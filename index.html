<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>STELLAR ASSAULT - 3D Space Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            color: #fff;
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-title {
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: 0.5rem;
            text-transform: uppercase;
            background: linear-gradient(90deg, #00f5ff, #bf00ff, #00f5ff);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 3s ease infinite;
            margin-bottom: 2rem;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
        }

        @keyframes gradient-shift {
            0%, 100% { background-position: 0% center; }
            50% { background-position: 200% center; }
        }

        .loading-bar-container {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00f5ff, #bf00ff);
            border-radius: 2px;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.8);
        }

        .loading-text {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.2rem;
        }

        /* Main Menu */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.7) 100%);
        }

        #main-menu.active {
            display: flex;
        }

        .menu-title {
            font-size: 4rem;
            font-weight: 800;
            letter-spacing: 1rem;
            text-transform: uppercase;
            background: linear-gradient(180deg, #fff 0%, #00f5ff 50%, #bf00ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 50px rgba(0, 245, 255, 0.5);
            animation: title-glow 2s ease-in-out infinite alternate;
        }

        @keyframes title-glow {
            from { filter: drop-shadow(0 0 20px rgba(0, 245, 255, 0.3)); }
            to { filter: drop-shadow(0 0 40px rgba(191, 0, 255, 0.5)); }
        }

        .menu-subtitle {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 0.5rem;
            margin-bottom: 3rem;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .menu-btn {
            padding: 1rem 3rem;
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 0.3rem;
            text-transform: uppercase;
            background: transparent;
            border: 2px solid rgba(0, 245, 255, 0.5);
            color: #00f5ff;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            clip-path: polygon(10px 0, 100% 0, calc(100% - 10px) 100%, 0 100%);
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 245, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .menu-btn:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: #00f5ff;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.3), inset 0 0 30px rgba(0, 245, 255, 0.1);
            transform: scale(1.05);
        }

        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
        }

        .menu-controls span {
            margin: 0 1rem;
        }

        .key {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            font-family: monospace;
            margin: 0 0.2rem;
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95) 0%, rgba(10, 10, 30, 0.95) 100%);
            border: 2px solid rgba(0, 245, 255, 0.4);
            border-radius: 10px;
            padding: 2rem 3rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 245, 255, 0.2), inset 0 0 30px rgba(0, 245, 255, 0.05);
        }

        .modal-title {
            font-size: 2rem;
            color: #00f5ff;
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
            letter-spacing: 0.3rem;
        }

        .modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: transparent;
            border: 1px solid rgba(255, 100, 100, 0.5);
            color: #ff6666;
            font-size: 1.5rem;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .modal-close:hover {
            background: rgba(255, 100, 100, 0.2);
            border-color: #ff6666;
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.3);
        }

        /* Controls Modal */
        .controls-section {
            margin-bottom: 1.5rem;
        }

        .controls-section-title {
            color: #bf00ff;
            font-size: 1.2rem;
            margin-bottom: 0.8rem;
            border-bottom: 1px solid rgba(191, 0, 255, 0.3);
            padding-bottom: 0.3rem;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-action {
            color: rgba(255, 255, 255, 0.8);
        }

        .control-keys {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .control-keys .key {
            background: rgba(0, 245, 255, 0.1);
            border-color: rgba(0, 245, 255, 0.4);
            color: #00f5ff;
            padding: 0.3rem 0.6rem;
        }

        .control-or {
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
        }

        /* Settings Modal */
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setting-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
        }

        .setting-description {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
            margin-top: 0.2rem;
        }

        .setting-control {
            display: flex;
            gap: 0.5rem;
        }

        /* Difficulty Buttons */
        .difficulty-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }

        .difficulty-btn:hover {
            border-color: #00f5ff;
            color: #00f5ff;
        }

        .difficulty-btn.active {
            background: rgba(0, 245, 255, 0.2);
            border-color: #00f5ff;
            color: #00f5ff;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }

        .difficulty-btn.easy.active {
            background: rgba(100, 255, 100, 0.2);
            border-color: #66ff66;
            color: #66ff66;
            box-shadow: 0 0 15px rgba(100, 255, 100, 0.3);
        }

        .difficulty-btn.hard.active {
            background: rgba(255, 100, 100, 0.2);
            border-color: #ff6666;
            color: #ff6666;
            box-shadow: 0 0 15px rgba(255, 100, 100, 0.3);
        }

        .difficulty-btn.nightmare.active {
            background: rgba(191, 0, 255, 0.2);
            border-color: #bf00ff;
            color: #bf00ff;
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.3);
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .toggle-switch.active {
            background: rgba(0, 245, 255, 0.3);
            border-color: #00f5ff;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle-switch.active::after {
            left: 26px;
            background: #00f5ff;
        }

        /* Slider */
        .setting-slider {
            width: 120px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        .setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00f5ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }

        .setting-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00f5ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            color: #00f5ff;
            min-width: 40px;
            text-align: right;
        }

        /* Apply Button */
        .modal-apply-btn {
            display: block;
            margin: 1.5rem auto 0;
            padding: 0.8rem 2rem;
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.2) 0%, rgba(191, 0, 255, 0.2) 100%);
            border: 2px solid #00f5ff;
            color: #00f5ff;
            font-size: 1rem;
            letter-spacing: 0.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-apply-btn:hover {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.4) 0%, rgba(191, 0, 255, 0.4) 100%);
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.4);
            transform: scale(1.05);
        }

        /* Scan Lines Effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99;
            opacity: 0.03;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.5),
                rgba(0, 0, 0, 0.5) 1px,
                transparent 1px,
                transparent 2px
            );
        }

        /* Performance Stats */
        #stats {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 200;
            color: #00f5ff;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 3px;
            display: none;
        }

        #stats.visible {
            display: block;
        }

        /* Crosshair - ÈùûË°®Á§∫ */
        #crosshair {
            display: none !important;
        }

        #crosshair.visible {
            display: none !important;
        }

        .crosshair-ring {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(0, 245, 255, 0.6);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: crosshair-pulse 2s ease-in-out infinite;
        }

        .crosshair-ring-inner {
            width: 30px;
            height: 30px;
            border: 1px solid rgba(0, 245, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair-dot {
            width: 4px;
            height: 4px;
            background: #00f5ff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #00f5ff;
        }

        .crosshair-line {
            position: absolute;
            background: rgba(0, 245, 255, 0.6);
        }

        .crosshair-line.top {
            width: 2px;
            height: 15px;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair-line.bottom {
            width: 2px;
            height: 15px;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair-line.left {
            width: 15px;
            height: 2px;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
        }

        .crosshair-line.right {
            width: 15px;
            height: 2px;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
        }

        @keyframes crosshair-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.6; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        }

        /* Barrel Roll Indicator */
        #barrel-roll-indicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        #barrel-roll-indicator.visible {
            opacity: 1;
        }

        .roll-charge {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(0, 245, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #00f5ff;
            position: relative;
            overflow: hidden;
        }

        .roll-charge.ready {
            border-color: #00f5ff;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
        }

        .roll-charge.cooldown::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--cooldown, 0%);
            background: rgba(0, 245, 255, 0.3);
            transition: height 0.1s linear;
        }

        /* Bomb Indicator */
        #bomb-indicator {
            position: fixed;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        #bomb-indicator.visible {
            opacity: 1;
        }

        .bomb-charge {
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255, 0, 255, 0.5);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ff00ff;
            position: relative;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.5);
        }

        .bomb-charge.ready {
            border-color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
            animation: bombPulse 1.5s ease-in-out infinite;
        }

        .bomb-charge.used {
            border-color: rgba(100, 100, 100, 0.5);
            color: #666;
        }

        @keyframes bombPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        #bomb-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #ff00ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            white-space: nowrap;
        }

        /* Wave Indicator */
        #wave-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #wave-indicator.visible {
            opacity: 1;
        }

        .wave-text {
            font-size: 1.2rem;
            color: #00f5ff;
            letter-spacing: 0.3rem;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(0, 245, 255, 0.8);
        }

        .wave-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
        }

        /* Score Display */
        #score-display {
            position: fixed;
            top: 20px;
            left: 20px;
            text-align: left;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #score-display.visible {
            opacity: 1;
        }

        .score-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.2rem;
        }

        .score-value {
            font-size: 2rem;
            font-weight: 700;
            color: #00f5ff;
            text-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
        }

        .kills-display {
            font-size: 0.9rem;
            color: #ff6600;
            margin-top: 5px;
            opacity: 1;
        }

        /* Health Bar */
        #health-bar {
            position: fixed;
            bottom: 30px;
            left: 20px;
            width: 200px;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #health-bar.visible {
            opacity: 1;
        }

        .bar-container {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }

        .bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff3333, #ff6666);
            box-shadow: 0 0 10px rgba(255, 50, 50, 0.5);
        }

        .shield-fill {
            background: linear-gradient(90deg, #00aaff, #00ffff);
            box-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
        }

        .bar-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.1rem;
            margin-bottom: 2px;
        }

        /* Enemy Count */
        #enemy-count {
            position: fixed;
            top: 110px;
            left: 20px;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }

        #enemy-count.visible {
            opacity: 1;
        }
        
        /* Power Level Display */
        #power-level-display {
            position: fixed;
            top: 140px;
            left: 20px;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        #power-level-display.visible {
            opacity: 1;
        }
        
        #power-level-value {
            font-weight: bold;
            color: #ffffff;
            transition: color 0.3s ease;
        }
        
        #power-level-bar {
            width: 100px;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 0, 0.5);
            border-radius: 3px;
            margin-top: 4px;
            overflow: hidden;
        }
        
        #power-level-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ffff00, #ff8800);
            transition: width 0.3s ease, background 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
        }
        
        /* Power Up Notification Animation */
        @keyframes powerUpNotify {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1.1);
            }
            40% {
                transform: translateX(-50%) translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px) scale(1);
            }
        }
        
        /* Boss Reward Notification Animation */
        @keyframes bossRewardNotify {
            0% {
                opacity: 0;
                transform: translateX(-50%) scale(0.5);
            }
            15% {
                opacity: 1;
                transform: translateX(-50%) scale(1.2);
            }
            30% {
                transform: translateX(-50%) scale(1);
            }
            70% {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px) scale(0.9);
            }
        }
        
        /* Boss HP Bar */
        #boss-hp-container {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 55;
            text-align: center;
            width: 60%;
            max-width: 600px;
        }
        
        #boss-name {
            font-size: 1.2rem;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff0088;
            margin-bottom: 8px;
            font-weight: bold;
            letter-spacing: 3px;
        }
        
        #boss-hp-bar-bg {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        #boss-hp-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0066, #ff00ff, #ff0066);
            border-radius: 8px;
            transition: width 0.2s ease;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* Wave Announcement */
        #wave-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 60;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        #wave-announcement.visible {
            opacity: 1;
        }

        .announcement-text {
            font-size: 3rem;
            font-weight: 800;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5rem;
            text-shadow: 0 0 50px rgba(0, 245, 255, 0.8);
            animation: announcement-pulse 0.5s ease-out;
        }

        .announcement-sub {
            font-size: 1.2rem;
            color: #00f5ff;
            margin-top: 10px;
            letter-spacing: 0.3rem;
        }

        @keyframes announcement-pulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes damage-pulse {
            0% { opacity: 1; transform: translateX(-50%) scale(1); }
            100% { opacity: 0; transform: translateX(-50%) scale(1.5) translateY(-30px); }
        }

        /* Sound Toggle Button */
        #sound-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(0, 245, 255, 0.5);
            border-radius: 50%;
            cursor: pointer;
            z-index: 200;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
        }

        #sound-toggle.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #sound-toggle:hover {
            background: rgba(0, 245, 255, 0.2);
            border-color: #00f5ff;
            transform: scale(1.1);
        }

        #sound-toggle svg {
            width: 24px;
            height: 24px;
            fill: #00f5ff;
        }

        #sound-toggle.muted svg.sound-on {
            display: none;
        }

        #sound-toggle:not(.muted) svg.sound-off {
            display: none;
        }

        /* Game Over Screen */
        #game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(20, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.95) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        #game-over-screen.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .game-over-content {
            text-align: center;
        }

        .game-over-title {
            font-size: 4rem;
            font-weight: 900;
            color: #ff3333;
            text-shadow: 0 0 30px rgba(255, 50, 50, 0.8), 0 0 60px rgba(255, 50, 50, 0.4);
            letter-spacing: 0.5rem;
            margin-bottom: 2rem;
            animation: game-over-pulse 2s ease-in-out infinite;
        }

        @keyframes game-over-pulse {
            0%, 100% { text-shadow: 0 0 30px rgba(255, 50, 50, 0.8), 0 0 60px rgba(255, 50, 50, 0.4); }
            50% { text-shadow: 0 0 50px rgba(255, 50, 50, 1), 0 0 100px rgba(255, 50, 50, 0.6); }
        }

        .final-stats {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 50, 50, 0.3);
            border-radius: 10px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.2rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00f5ff;
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }

        .game-over-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .menu-btn.secondary {
            background: transparent;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .menu-btn.secondary:hover {
            border-color: #00f5ff;
            background: rgba(0, 245, 255, 0.1);
        }

        /* Pause Screen */
        #pause-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #pause-screen.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .pause-content {
            text-align: center;
        }

        .pause-title {
            font-size: 3rem;
            font-weight: 900;
            color: #00f5ff;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.8);
            letter-spacing: 0.8rem;
            margin-bottom: 2rem;
        }

        .pause-stats {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 10px;
            padding: 1.5rem 2rem;
            margin-bottom: 2rem;
            min-width: 300px;
        }

        .pause-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1rem;
        }

        .pause-hint {
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            letter-spacing: 0.1rem;
        }

        /* FPS Counter */
        #fps-counter {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 0.8rem;
            color: rgba(0, 245, 255, 0.7);
            font-family: monospace;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #fps-counter.visible {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .menu-title {
                font-size: 2rem;
                letter-spacing: 0.3rem;
            }

            .loading-title {
                font-size: 1.5rem;
                letter-spacing: 0.2rem;
            }

            .menu-btn {
                padding: 0.8rem 2rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <!-- Scan Lines Overlay -->
    <div class="scanlines"></div>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <h1 class="loading-title">STELLAR ASSAULT</h1>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loading-bar"></div>
        </div>
        <p class="loading-text" id="loading-text">INITIALIZING SYSTEMS...</p>
    </div>

    <!-- Main Menu -->
    <div id="main-menu">
        <h1 class="menu-title">STELLAR ASSAULT</h1>
        <p class="menu-subtitle">3D SPACE SHOOTER</p>
        <div class="menu-buttons">
            <button class="menu-btn" id="btn-start">START MISSION</button>
            <button class="menu-btn" id="btn-controls">CONTROLS</button>
            <button class="menu-btn" id="btn-settings">SETTINGS</button>
        </div>
        <div class="menu-controls">
            <span><span class="key">‚Üë</span><span class="key">‚Üì</span><span class="key">‚Üê</span><span class="key">‚Üí</span> / <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> Move</span>
            <span><span class="key">SPACE</span> / <span class="key">CLICK</span> Fire</span>
            <span><span class="key">B</span> Bomb (√ó3/Wave)</span>
            <span><span class="key">Q</span><span class="key">E</span> Barrel Roll</span>
        </div>
    </div>

    <!-- Controls Modal -->
    <div class="modal-overlay" id="controls-modal">
        <div class="modal-content" style="position: relative;">
            <button class="modal-close" id="controls-close">√ó</button>
            <h2 class="modal-title">CONTROLS</h2>
            
            <div class="controls-section">
                <h3 class="controls-section-title">MOVEMENT</h3>
                <div class="control-row">
                    <span class="control-action">Move Up</span>
                    <div class="control-keys">
                        <span class="key">W</span>
                        <span class="control-or">or</span>
                        <span class="key">‚Üë</span>
                    </div>
                </div>
                <div class="control-row">
                    <span class="control-action">Move Down</span>
                    <div class="control-keys">
                        <span class="key">S</span>
                        <span class="control-or">or</span>
                        <span class="key">‚Üì</span>
                    </div>
                </div>
                <div class="control-row">
                    <span class="control-action">Move Left</span>
                    <div class="control-keys">
                        <span class="key">A</span>
                        <span class="control-or">or</span>
                        <span class="key">‚Üê</span>
                    </div>
                </div>
                <div class="control-row">
                    <span class="control-action">Move Right</span>
                    <div class="control-keys">
                        <span class="key">D</span>
                        <span class="control-or">or</span>
                        <span class="key">‚Üí</span>
                    </div>
                </div>
            </div>

            <div class="controls-section">
                <h3 class="controls-section-title">COMBAT</h3>
                <div class="control-row">
                    <span class="control-action">Fire</span>
                    <div class="control-keys">
                        <span class="key">SPACE</span>
                        <span class="control-or">or</span>
                        <span class="key">LEFT CLICK</span>
                    </div>
                </div>
                <div class="control-row">
                    <span class="control-action">Bomb (Screen Clear)</span>
                    <div class="control-keys">
                        <span class="key">B</span>
                    </div>
                </div>
            </div>

            <div class="controls-section">
                <h3 class="controls-section-title">SPECIAL MOVES</h3>
                <div class="control-row">
                    <span class="control-action">Barrel Roll Left</span>
                    <div class="control-keys">
                        <span class="key">Q</span>
                    </div>
                </div>
                <div class="control-row">
                    <span class="control-action">Barrel Roll Right</span>
                    <div class="control-keys">
                        <span class="key">E</span>
                    </div>
                </div>
            </div>

            <div class="controls-section">
                <h3 class="controls-section-title">SYSTEM</h3>
                <div class="control-row">
                    <span class="control-action">Pause Game</span>
                    <div class="control-keys">
                        <span class="key">ESC</span>
                    </div>
                </div>
                <div class="control-row">
                    <span class="control-action">Toggle Sound</span>
                    <div class="control-keys">
                        <span class="key">M</span>
                    </div>
                </div>
                <div class="control-row">
                    <span class="control-action">Toggle FPS Counter</span>
                    <div class="control-keys">
                        <span class="key">F3</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal">
        <div class="modal-content" style="position: relative;">
            <button class="modal-close" id="settings-close">√ó</button>
            <h2 class="modal-title">SETTINGS</h2>
            
            <div class="setting-row">
                <div>
                    <div class="setting-label">Difficulty</div>
                    <div class="setting-description">Affects enemy HP, damage, and spawn rate</div>
                </div>
                <div class="setting-control">
                    <button class="difficulty-btn easy" data-difficulty="easy">EASY</button>
                    <button class="difficulty-btn active" data-difficulty="normal">NORMAL</button>
                    <button class="difficulty-btn hard" data-difficulty="hard">HARD</button>
                    <button class="difficulty-btn nightmare" data-difficulty="nightmare">NIGHTMARE</button>
                </div>
            </div>

            <div class="setting-row">
                <div>
                    <div class="setting-label">Mouse Sensitivity</div>
                    <div class="setting-description">Aiming sensitivity with mouse</div>
                </div>
                <div class="setting-control">
                    <input type="range" class="setting-slider" id="sensitivity-slider" min="0.5" max="2" step="0.1" value="1">
                    <span class="slider-value" id="sensitivity-value">1.0</span>
                </div>
            </div>

            <div class="setting-row">
                <div>
                    <div class="setting-label">Master Volume</div>
                    <div class="setting-description">Overall sound volume</div>
                </div>
                <div class="setting-control">
                    <input type="range" class="setting-slider" id="volume-slider" min="0" max="100" step="5" value="70">
                    <span class="slider-value" id="volume-value">70%</span>
                </div>
            </div>

            <div class="setting-row">
                <div>
                    <div class="setting-label">Screen Shake</div>
                    <div class="setting-description">Camera shake on impacts</div>
                </div>
                <div class="setting-control">
                    <div class="toggle-switch active" id="screenshake-toggle"></div>
                </div>
            </div>

            <div class="setting-row">
                <div>
                    <div class="setting-label">Show FPS Counter</div>
                    <div class="setting-description">Display framerate in corner</div>
                </div>
                <div class="setting-control">
                    <div class="toggle-switch" id="fps-toggle"></div>
                </div>
            </div>

            <div class="setting-row">
                <div>
                    <div class="setting-label">Auto-Fire</div>
                    <div class="setting-description">Hold fire button to continuously shoot</div>
                </div>
                <div class="setting-control">
                    <div class="toggle-switch active" id="autofire-toggle"></div>
                </div>
            </div>

            <div class="setting-row">
                <div>
                    <div class="setting-label">Invert Y-Axis</div>
                    <div class="setting-description">Invert vertical movement controls</div>
                </div>
                <div class="setting-control">
                    <div class="toggle-switch" id="inverty-toggle"></div>
                </div>
            </div>

            <button class="modal-apply-btn" id="settings-apply">APPLY & CLOSE</button>
        </div>
    </div>

    <!-- Performance Stats -->
    <div id="stats">
        FPS: <span id="fps">60</span> | 
        Objects: <span id="obj-count">0</span>
    </div>

    <!-- Crosshair -->
    <div id="crosshair">
        <div class="crosshair-ring"></div>
        <div class="crosshair-ring-inner"></div>
        <div class="crosshair-dot"></div>
        <div class="crosshair-line top"></div>
        <div class="crosshair-line bottom"></div>
        <div class="crosshair-line left"></div>
        <div class="crosshair-line right"></div>
    </div>

    <!-- Barrel Roll Indicator -->
    <div id="barrel-roll-indicator">
        <div class="roll-charge ready" id="roll-left">Q</div>
        <div class="roll-charge ready" id="roll-right">E</div>
    </div>

    <!-- Bomb Indicator -->
    <div id="bomb-indicator">
        <div class="bomb-charge ready" id="bomb-1">üí£</div>
        <div class="bomb-charge ready" id="bomb-2">üí£</div>
        <div class="bomb-charge ready" id="bomb-3">üí£</div>
        <span id="bomb-label">BOMB [B]</span>
    </div>

    <!-- Wave Indicator -->
    <div id="wave-indicator">
        <div class="wave-text">WAVE</div>
        <div class="wave-number" id="wave-number">1</div>
    </div>

    <!-- Score Display -->
    <div id="score-display">
        <div class="score-label">SCORE</div>
        <div class="score-value" id="score-value">0</div>
        <div class="kills-display">
            <span id="asteroid-kills">0</span> ASTEROIDS | <span id="enemy-kills">0</span> ENEMIES
        </div>
    </div>

    <!-- Health Bar -->
    <div id="health-bar">
        <div class="bar-label">SHIELD</div>
        <div class="bar-container">
            <div class="bar-fill shield-fill" id="shield-bar" style="width: 100%"></div>
        </div>
        <div class="bar-label">HULL</div>
        <div class="bar-container">
            <div class="bar-fill health-fill" id="health-bar-fill" style="width: 100%"></div>
        </div>
    </div>

    <!-- Sound Toggle -->
    <button id="sound-toggle" title="Toggle Sound">
        <svg class="sound-on" viewBox="0 0 24 24">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
        <svg class="sound-off" viewBox="0 0 24 24">
            <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
        </svg>
    </button>

    <!-- Enemy Count -->
    <div id="enemy-count">
        ENEMIES: <span id="enemy-count-value">0</span>
    </div>
    
    <!-- Power Level Display -->
    <div id="power-level-display">
        POWER: <span id="power-level-value">0</span>
        <div id="power-level-bar">
            <div id="power-level-fill"></div>
        </div>
    </div>
    
    <!-- Boss HP Bar -->
    <div id="boss-hp-container" style="display: none;">
        <div id="boss-name">BOSS</div>
        <div id="boss-hp-bar-bg">
            <div id="boss-hp-bar-fill"></div>
        </div>
    </div>

    <!-- Wave Announcement -->
    <div id="wave-announcement">
        <div class="announcement-text" id="announcement-text">WAVE 1</div>
        <div class="announcement-sub" id="announcement-sub">PREPARE FOR BATTLE</div>
    </div>

    <!-- Pause Screen -->
    <div id="pause-screen">
        <div class="pause-content">
            <h1 class="pause-title">PAUSED</h1>
            <div class="pause-stats">
                <div class="stat-row">
                    <span class="stat-label">CURRENT SCORE</span>
                    <span class="stat-value" id="pause-score">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">WAVE</span>
                    <span class="stat-value" id="pause-wave">1</span>
                </div>
            </div>
            <div class="pause-buttons">
                <button class="menu-btn" id="btn-resume">RESUME</button>
                <button class="menu-btn secondary" id="btn-quit">QUIT TO MENU</button>
            </div>
            <p class="pause-hint">Press ESC to resume</p>
        </div>
    </div>

    <!-- FPS Counter -->
    <div id="fps-counter">FPS: 60</div>

    <!-- Game Over Screen -->
    <div id="game-over-screen">
        <div class="game-over-content">
            <h1 class="game-over-title">GAME OVER</h1>
            <div class="final-stats">
                <div class="stat-row">
                    <span class="stat-label">FINAL SCORE</span>
                    <span class="stat-value" id="final-score">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">WAVES SURVIVED</span>
                    <span class="stat-value" id="final-waves">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ASTEROIDS DESTROYED</span>
                    <span class="stat-value" id="final-asteroids">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ENEMIES DESTROYED</span>
                    <span class="stat-value" id="final-enemies">0</span>
                </div>
            </div>
            <div class="game-over-buttons">
                <button class="menu-btn" id="btn-restart">PLAY AGAIN</button>
                <button class="menu-btn secondary" id="btn-to-menu">MAIN MENU</button>
            </div>
        </div>
    </div>

    <!-- Three.js and Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post Processing -->
    <script>
        // EffectComposer and Passes (inline for single file)
        THREE.EffectComposer = function(renderer, renderTarget) {
            this.renderer = renderer;
            if (renderTarget === undefined) {
                const size = renderer.getSize(new THREE.Vector2());
                this._pixelRatio = renderer.getPixelRatio();
                this._width = size.width;
                this._height = size.height;
                renderTarget = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio);
                renderTarget.texture.name = 'EffectComposer.rt1';
            }
            this.renderTarget1 = renderTarget;
            this.renderTarget2 = renderTarget.clone();
            this.renderTarget2.texture.name = 'EffectComposer.rt2';
            this.writeBuffer = this.renderTarget1;
            this.readBuffer = this.renderTarget2;
            this.renderToScreen = true;
            this.passes = [];
        };

        Object.assign(THREE.EffectComposer.prototype, {
            swapBuffers: function() {
                const tmp = this.readBuffer;
                this.readBuffer = this.writeBuffer;
                this.writeBuffer = tmp;
            },
            addPass: function(pass) {
                this.passes.push(pass);
                pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
            },
            render: function(deltaTime) {
                const maskActive = false;
                let pass, i;
                const il = this.passes.length;
                for (i = 0; i < il; i++) {
                    pass = this.passes[i];
                    if (pass.enabled === false) continue;
                    pass.renderToScreen = (this.renderToScreen && i === il - 1);
                    pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
                    if (pass.needsSwap) {
                        this.swapBuffers();
                    }
                }
            },
            setSize: function(width, height) {
                this._width = width;
                this._height = height;
                const effectiveWidth = this._width * this._pixelRatio;
                const effectiveHeight = this._height * this._pixelRatio;
                this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
                this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
                for (let i = 0; i < this.passes.length; i++) {
                    this.passes[i].setSize(effectiveWidth, effectiveHeight);
                }
            }
        });

        THREE.Pass = function() {
            this.enabled = true;
            this.needsSwap = true;
            this.clear = false;
            this.renderToScreen = false;
        };

        Object.assign(THREE.Pass.prototype, {
            setSize: function() {},
            render: function() {
                console.error('THREE.Pass: .render() must be implemented in derived pass.');
            }
        });

        THREE.Pass.FullScreenQuad = (function() {
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const geometry = new THREE.PlaneGeometry(2, 2);
            const FullScreenQuad = function(material) {
                this._mesh = new THREE.Mesh(geometry, material);
            };
            Object.defineProperty(FullScreenQuad.prototype, 'material', {
                get: function() { return this._mesh.material; },
                set: function(value) { this._mesh.material = value; }
            });
            Object.assign(FullScreenQuad.prototype, {
                dispose: function() { this._mesh.geometry.dispose(); },
                render: function(renderer) {
                    renderer.render(this._mesh, camera);
                }
            });
            return FullScreenQuad;
        })();

        // RenderPass
        THREE.RenderPass = function(scene, camera) {
            THREE.Pass.call(this);
            this.scene = scene;
            this.camera = camera;
            this.clear = true;
            this.needsSwap = false;
        };

        THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
            constructor: THREE.RenderPass,
            render: function(renderer, writeBuffer, readBuffer) {
                renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
                if (this.clear) renderer.clear();
                renderer.render(this.scene, this.camera);
            }
        });

        // UnrealBloomPass
        THREE.UnrealBloomPass = function(resolution, strength, radius, threshold) {
            THREE.Pass.call(this);
            this.strength = (strength !== undefined) ? strength : 1;
            this.radius = radius;
            this.threshold = threshold;
            this.resolution = (resolution !== undefined) ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);
            
            this.clearColor = new THREE.Color(0, 0, 0);
            
            const pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };
            this.renderTargetsHorizontal = [];
            this.renderTargetsVertical = [];
            this.nMips = 5;
            let resx = Math.round(this.resolution.x / 2);
            let resy = Math.round(this.resolution.y / 2);
            
            this.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);
            this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';
            
            for (let i = 0; i < this.nMips; i++) {
                const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);
                renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;
                this.renderTargetsHorizontal.push(renderTargetHorizonal);
                const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);
                renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;
                this.renderTargetsVertical.push(renderTargetVertical);
                resx = Math.round(resx / 2);
                resy = Math.round(resy / 2);
            }

            // Luminosity high pass shader
            const highPassShader = {
                uniforms: {
                    'tDiffuse': { value: null },
                    'luminosityThreshold': { value: 1.0 },
                    'smoothWidth': { value: 1.0 },
                    'defaultColor': { value: new THREE.Color(0x000000) },
                    'defaultOpacity': { value: 0.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec3 defaultColor;
                    uniform float defaultOpacity;
                    uniform float luminosityThreshold;
                    uniform float smoothWidth;
                    varying vec2 vUv;
                    void main() {
                        vec4 texel = texture2D(tDiffuse, vUv);
                        vec3 luma = vec3(0.299, 0.587, 0.114);
                        float v = dot(texel.xyz, luma);
                        vec4 outputColor = vec4(defaultColor.rgb, defaultOpacity);
                        float alpha = smoothstep(luminosityThreshold, luminosityThreshold + smoothWidth, v);
                        gl_FragColor = mix(outputColor, texel, alpha);
                    }
                `
            };

            this.materialHighPassFilter = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone(highPassShader.uniforms),
                vertexShader: highPassShader.vertexShader,
                fragmentShader: highPassShader.fragmentShader
            });
            this.materialHighPassFilter.uniforms['luminosityThreshold'].value = threshold;
            this.materialHighPassFilter.uniforms['smoothWidth'].value = 0.01;

            // Gaussian Blur shader
            this.separableBlurMaterials = [];
            const kernelSizeArray = [3, 5, 7, 9, 11];
            resx = Math.round(this.resolution.x / 2);
            resy = Math.round(this.resolution.y / 2);

            for (let i = 0; i < this.nMips; i++) {
                this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
                this.separableBlurMaterials[i].uniforms['texSize'].value = new THREE.Vector2(resx, resy);
                resx = Math.round(resx / 2);
                resy = Math.round(resy / 2);
            }

            // Composite shader
            this.compositeMaterial = this.getCompositeMaterial(this.nMips);
            this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;
            this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;
            this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;
            this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;
            this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;
            this.compositeMaterial.uniforms['bloomStrength'].value = strength;
            this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;
            
            const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
            this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;
            this.bloomTintColors = [
                new THREE.Vector3(1, 1, 1),
                new THREE.Vector3(1, 1, 1),
                new THREE.Vector3(1, 1, 1),
                new THREE.Vector3(1, 1, 1),
                new THREE.Vector3(1, 1, 1)
            ];
            this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;

            // Blend shader
            const copyShader = {
                uniforms: {
                    'tDiffuse': { value: null },
                    'opacity': { value: 1.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float opacity;
                    uniform sampler2D tDiffuse;
                    varying vec2 vUv;
                    void main() {
                        vec4 texel = texture2D(tDiffuse, vUv);
                        gl_FragColor = opacity * texel;
                    }
                `
            };

            this.materialCopy = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone(copyShader.uniforms),
                vertexShader: copyShader.vertexShader,
                fragmentShader: copyShader.fragmentShader,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                depthWrite: false,
                transparent: true
            });

            this.enabled = true;
            this.needsSwap = false;
            this.fsQuad = new THREE.Pass.FullScreenQuad(null);
        };

        THREE.UnrealBloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
            constructor: THREE.UnrealBloomPass,
            
            getSeperableBlurMaterial: function(kernelRadius) {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        'colorTexture': { value: null },
                        'texSize': { value: new THREE.Vector2(0.5, 0.5) },
                        'direction': { value: new THREE.Vector2(0.5, 0.5) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        #include <common>
                        varying vec2 vUv;
                        uniform sampler2D colorTexture;
                        uniform vec2 texSize;
                        uniform vec2 direction;
                        
                        float gaussianPdf(in float x, in float sigma) {
                            return 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;
                        }
                        
                        void main() {
                            vec2 invSize = 1.0 / texSize;
                            float fSigma = float(${kernelRadius});
                            float weightSum = gaussianPdf(0.0, fSigma);
                            vec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;
                            for (int i = 1; i < ${kernelRadius}; i++) {
                                float x = float(i);
                                float w = gaussianPdf(x, fSigma);
                                vec2 uvOffset = direction * invSize * x;
                                vec3 sample1 = texture2D(colorTexture, vUv + uvOffset).rgb;
                                vec3 sample2 = texture2D(colorTexture, vUv - uvOffset).rgb;
                                diffuseSum += (sample1 + sample2) * w;
                                weightSum += 2.0 * w;
                            }
                            gl_FragColor = vec4(diffuseSum / weightSum, 1.0);
                        }
                    `
                });
            },
            
            getCompositeMaterial: function(nMips) {
                return new THREE.ShaderMaterial({
                    uniforms: {
                        'blurTexture1': { value: null },
                        'blurTexture2': { value: null },
                        'blurTexture3': { value: null },
                        'blurTexture4': { value: null },
                        'blurTexture5': { value: null },
                        'bloomStrength': { value: 1.0 },
                        'bloomFactors': { value: null },
                        'bloomTintColors': { value: null },
                        'bloomRadius': { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying vec2 vUv;
                        uniform sampler2D blurTexture1;
                        uniform sampler2D blurTexture2;
                        uniform sampler2D blurTexture3;
                        uniform sampler2D blurTexture4;
                        uniform sampler2D blurTexture5;
                        uniform float bloomStrength;
                        uniform float bloomRadius;
                        uniform float bloomFactors[5];
                        uniform vec3 bloomTintColors[5];
                        
                        float lerpBloomFactor(const in float factor) {
                            float mirrorFactor = 1.2 - factor;
                            return mix(factor, mirrorFactor, bloomRadius);
                        }
                        
                        void main() {
                            gl_FragColor = bloomStrength * (
                                lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
                                lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
                                lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
                                lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
                                lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv)
                            );
                        }
                    `
                });
            },
            
            render: function(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
                this.materialHighPassFilter.uniforms['tDiffuse'].value = readBuffer.texture;
                this.materialHighPassFilter.uniforms['luminosityThreshold'].value = this.threshold;
                this.fsQuad.material = this.materialHighPassFilter;
                renderer.setRenderTarget(this.renderTargetBright);
                renderer.clear();
                this.fsQuad.render(renderer);

                let inputRenderTarget = this.renderTargetBright;
                for (let i = 0; i < this.nMips; i++) {
                    this.fsQuad.material = this.separableBlurMaterials[i];
                    this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;
                    this.separableBlurMaterials[i].uniforms['direction'].value = new THREE.Vector2(1.0, 0.0);
                    renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
                    renderer.clear();
                    this.fsQuad.render(renderer);

                    this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;
                    this.separableBlurMaterials[i].uniforms['direction'].value = new THREE.Vector2(0.0, 1.0);
                    renderer.setRenderTarget(this.renderTargetsVertical[i]);
                    renderer.clear();
                    this.fsQuad.render(renderer);
                    inputRenderTarget = this.renderTargetsVertical[i];
                }

                this.fsQuad.material = this.compositeMaterial;
                this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;
                this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;
                renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
                renderer.clear();
                this.fsQuad.render(renderer);

                this.fsQuad.material = this.materialCopy;
                this.materialCopy.uniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;
                if (maskActive) renderer.state.buffers.stencil.setTest(false);
                if (this.renderToScreen) {
                    renderer.setRenderTarget(null);
                    this.fsQuad.render(renderer);
                } else {
                    renderer.setRenderTarget(readBuffer);
                    this.fsQuad.render(renderer);
                }
            },
            
            setSize: function(width, height) {
                let resx = Math.round(width / 2);
                let resy = Math.round(height / 2);
                this.renderTargetBright.setSize(resx, resy);
                for (let i = 0; i < this.nMips; i++) {
                    this.renderTargetsHorizontal[i].setSize(resx, resy);
                    this.renderTargetsVertical[i].setSize(resx, resy);
                    this.separableBlurMaterials[i].uniforms['texSize'].value = new THREE.Vector2(resx, resy);
                    resx = Math.round(resx / 2);
                    resy = Math.round(resy / 2);
                }
            }
        });
    </script>

    <!-- Main Game Script -->
    <script>
        // ============================================
        // STELLAR ASSAULT - 3D Space Shooter
        // Part 1: Game Structure + 3D Scene Setup
        // ============================================

        // Game State Management
        const GameState = {
            LOADING: 'loading',
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'game_over',
            VICTORY: 'victory'
        };

        // ============================================
        // Game Settings (Global)
        // ============================================
        const GameSettings = {
            difficulty: 'normal',  // easy, normal, hard, nightmare
            mouseSensitivity: 1.0,
            masterVolume: 0.7,
            screenShake: true,
            showFPS: false,
            autoFire: true,
            invertY: false,
            
            // Difficulty multipliers
            getDifficultyMultipliers() {
                switch (this.difficulty) {
                    case 'easy':
                        return {
                            enemyHP: 0.6,
                            enemyDamage: 0.5,
                            enemySpeed: 0.8,
                            spawnRate: 0.7,
                            playerDamage: 1.3,
                            scoreMultiplier: 0.5
                        };
                    case 'normal':
                        return {
                            enemyHP: 1.0,
                            enemyDamage: 1.0,
                            enemySpeed: 1.0,
                            spawnRate: 1.0,
                            playerDamage: 1.0,
                            scoreMultiplier: 1.0
                        };
                    case 'hard':
                        return {
                            enemyHP: 1.5,
                            enemyDamage: 1.5,
                            enemySpeed: 1.2,
                            spawnRate: 1.3,
                            playerDamage: 0.9,
                            scoreMultiplier: 1.5
                        };
                    case 'nightmare':
                        return {
                            enemyHP: 2.5,
                            enemyDamage: 2.0,
                            enemySpeed: 1.5,
                            spawnRate: 1.6,
                            playerDamage: 0.8,
                            scoreMultiplier: 3.0
                        };
                    default:
                        return this.getDifficultyMultipliers.call({ difficulty: 'normal' });
                }
            },

            // Save settings to localStorage
            save() {
                const data = {
                    difficulty: this.difficulty,
                    mouseSensitivity: this.mouseSensitivity,
                    masterVolume: this.masterVolume,
                    screenShake: this.screenShake,
                    showFPS: this.showFPS,
                    autoFire: this.autoFire,
                    invertY: this.invertY
                };
                localStorage.setItem('stellarAssaultSettings', JSON.stringify(data));
            },

            // Load settings from localStorage
            load() {
                const saved = localStorage.getItem('stellarAssaultSettings');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.difficulty = data.difficulty || 'normal';
                        this.mouseSensitivity = data.mouseSensitivity ?? 1.0;
                        this.masterVolume = data.masterVolume ?? 0.7;
                        this.screenShake = data.screenShake ?? true;
                        this.showFPS = data.showFPS ?? false;
                        this.autoFire = data.autoFire ?? true;
                        this.invertY = data.invertY ?? false;
                    } catch (e) {
                        console.warn('Failed to load settings:', e);
                    }
                }
            }
        };

        // ============================================
        // Input Manager
        // ============================================
        class InputManager {
            constructor() {
                this.keys = {};
                this.mouse = {
                    x: 0,
                    y: 0,
                    normalizedX: 0,
                    normalizedY: 0,
                    leftButton: false,
                    rightButton: false
                };
                this.touch = {
                    active: false,
                    x: 0,
                    y: 0
                };
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    // Prevent default for game keys
                    if (['Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE'].includes(e.code)) {
                        e.preventDefault();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Mouse
                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                    this.mouse.normalizedX = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.normalizedY = -(e.clientY / window.innerHeight) * 2 + 1;
                });

                window.addEventListener('mousedown', (e) => {
                    if (e.button === 0) this.mouse.leftButton = true;
                    if (e.button === 2) this.mouse.rightButton = true;
                });

                window.addEventListener('mouseup', (e) => {
                    if (e.button === 0) this.mouse.leftButton = false;
                    if (e.button === 2) this.mouse.rightButton = false;
                });

                // Prevent context menu
                window.addEventListener('contextmenu', (e) => e.preventDefault());

                // Touch support
                window.addEventListener('touchstart', (e) => {
                    this.touch.active = true;
                    this.touch.x = e.touches[0].clientX;
                    this.touch.y = e.touches[0].clientY;
                    this.mouse.leftButton = true;
                });

                window.addEventListener('touchmove', (e) => {
                    this.touch.x = e.touches[0].clientX;
                    this.touch.y = e.touches[0].clientY;
                    this.mouse.normalizedX = (this.touch.x / window.innerWidth) * 2 - 1;
                    this.mouse.normalizedY = -(this.touch.y / window.innerHeight) * 2 + 1;
                });

                window.addEventListener('touchend', () => {
                    this.touch.active = false;
                    this.mouse.leftButton = false;
                });

                // Pointer lock for better mouse control
                document.addEventListener('pointerlockchange', () => {
                    this.pointerLocked = document.pointerLockElement !== null;
                });
            }

            isKeyPressed(code) {
                return this.keys[code] === true;
            }

            getMovementVector() {
                const movement = { x: 0, y: 0, z: 0 };
                
                // Áü¢Âç∞„Ç≠„ÉºÔºö‰∏ä‰∏ã„ÅßÂâçÂæåÔºàYËª∏Ôºâ„ÄÅÂ∑¶Âè≥„ÅßÂ∑¶Âè≥ÔºàXËª∏Ôºâ
                if (this.isKeyPressed('ArrowUp') || this.isKeyPressed('KeyW')) movement.y = 1;
                if (this.isKeyPressed('ArrowDown') || this.isKeyPressed('KeyS')) movement.y = -1;
                if (this.isKeyPressed('ArrowLeft') || this.isKeyPressed('KeyA')) movement.x = -1;
                if (this.isKeyPressed('ArrowRight') || this.isKeyPressed('KeyD')) movement.x = 1;
                
                // YËª∏ÂèçËª¢Ë®≠ÂÆö
                if (GameSettings.invertY) {
                    movement.y = -movement.y;
                }
                
                return movement;
            }
        }

        // ============================================
        // Player Ship Class
        // ============================================
        class PlayerShip {
            constructor(scene) {
                this.scene = scene;
                this.mesh = null;
                this.engineGlows = [];
                this.engineParticles = null;
                this.shield = null;
                this.shieldActive = false;
                
                // Physics
                this.position = new THREE.Vector3(0, 0, 0);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.rotation = new THREE.Euler(0, 0, 0);
                this.targetRotation = new THREE.Euler(0, 0, 0);
                
                // Stats
                this.health = 100;
                this.maxHealth = 100;
                this.shields = 100;
                this.maxShields = 100;
                this.speed = 50;
                this.rotationSpeed = 3;
                
                // Barrel Roll
                this.barrelRollCharges = 2;
                this.maxBarrelRollCharges = 2;
                this.barrelRollCooldown = 0;
                this.barrelRollCooldownTime = 3;
                this.isBarrelRolling = false;
                this.barrelRollDirection = 0;
                this.barrelRollProgress = 0;
                this.invincible = false;
                
                // Bomb
                this.bombCount = 3;
                this.maxBombs = 3;
                this.bombCooldown = 0;
                this.bombCooldownTime = 1; // 1Áßí„ÅÆ„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥
                
                // Power-up System (0 = default, 1-3 = powered up)
                this.powerLevel = 0;
                this.maxPowerLevel = 3;
                
                // Weapons
                this.primaryWeapon = 'laser';
                this.secondaryWeapon = 'missile';
                this.ammo = { missile: 10, emp: 3 };
                
                this.createShip();
                this.createEngineEffects();
                this.createShield();
            }

            createShip() {
                this.mesh = new THREE.Group();
                
                // Main body - sleek futuristic design
                const bodyGeometry = new THREE.ConeGeometry(0.8, 4, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2244aa,
                    metalness: 0.9,
                    roughness: 0.2,
                    emissive: 0x112244,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.x = Math.PI / 2;
                body.position.z = 0.5;
                this.mesh.add(body);

                // Cockpit
                const cockpitGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const cockpitMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    metalness: 0.1,
                    roughness: 0.1,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                cockpit.scale.set(1, 0.6, 1.2);
                cockpit.position.set(0, 0.3, -0.5);
                this.mesh.add(cockpit);

                // Wings
                const wingGeometry = new THREE.BoxGeometry(4, 0.1, 1.5);
                const wingMaterial = new THREE.MeshStandardMaterial({
                    color: 0x334488,
                    metalness: 0.8,
                    roughness: 0.3,
                    emissive: 0x112233,
                    emissiveIntensity: 0.1
                });
                
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-1.5, 0, 0.5);
                leftWing.rotation.z = 0.1;
                this.mesh.add(leftWing);

                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(1.5, 0, 0.5);
                rightWing.rotation.z = -0.1;
                this.mesh.add(rightWing);

                // Wing tips with lights
                const wingTipGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const wingTipMaterialLeft = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.9
                });
                const wingTipMaterialRight = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.9
                });

                const leftTip = new THREE.Mesh(wingTipGeometry, wingTipMaterialLeft);
                leftTip.position.set(-3.5, 0, 0.5);
                this.mesh.add(leftTip);

                const rightTip = new THREE.Mesh(wingTipGeometry, wingTipMaterialRight);
                rightTip.position.set(3.5, 0, 0.5);
                this.mesh.add(rightTip);

                // Engine housings
                const engineGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 8);
                const engineMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444466,
                    metalness: 0.9,
                    roughness: 0.3
                });

                const engines = [
                    { x: -1, y: -0.1, z: 1.5 },
                    { x: 1, y: -0.1, z: 1.5 },
                    { x: 0, y: -0.2, z: 1.8 }
                ];

                engines.forEach(pos => {
                    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                    engine.rotation.x = Math.PI / 2;
                    engine.position.set(pos.x, pos.y, pos.z);
                    this.mesh.add(engine);
                });

                // Weapon mounts
                const weaponGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 6);
                const weaponMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666688,
                    metalness: 0.9,
                    roughness: 0.2
                });

                const leftWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                leftWeapon.rotation.x = Math.PI / 2;
                leftWeapon.position.set(-2.5, -0.1, 0);
                this.mesh.add(leftWeapon);

                const rightWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                rightWeapon.rotation.x = Math.PI / 2;
                rightWeapon.position.set(2.5, -0.1, 0);
                this.mesh.add(rightWeapon);
                
                // Tomoto Logo on wings using text texture
                this.addTomotoLogo();

                // Add ship to scene
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }
            
            addTomotoLogo() {
                // Create canvas texture for "Tomoto" logo
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // Transparent background
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw "Tomoto" text
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Tomoto', canvas.width / 2, canvas.height / 2);
                
                // Add glow effect
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillText('Tomoto', canvas.width / 2, canvas.height / 2);
                
                // Create texture
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                // Create logo material
                const logoMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                // Left wing logo
                const leftLogoGeometry = new THREE.PlaneGeometry(2, 0.5);
                const leftLogo = new THREE.Mesh(leftLogoGeometry, logoMaterial);
                leftLogo.position.set(-1.8, 0.15, 0.5);
                leftLogo.rotation.x = -Math.PI / 2;
                this.mesh.add(leftLogo);
                
                // Right wing logo
                const rightLogoGeometry = new THREE.PlaneGeometry(2, 0.5);
                const rightLogo = new THREE.Mesh(rightLogoGeometry, logoMaterial.clone());
                rightLogo.position.set(1.8, 0.15, 0.5);
                rightLogo.rotation.x = -Math.PI / 2;
                this.mesh.add(rightLogo);
                
                // Body logo (on top)
                const bodyLogoGeometry = new THREE.PlaneGeometry(1.5, 0.4);
                const bodyLogo = new THREE.Mesh(bodyLogoGeometry, logoMaterial.clone());
                bodyLogo.position.set(0, 0.5, 0);
                bodyLogo.rotation.x = -Math.PI / 2;
                this.mesh.add(bodyLogo);
            }

            createEngineEffects() {
                // Engine glow lights
                const glowPositions = [
                    { x: -1, y: -0.1, z: 2.1 },
                    { x: 1, y: -0.1, z: 2.1 },
                    { x: 0, y: -0.2, z: 2.4 }
                ];

                glowPositions.forEach(pos => {
                    // Glow sprite
                    const glowGeometry = new THREE.PlaneGeometry(1.2, 1.2);
                    const glowMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            intensity: { value: 1.0 },
                            color: { value: new THREE.Color(0x00aaff) }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform float intensity;
                            uniform vec3 color;
                            varying vec2 vUv;
                            
                            void main() {
                                vec2 center = vUv - 0.5;
                                float dist = length(center);
                                
                                // Flickering effect
                                float flicker = 0.9 + 0.1 * sin(time * 20.0) * sin(time * 13.0);
                                
                                // Core glow
                                float glow = exp(-dist * 4.0) * intensity * flicker;
                                
                                // Outer halo
                                float halo = exp(-dist * 2.0) * 0.3 * intensity;
                                
                                vec3 finalColor = color * (glow + halo);
                                float alpha = glow + halo * 0.5;
                                
                                gl_FragColor = vec4(finalColor, alpha);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide
                    });

                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.position.set(pos.x, pos.y, pos.z);
                    this.mesh.add(glow);
                    this.engineGlows.push(glow);
                });

                // Engine particle trail
                this.createEngineParticles();
            }

            createEngineParticles() {
                const particleCount = 500;
                const geometry = new THREE.BufferGeometry();
                
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                const lifetimes = new Float32Array(particleCount);
                const sizes = new Float32Array(particleCount);
                const engineIndex = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    
                    velocities[i * 3] = (Math.random() - 0.5) * 2;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 2;
                    velocities[i * 3 + 2] = 5 + Math.random() * 10;
                    
                    lifetimes[i] = Math.random();
                    sizes[i] = 0.1 + Math.random() * 0.3;
                    engineIndex[i] = Math.floor(Math.random() * 3);
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('engineIndex', new THREE.BufferAttribute(engineIndex, 1));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        shipPosition: { value: new THREE.Vector3() },
                        shipRotation: { value: new THREE.Matrix4() },
                        enginePositions: { value: [
                            new THREE.Vector3(-1, -0.1, 2.1),
                            new THREE.Vector3(1, -0.1, 2.1),
                            new THREE.Vector3(0, -0.2, 2.4)
                        ]},
                        thrustIntensity: { value: 1.0 },
                        pixelRatio: { value: window.devicePixelRatio }
                    },
                    vertexShader: `
                        attribute vec3 velocity;
                        attribute float lifetime;
                        attribute float size;
                        attribute float engineIndex;
                        
                        uniform float time;
                        uniform vec3 shipPosition;
                        uniform mat4 shipRotation;
                        uniform vec3 enginePositions[3];
                        uniform float thrustIntensity;
                        uniform float pixelRatio;
                        
                        varying float vLifetime;
                        varying float vIntensity;
                        
                        void main() {
                            vLifetime = lifetime;
                            
                            // Get engine position
                            int idx = int(engineIndex);
                            vec3 enginePos = enginePositions[idx];
                            
                            // Calculate particle life cycle
                            float life = mod(time * 2.0 + lifetime * 6.28, 1.0);
                            vIntensity = (1.0 - life) * thrustIntensity;
                            
                            // Calculate world position of engine
                            vec4 worldEnginePos = shipRotation * vec4(enginePos, 1.0);
                            
                            // Particle position trails behind ship
                            vec3 offset = velocity * life * 0.5;
                            vec4 worldOffset = shipRotation * vec4(offset, 0.0);
                            
                            vec3 pos = shipPosition + worldEnginePos.xyz + worldOffset.xyz;
                            
                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            gl_PointSize = size * pixelRatio * vIntensity * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying float vLifetime;
                        varying float vIntensity;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if (dist > 0.5) discard;
                            
                            // Color gradient from white-blue to orange
                            vec3 coreColor = vec3(0.8, 0.9, 1.0);
                            vec3 outerColor = vec3(0.0, 0.5, 1.0);
                            vec3 color = mix(outerColor, coreColor, vIntensity);
                            
                            float alpha = (1.0 - dist * 2.0) * vIntensity;
                            gl_FragColor = vec4(color * 2.0, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.engineParticles = new THREE.Points(geometry, material);
                this.scene.add(this.engineParticles);
            }

            createShield() {
                // Hexagonal shield bubble
                const shieldGeometry = new THREE.IcosahedronGeometry(4, 1);
                const shieldMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        hitPoint: { value: new THREE.Vector3(0, 0, 1) },
                        hitIntensity: { value: 0 },
                        shieldStrength: { value: 1.0 },
                        color: { value: new THREE.Color(0x00ffff) }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        varying vec2 vUv;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = position;
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec3 hitPoint;
                        uniform float hitIntensity;
                        uniform float shieldStrength;
                        uniform vec3 color;
                        
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        
                        // Hexagon pattern
                        float hexagon(vec2 p) {
                            p = abs(p);
                            return max(p.x * 0.866025 + p.y * 0.5, p.y) - 1.0;
                        }
                        
                        void main() {
                            // Fresnel effect - brighter at edges
                            vec3 viewDir = normalize(cameraPosition - vPosition);
                            float fresnel = pow(1.0 - abs(dot(vNormal, viewDir)), 3.0);
                            
                            // Hexagonal pattern
                            vec2 hexUv = vPosition.xy * 2.0;
                            float hex = smoothstep(0.0, 0.1, abs(hexagon(hexUv)));
                            
                            // Animated energy lines
                            float energy = sin(vPosition.z * 10.0 + time * 3.0) * 0.5 + 0.5;
                            energy *= sin(vPosition.x * 8.0 - time * 2.0) * 0.5 + 0.5;
                            
                            // Hit effect
                            float hitDist = length(vPosition - hitPoint);
                            float hitWave = sin(hitDist * 10.0 - time * 20.0) * exp(-hitDist * 2.0) * hitIntensity;
                            
                            // Combine effects
                            float alpha = fresnel * 0.5 + hex * 0.1 + energy * 0.1 + hitWave;
                            alpha *= shieldStrength;
                            
                            vec3 finalColor = color + vec3(hitWave * 0.5);
                            
                            gl_FragColor = vec4(finalColor, alpha * 0.6);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });
                
                this.shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                this.shield.visible = false;
                this.mesh.add(this.shield);
            }

            update(deltaTime, input, elapsedTime) {
                if (!this.mesh) return;
                
                // Get movement input
                const movement = input.getMovementVector();
                
                // Á∏¶„Çπ„ÇØ„É≠„Éº„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞È¢®„ÅÆÊìç‰Ωú - Â§ß„Åç„ÇÅ„ÅÆÂãï„Åç
                // X: Â∑¶Âè≥ÁßªÂãï„ÄÅY: ‰∏ä‰∏ãÁßªÂãïÔºàÁîªÈù¢‰∏ä„ÅÆ‰∏ä‰∏ãÔºâ
                const moveSpeed = this.speed * 1.8; // ÁßªÂãïÈÄüÂ∫¶„Çí1.8ÂÄç„Å´
                const targetVelocity = new THREE.Vector3(
                    movement.x * moveSpeed,        // Â∑¶Âè≥ÔºàÂ§ß„Åç„ÅèÔºâ
                    movement.y * moveSpeed * 0.9,  // ‰∏ä‰∏ãÔºàÂ§ß„Åç„ÅèÔºâ
                    0                              // ZÊñπÂêë„ÅØÂõ∫ÂÆö
                );
                
                // Smooth velocity interpolationÔºàÂøúÁ≠îÊÄß„Çí„Åï„Çâ„Å´‰∏ä„Åí„ÇãÔºâ
                this.velocity.lerp(targetVelocity, deltaTime * 12);
                
                // Apply velocity to position
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Clamp position to play areaÔºàÂ∫É„ÅÑÁØÑÂõ≤„ÅßÂãï„Åë„ÇãÔºâ
                this.position.x = THREE.MathUtils.clamp(this.position.x, -45, 45);
                this.position.y = THREE.MathUtils.clamp(this.position.y, -25, 25);
                // Z‰ΩçÁΩÆ„ÅØÂõ∫ÂÆöÔºà„Ç´„É°„É©„Åã„Çâ„ÅÆÁõ∏ÂØæ‰ΩçÁΩÆ„ÇíÁ∂≠ÊåÅÔºâ
                this.position.z = THREE.MathUtils.clamp(this.position.z, -5, 5);
                
                // Ê©ü‰Ωì„ÅÆÂÇæ„ÅçÔºàÁßªÂãïÊñπÂêë„Å´Âøú„Åò„Å¶ - „Çà„ÇäÂ§ß„Åç„Å™ÂÇæ„ÅçÔºâ
                this.targetRotation.y = movement.x * 0.35;  // Â∑¶Âè≥ÁßªÂãï„Åß„É®„Éº
                this.targetRotation.x = -movement.y * 0.25; // ‰∏ä‰∏ãÁßªÂãï„Åß„Éî„ÉÉ„ÉÅ
                this.targetRotation.z = -movement.x * 0.6;  // Â∑¶Âè≥ÁßªÂãï„Åß„É≠„Éº„É´Ôºà„Éê„É≥„ÇØÔºâ
                
                // Barrel roll
                this.updateBarrelRoll(deltaTime, input);
                
                // Smooth rotation
                if (!this.isBarrelRolling) {
                    this.mesh.rotation.x += (this.targetRotation.x - this.mesh.rotation.x) * deltaTime * 5;
                    this.mesh.rotation.y += (this.targetRotation.y - this.mesh.rotation.y) * deltaTime * 5;
                    this.mesh.rotation.z += (this.targetRotation.z - this.mesh.rotation.z) * deltaTime * 5;
                }
                
                // Update position
                this.mesh.position.copy(this.position);
                
                // Update engine effects
                this.updateEngineEffects(deltaTime, elapsedTime, movement);
                
                // Update shield
                this.updateShield(deltaTime, elapsedTime);
                
                // Update engine particles
                if (this.engineParticles) {
                    const thrustIntensity = 0.5 + Math.abs(movement.z) * 0.5 + Math.abs(movement.x) * 0.3;
                    this.engineParticles.material.uniforms.time.value = elapsedTime;
                    this.engineParticles.material.uniforms.shipPosition.value.copy(this.position);
                    this.engineParticles.material.uniforms.thrustIntensity.value = thrustIntensity;
                    
                    // Create rotation matrix from ship
                    const rotMatrix = new THREE.Matrix4();
                    rotMatrix.makeRotationFromEuler(this.mesh.rotation);
                    this.engineParticles.material.uniforms.shipRotation.value.copy(rotMatrix);
                }
            }

            updateBarrelRoll(deltaTime, input) {
                // Cooldown
                if (this.barrelRollCooldown > 0) {
                    this.barrelRollCooldown -= deltaTime;
                    if (this.barrelRollCooldown <= 0 && this.barrelRollCharges < this.maxBarrelRollCharges) {
                        this.barrelRollCharges++;
                        this.barrelRollCooldown = this.barrelRollCooldownTime;
                    }
                }
                
                // Start barrel roll
                if (!this.isBarrelRolling && this.barrelRollCharges > 0) {
                    if (input.isKeyPressed('KeyQ')) {
                        this.startBarrelRoll(-1);
                    } else if (input.isKeyPressed('KeyE')) {
                        this.startBarrelRoll(1);
                    }
                }
                
                // Execute barrel roll
                if (this.isBarrelRolling) {
                    this.barrelRollProgress += deltaTime * 4;
                    
                    // Full 360 rotation
                    const rollAngle = this.barrelRollDirection * this.barrelRollProgress * Math.PI * 2;
                    this.mesh.rotation.z = rollAngle;
                    
                    // Slight lateral movement
                    this.position.x += this.barrelRollDirection * deltaTime * 20;
                    
                    if (this.barrelRollProgress >= 1) {
                        this.isBarrelRolling = false;
                        this.barrelRollProgress = 0;
                        this.invincible = false;
                        this.mesh.rotation.z = 0;
                    }
                }
                
                // Update UI
                this.updateBarrelRollUI();
            }

            startBarrelRoll(direction) {
                this.isBarrelRolling = true;
                this.barrelRollDirection = direction;
                this.barrelRollProgress = 0;
                this.barrelRollCharges--;
                this.invincible = true;
                
                if (this.barrelRollCharges < this.maxBarrelRollCharges && this.barrelRollCooldown <= 0) {
                    this.barrelRollCooldown = this.barrelRollCooldownTime;
                }
                
                // Flash shield
                this.activateShield(0.3);
            }

            updateBarrelRollUI() {
                const leftRoll = document.getElementById('roll-left');
                const rightRoll = document.getElementById('roll-right');
                
                if (leftRoll && rightRoll) {
                    const updateCharge = (element, index) => {
                        if (index < this.barrelRollCharges) {
                            element.classList.add('ready');
                            element.classList.remove('cooldown');
                        } else {
                            element.classList.remove('ready');
                            element.classList.add('cooldown');
                            const cooldownPercent = (1 - this.barrelRollCooldown / this.barrelRollCooldownTime) * 100;
                            element.style.setProperty('--cooldown', cooldownPercent + '%');
                        }
                    };
                    
                    updateCharge(leftRoll, 0);
                    updateCharge(rightRoll, 1);
                }
            }

            updateEngineEffects(deltaTime, elapsedTime, movement) {
                const thrustIntensity = 0.5 + Math.abs(movement.z) * 0.5;
                
                this.engineGlows.forEach(glow => {
                    glow.material.uniforms.time.value = elapsedTime;
                    glow.material.uniforms.intensity.value = thrustIntensity;
                    
                    // Billboard effect - always face camera
                    glow.lookAt(this.mesh.position.clone().add(new THREE.Vector3(0, 0, 10)));
                });
            }

            updateShield(deltaTime, elapsedTime) {
                if (this.shield) {
                    this.shield.material.uniforms.time.value = elapsedTime;
                    this.shield.material.uniforms.shieldStrength.value = this.shields / this.maxShields;
                    
                    // Fade hit intensity
                    const hitIntensity = this.shield.material.uniforms.hitIntensity.value;
                    if (hitIntensity > 0) {
                        this.shield.material.uniforms.hitIntensity.value = Math.max(0, hitIntensity - deltaTime * 3);
                    }
                    
                    // Show shield when active or recently hit
                    if (this.shieldActive || hitIntensity > 0.1) {
                        this.shield.visible = true;
                    }
                }
            }

            activateShield(duration = 0.5) {
                this.shieldActive = true;
                this.shield.visible = true;
                
                setTimeout(() => {
                    this.shieldActive = false;
                }, duration * 1000);
            }

            takeDamage(amount, hitPoint) {
                if (this.invincible) return;
                
                // „ÉÄ„É°„Éº„Ç∏„Çí2/3„Å´ËªΩÊ∏õ
                amount = Math.floor(amount * 0.67);
                
                // Shield absorbs damage first
                if (this.shields > 0) {
                    const shieldDamage = Math.min(this.shields, amount);
                    this.shields -= shieldDamage;
                    amount -= shieldDamage;
                    
                    // Shield hit effect
                    if (this.shield) {
                        this.shield.material.uniforms.hitPoint.value.copy(hitPoint || new THREE.Vector3(0, 0, 1));
                        this.shield.material.uniforms.hitIntensity.value = 1.0;
                        this.shield.visible = true;
                    }
                }
                
                // Remaining damage to health
                this.health -= amount;
                
                if (this.health <= 0) {
                    this.health = 0;
                    this.onDestroyed();
                }
            }

            onDestroyed() {
                console.log('Player destroyed!');
                // Will be implemented in VFX section
            }

            getWeaponPositions() {
                // Return world positions of weapon mounts
                const leftPos = new THREE.Vector3(-2.5, -0.1, -1);
                const rightPos = new THREE.Vector3(2.5, -0.1, -1);
                
                leftPos.applyMatrix4(this.mesh.matrixWorld);
                rightPos.applyMatrix4(this.mesh.matrixWorld);
                
                return [leftPos, rightPos];
            }

            getForwardDirection() {
                // Â∏∏„Å´ÂâçÊñπÔºà-ZÊñπÂêëÔºâ„ÇíÂêë„Åè
                return new THREE.Vector3(0, 0, -1);
            }
        }

        // ============================================
        // Projectile Class (Bullets/Lasers)
        // ============================================
        class Projectile {
            constructor(scene, position, direction, isPlayerBullet = true) {
                this.scene = scene;
                this.isPlayerBullet = isPlayerBullet;
                this.alive = true;
                this.damage = isPlayerBullet ? 30 : 10;  // „Éó„É¨„Ç§„É§„ÉºÂºæ„ÅÆ„ÉÄ„É°„Éº„Ç∏Â¢óÂä†
                this.speed = isPlayerBullet ? 200 : 80;
                this.lifetime = 3;
                this.age = 0;
                
                this.position = position.clone();
                this.velocity = direction.clone().normalize().multiplyScalar(this.speed);
                
                // Trail system - „Éó„É¨„Ç§„É§„ÉºÂºæ„ÅØÈï∑„ÇÅ„ÅÆ„Éà„É¨„Ç§„É´
                this.trailPositions = [];
                this.maxTrailLength = isPlayerBullet ? 25 : 10;
                this.trailUpdateTimer = 0;
                
                this.createMesh();
                this.createTrail();
            }

            createMesh() {
                const color = this.isPlayerBullet ? 0x00ffff : 0xff3300;
                // „Éó„É¨„Ç§„É§„ÉºÂºæ„ÇíÂ§ß„Åç„Åè„Åô„Çã
                const length = this.isPlayerBullet ? 5.5 : 1.5;
                const radius = this.isPlayerBullet ? 0.35 : 0.1;
                
                // Elongated bullet shape
                const geometry = new THREE.CylinderGeometry(radius, radius, length, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                
                // Align with velocity direction
                this.mesh.quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0),
                    this.velocity.clone().normalize()
                );
                
                // Add glow - „Éó„É¨„Ç§„É§„ÉºÂºæ„ÅØÂ§ß„Åç„ÇÅ„ÅÆ„Ç∞„É≠„Éº
                const glowSize = this.isPlayerBullet ? 1.0 : 0.3;
                const glowGeometry = new THREE.SphereGeometry(glowSize, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.mesh.add(glow);
                
                this.scene.add(this.mesh);
            }

            createTrail() {
                const color = this.isPlayerBullet ? 0x00ffff : 0xff3300;
                
                // Create trail line
                const trailGeo = new THREE.BufferGeometry();
                const positions = new Float32Array(this.maxTrailLength * 3);
                trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                this.trailMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                
                this.trail = new THREE.Line(trailGeo, this.trailMaterial);
                this.scene.add(this.trail);
            }

            updateTrail() {
                // Add current position to trail
                this.trailPositions.unshift(this.position.clone());
                
                // Limit trail length
                if (this.trailPositions.length > this.maxTrailLength) {
                    this.trailPositions.pop();
                }
                
                // Update trail geometry
                const positions = this.trail.geometry.attributes.position.array;
                for (let i = 0; i < this.maxTrailLength; i++) {
                    if (i < this.trailPositions.length) {
                        positions[i * 3] = this.trailPositions[i].x;
                        positions[i * 3 + 1] = this.trailPositions[i].y;
                        positions[i * 3 + 2] = this.trailPositions[i].z;
                    } else {
                        // Fill remaining with last position
                        const last = this.trailPositions[this.trailPositions.length - 1] || this.position;
                        positions[i * 3] = last.x;
                        positions[i * 3 + 1] = last.y;
                        positions[i * 3 + 2] = last.z;
                    }
                }
                this.trail.geometry.attributes.position.needsUpdate = true;
                this.trail.geometry.setDrawRange(0, this.trailPositions.length);
            }

            update(deltaTime) {
                if (!this.alive) return;
                
                this.age += deltaTime;
                if (this.age >= this.lifetime) {
                    this.destroy();
                    return;
                }
                
                // Move projectile
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.mesh.position.copy(this.position);
                
                // Update trail
                this.trailUpdateTimer += deltaTime;
                if (this.trailUpdateTimer >= 0.016) { // ~60fps
                    this.updateTrail();
                    this.trailUpdateTimer = 0;
                }
                
                // Check bounds
                if (Math.abs(this.position.x) > 100 ||
                    Math.abs(this.position.y) > 100 ||
                    Math.abs(this.position.z) > 200) {
                    this.destroy();
                }
            }

            destroy() {
                this.alive = false;
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
                if (this.trail) {
                    this.scene.remove(this.trail);
                    this.trail.geometry.dispose();
                    this.trailMaterial.dispose();
                }
            }

            getCollisionRadius() {
                // „Éó„É¨„Ç§„É§„ÉºÂºæ„ÅØÂΩì„Åü„ÇäÂà§ÂÆö„ÇíÂ∫É„Åè
                return this.isPlayerBullet ? 2.5 : 0.5;
            }
        }

        // ============================================
        // PowerUpItem Class („Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†)
        // ============================================
        class PowerUpItem {
            constructor(scene, position) {
                this.scene = scene;
                this.position = position.clone();
                this.alive = true;
                this.age = 0;
                this.radius = 7.5;  // ÂèñÂæóÂà§ÂÆöÁØÑÂõ≤Ôºà3ÂÄç„Å´Êã°Â§ßÔºâ
                
                this.createMesh();
            }
            
            createMesh() {
                this.mesh = new THREE.Group();
                
                // „É°„Ç§„É≥„ÅÆÊòüÂΩ¢„Ç≥„Ç¢Ôºà3ÂÄç„Çµ„Ç§„Ç∫Ôºâ
                const coreGeo = new THREE.OctahedronGeometry(3.6, 0);
                const coreMat = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.95
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);
                this.mesh.add(this.core);
                
                // Â§ñÂÅ¥„ÅÆ„Ç∞„É≠„ÉºÔºà3ÂÄç„Çµ„Ç§„Ç∫Ôºâ
                const glowGeo = new THREE.SphereGeometry(5.4, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.3
                });
                this.glow = new THREE.Mesh(glowGeo, glowMat);
                this.mesh.add(this.glow);
                
                // ÂõûËª¢„Åô„Çã„É™„É≥„Ç∞Ôºà3ÂÄç„Çµ„Ç§„Ç∫Ôºâ
                const ringGeo = new THREE.TorusGeometry(6.0, 0.45, 8, 24);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xffff44,
                    transparent: true,
                    opacity: 0.6
                });
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.mesh.add(this.ring);
                
                // Á∏¶„ÅÆ„É™„É≥„Ç∞
                const ring2 = new THREE.Mesh(ringGeo.clone(), ringMat.clone());
                ring2.rotation.x = Math.PI / 2;
                this.ring2 = ring2;
                this.mesh.add(ring2);
                
                // P „Éû„Éº„ÇØ„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÔºàPOWER UPË°®Á§∫Ôºâ
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 64, 64);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('P', 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.9
                });
                this.sprite = new THREE.Sprite(spriteMat);
                this.sprite.scale.set(4.5, 4.5, 1);  // 3ÂÄç„Å´Êã°Â§ß
                this.mesh.add(this.sprite);
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }
            
            update(deltaTime) {
                if (!this.alive) return;
                
                this.age += deltaTime;
                
                // ÊµÆÈÅä„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.mesh.position.y = this.position.y + Math.sin(this.age * 3) * 0.5;
                
                // ÂõûËª¢„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.core.rotation.y += deltaTime * 2;
                this.core.rotation.x += deltaTime * 1.5;
                this.ring.rotation.z += deltaTime * 2;
                this.ring2.rotation.y += deltaTime * 2;
                
                // „Éë„É´„ÇπÂäπÊûú
                const pulse = 1 + Math.sin(this.age * 5) * 0.2;
                this.glow.scale.setScalar(pulse);
                
                // ZÊñπÂêë„Å´ÊµÅ„Çå„ÇãÔºà„Éó„É¨„Ç§„É§„Éº„Å´Âêë„Åã„Å£„Å¶Ôºâ
                this.position.z += deltaTime * 8;
                this.mesh.position.x = this.position.x;
                this.mesh.position.z = this.position.z;
                
                // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÊ∂àÊªÖ
                if (this.position.z > 50) {
                    this.destroy();
                }
            }
            
            destroy() {
                this.alive = false;
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                }
            }
            
            getCollisionRadius() {
                return this.radius;
            }
        }

        // ============================================
        // HealthItem Class (HPÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†)
        // ============================================
        class HealthItem {
            constructor(scene, position) {
                this.scene = scene;
                this.position = position.clone();
                this.alive = true;
                this.age = 0;
                this.radius = 7.5;  // ÂèñÂæóÂà§ÂÆöÁØÑÂõ≤Ôºà„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Å®Âêå„ÅòÔºâ
                this.healPercent = 0.25;  // HP25%ÂõûÂæ©
                
                this.createMesh();
            }
            
            createMesh() {
                this.mesh = new THREE.Group();
                
                // „É°„Ç§„É≥„ÅÆÂçÅÂ≠ó„Ç≥„Ç¢ÔºàÁ∑ëËâ≤Ôºâ
                const coreGeo = new THREE.OctahedronGeometry(3.6, 0);
                const coreMat = new THREE.MeshBasicMaterial({
                    color: 0x00ff44,
                    transparent: true,
                    opacity: 0.95
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);
                this.mesh.add(this.core);
                
                // Â§ñÂÅ¥„ÅÆ„Ç∞„É≠„ÉºÔºàÁ∑ëÔºâ
                const glowGeo = new THREE.SphereGeometry(5.4, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0x00aa33,
                    transparent: true,
                    opacity: 0.3
                });
                this.glow = new THREE.Mesh(glowGeo, glowMat);
                this.mesh.add(this.glow);
                
                // ÂõûËª¢„Åô„Çã„É™„É≥„Ç∞ÔºàÁ∑ëÔºâ
                const ringGeo = new THREE.TorusGeometry(6.0, 0.45, 8, 24);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0x44ff66,
                    transparent: true,
                    opacity: 0.6
                });
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.mesh.add(this.ring);
                
                // Á∏¶„ÅÆ„É™„É≥„Ç∞
                const ring2 = new THREE.Mesh(ringGeo.clone(), ringMat.clone());
                ring2.rotation.x = Math.PI / 2;
                this.ring2 = ring2;
                this.mesh.add(ring2);
                
                // + „Éû„Éº„ÇØ„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÔºàHPË°®Á§∫Ôºâ
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 64, 64);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 56px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('+', 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.9
                });
                this.sprite = new THREE.Sprite(spriteMat);
                this.sprite.scale.set(4.5, 4.5, 1);
                this.mesh.add(this.sprite);
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }
            
            update(deltaTime) {
                if (!this.alive) return;
                
                this.age += deltaTime;
                
                // ÊµÆÈÅä„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.mesh.position.y = this.position.y + Math.sin(this.age * 3) * 0.5;
                
                // ÂõûËª¢„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.core.rotation.y += deltaTime * 2;
                this.core.rotation.x += deltaTime * 1.5;
                this.ring.rotation.z += deltaTime * 2;
                this.ring2.rotation.y += deltaTime * 2;
                
                // „Éë„É´„ÇπÂäπÊûú
                const pulse = 1 + Math.sin(this.age * 5) * 0.2;
                this.glow.scale.setScalar(pulse);
                
                // ZÊñπÂêë„Å´ÊµÅ„Çå„ÇãÔºà„Éó„É¨„Ç§„É§„Éº„Å´Âêë„Åã„Å£„Å¶Ôºâ
                this.position.z += deltaTime * 8;
                this.mesh.position.x = this.position.x;
                this.mesh.position.z = this.position.z;
                
                // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÊ∂àÊªÖ
                if (this.position.z > 50) {
                    this.destroy();
                }
            }
            
            destroy() {
                this.alive = false;
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                }
            }
            
            getCollisionRadius() {
                return this.radius;
            }
        }

        // ============================================
        // Bomb Class (Â§ßÂ®ÅÂäõ„ÉªÂ∫ÉÁØÑÂõ≤ÊîªÊíÉ)
        // ============================================
        class Bomb {
            constructor(scene, position, direction) {
                this.scene = scene;
                this.alive = true;
                this.damage = 9999;  // Â§ß„ÉÄ„É°„Éº„Ç∏ÔºàÁ¢∫ÂÆü„Å´Á†¥Â£äÔºâ
                this.speed = 100;   // Âºæ„Çà„ÇäÈÅÖ„ÇÅÔºàÊâãÂãïÁàÜÁô∫„Åó„ÇÑ„Åô„ÅèÔºâ
                this.lifetime = 4;  // 4ÁßíÈñìÈ£õË°åÔºàÊâãÂãïÁàÜÁô∫„ÅÆ‰ΩôË£ïÔºâ
                this.age = 0;
                this.exploded = false;
                this.explosionRadius = 120; // ÁàÜÁô∫ÁØÑÂõ≤Ôºà„Éó„É≠„Éë„ÉÜ„Ç£„Å®„Åó„Å¶ÂÆöÁæ©Ôºâ
                
                this.position = position.clone();
                this.velocity = direction.clone().normalize().multiplyScalar(this.speed);
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // „Éú„É†Êú¨‰Ωì - Â§ß„Åç„ÇÅ„ÅÆÂÖâ„ÇãÁêÉ
                const coreGeo = new THREE.SphereGeometry(1.0, 16, 16);
                const coreMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.9
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);
                this.mesh.add(this.core);
                
                // Â§ñÂÅ¥„ÅÆ„Ç∞„É≠„Éº
                const glowGeo = new THREE.SphereGeometry(1.8, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xff66ff,
                    transparent: true,
                    opacity: 0.4
                });
                this.glow = new THREE.Mesh(glowGeo, glowMat);
                this.mesh.add(this.glow);
                
                // „É™„É≥„Ç∞ÂäπÊûú
                const ringGeo = new THREE.RingGeometry(1.5, 2.0, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xffaaff,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.mesh.add(this.ring);
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime) {
                if (!this.alive) return;
                
                this.age += deltaTime;
                
                // ÁßªÂãï
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.mesh.position.copy(this.position);
                
                // ÂõûËª¢„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.ring.rotation.x += deltaTime * 5;
                this.ring.rotation.y += deltaTime * 3;
                
                // „Éë„É´„ÇπÂäπÊûúÔºàÂØøÂëΩ„ÅåËøë„Å•„Åè„Å®ÁÇπÊªÖ„ÅåÈÄü„Åè„Å™„ÇãÔºâ
                const urgency = Math.max(1, (this.age / this.lifetime) * 3);
                const pulse = 1 + Math.sin(this.age * 15 * urgency) * 0.3;
                this.glow.scale.setScalar(pulse);
                
                // ÂØøÂëΩ„ÉÅ„Çß„ÉÉ„ÇØ - ÊôÇÈñìÂàá„Çå„Å™„ÇâËá™ÂãïÁàÜÁô∫„Éï„É©„Ç∞„ÇíËøî„Åô
                if (this.age > this.lifetime) {
                    return 'timeout';
                }
                
                // ÁîªÈù¢Â§ñ„ÉÅ„Çß„ÉÉ„ÇØ - ÈÅ†„Åè„Å´Ë°å„ÅçÈÅé„Åé„Åü„ÇâÊ∂àÊªÖ
                if (this.position.z < -200) {
                    this.destroy();
                    return 'destroyed';
                }
                
                return 'flying';
            }

            // ÁàÜÁô∫ÔºàÁØÑÂõ≤ÂÜÖ„ÅÆÊïµ„Å´„ÉÄ„É°„Éº„Ç∏Ôºâ
            explode(enemies, asteroids, vfxManager, audioManager) {
                if (this.exploded) return [];
                this.exploded = true;
                
                const hitTargets = [];
                
                console.log('Bomb exploded at:', this.position, 'Explosion radius:', this.explosionRadius);
                
                // Êïµ„Å∏„ÅÆ„ÉÄ„É°„Éº„Ç∏ÔºàÂç≥Ê≠ªÔºâ
                enemies.forEach(enemy => {
                    if (!enemy.alive) return;
                    const dist = this.position.distanceTo(enemy.position);
                    if (dist < this.explosionRadius) {
                        // Âç≥Ê≠ª„ÉÄ„É°„Éº„Ç∏
                        enemy.health = 0;
                        const destroyed = enemy.takeDamage(this.damage);
                        hitTargets.push({ target: enemy, destroyed: true });
                    }
                });
                
                // Â∞èÊÉëÊòü„Å∏„ÅÆ„ÉÄ„É°„Éº„Ç∏ÔºàÂç≥Ê≠ªÔºâ
                asteroids.forEach(asteroid => {
                    if (!asteroid.alive) return;
                    const dist = this.position.distanceTo(asteroid.position);
                    if (dist < this.explosionRadius) {
                        // Âç≥Ê≠ª„ÉÄ„É°„Éº„Ç∏
                        asteroid.health = 0;
                        const destroyed = asteroid.takeDamage(this.damage);
                        hitTargets.push({ target: asteroid, destroyed: true });
                    }
                });
                
                // Â§ßÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà
                if (vfxManager) {
                    vfxManager.createExplosion(this.position.clone(), 'boss', 0xff00ff);
                }
                
                // ÁàÜÁô∫Èü≥
                if (audioManager) {
                    audioManager.playExplosion('large');
                }
                
                this.destroy();
                return hitTargets;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                }
            }

            getCollisionRadius() {
                return 2.0; // Â§ß„Åç„ÇÅ„ÅÆÂΩì„Åü„ÇäÂà§ÂÆö
            }
        }

        // ============================================
        // Asteroid Class
        // ============================================
        class Asteroid {
            constructor(scene, position, size = 'medium') {
                this.scene = scene;
                this.alive = true;
                this.size = size;
                this.type = 'asteroid';
                
                // Size configurations
                const sizeConfig = {
                    small: { radius: 1.5, health: 15, score: 50, speed: 15 },
                    medium: { radius: 3, health: 40, score: 100, speed: 10 },
                    large: { radius: 5, health: 80, score: 200, speed: 5 }
                };
                
                const config = sizeConfig[size];
                this.radius = config.radius;
                this.health = config.health;
                this.maxHealth = config.health;
                this.score = config.score;
                this.baseSpeed = config.speed;
                
                this.position = position.clone();
                // ÂâçÊñπ„Åã„Çâ„Éó„É¨„Ç§„É§„Éº„Å´Âêë„Åã„Å£„Å¶ÊµÅ„Çå„Å¶„Åè„Çã
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * this.baseSpeed * 0.3, // Â∑¶Âè≥„Å´„Çè„Åö„Åã„Å´Êè∫„Çå„Çã
                    (Math.random() - 0.5) * this.baseSpeed * 0.2, // ‰∏ä‰∏ã„Å´„Çè„Åö„Åã„Å´Êè∫„Çå„Çã
                    this.baseSpeed + Math.random() * 10           // „É°„Ç§„É≥„ÅØ+ZÊñπÂêëÔºà„Éó„É¨„Ç§„É§„Éº„Å´Âêë„Åã„ÅÜÔºâ
                );
                this.rotationSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Irregular asteroid shape using icosahedron with noise
                const geometry = new THREE.IcosahedronGeometry(this.radius, 1);
                const positions = geometry.attributes.position.array;
                
                // Add noise to vertices for irregular shape
                for (let i = 0; i < positions.length; i += 3) {
                    const noise = 0.7 + Math.random() * 0.6;
                    positions[i] *= noise;
                    positions[i + 1] *= noise;
                    positions[i + 2] *= noise;
                }
                geometry.computeVertexNormals();
                
                // Main rock material
                const material = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    roughness: 0.9,
                    metalness: 0.1,
                    flatShading: true
                });
                
                const rock = new THREE.Mesh(geometry, material);
                this.mesh.add(rock);
                
                // Add glowing crystal deposits
                const crystalCount = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < crystalCount; i++) {
                    const crystalGeo = new THREE.OctahedronGeometry(this.radius * 0.15, 0);
                    const crystalMat = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0x00ffff : 0xff00ff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const crystal = new THREE.Mesh(crystalGeo, crystalMat);
                    
                    // Position on surface
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    crystal.position.set(
                        this.radius * 0.8 * Math.sin(phi) * Math.cos(theta),
                        this.radius * 0.8 * Math.sin(phi) * Math.sin(theta),
                        this.radius * 0.8 * Math.cos(phi)
                    );
                    crystal.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                    this.mesh.add(crystal);
                }
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime) {
                if (!this.alive) return;
                
                // Move
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.mesh.position.copy(this.position);
                
                // Rotate
                this.mesh.rotation.x += this.rotationSpeed.x * deltaTime;
                this.mesh.rotation.y += this.rotationSpeed.y * deltaTime;
                this.mesh.rotation.z += this.rotationSpeed.z * deltaTime;
                
                // „Éó„É¨„Ç§„É§„Éº„ÇíÈÄö„ÇäÈÅé„Åé„Åü„ÇâÂâäÈô§ÔºàÁîªÈù¢Â§ñÔºâ
                if (this.position.z > 50) {
                    this.destroy();
                }
                // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÂâäÈô§
                if (Math.abs(this.position.x) > 100 || Math.abs(this.position.y) > 60) {
                    this.destroy();
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                
                // Flash effect
                if (this.mesh.children[0]) {
                    const rock = this.mesh.children[0];
                    rock.material.emissive.setHex(0xff6600);
                    rock.material.emissiveIntensity = 0.5;
                    setTimeout(() => {
                        rock.material.emissiveIntensity = 0;
                    }, 100);
                }
                
                if (this.health <= 0) {
                    this.destroy();
                    return true;
                }
                return false;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                }
            }

            getCollisionRadius() {
                return this.radius;
            }

            // Returns smaller asteroids when destroyed
            getFragments() {
                if (this.size === 'large') {
                    return ['medium', 'medium'];
                } else if (this.size === 'medium') {
                    return ['small', 'small'];
                }
                return [];
            }
        }

        // ============================================
        // Enemy Fighter Class
        // ============================================
        class EnemyFighter {
            constructor(scene, position, playerRef, waveNumber = 1) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'fighter';
                this.waveNumber = waveNumber;
                
                // Stats scale with wave
                this.health = 40 + waveNumber * 10;
                this.maxHealth = this.health;
                this.score = 150 + waveNumber * 25;
                this.speed = 25 + waveNumber * 3;
                this.radius = 2;
                
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                this.targetPosition = new THREE.Vector3();
                
                // AI state - fire rate increases with wave
                this.aiState = 'approach';
                this.stateTimer = 0;
                this.fireTimer = 0;
                this.fireCooldown = Math.max(0.6, 1.8 - waveNumber * 0.15); // Faster shooting each wave
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Enemy ship body - angular aggressive design
                const bodyGeo = new THREE.ConeGeometry(1.5, 4, 4);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xaa2222,
                    metalness: 0.8,
                    roughness: 0.3,
                    emissive: 0x330000,
                    emissiveIntensity: 0.3
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.rotation.x = Math.PI / 2;
                this.mesh.add(body);
                
                // Wings
                const wingGeo = new THREE.BoxGeometry(5, 0.2, 1.5);
                const wingMat = new THREE.MeshStandardMaterial({
                    color: 0x882222,
                    metalness: 0.7,
                    roughness: 0.4
                });
                const wings = new THREE.Mesh(wingGeo, wingMat);
                wings.position.z = 0.5;
                this.mesh.add(wings);
                
                // Engine glow
                const engineGeo = new THREE.SphereGeometry(0.4, 8, 8);
                const engineMat = new THREE.MeshBasicMaterial({
                    color: 0xff3300,
                    transparent: true,
                    opacity: 0.8
                });
                const engine = new THREE.Mesh(engineGeo, engineMat);
                engine.position.z = 2;
                this.mesh.add(engine);
                this.engineGlow = engine;
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                this.stateTimer += deltaTime;
                this.fireTimer += deltaTime;
                
                // „Ç∑„É≥„Éó„É´„Å™ÂâçÊñπ„Åã„Çâ„ÅÆÊîªÊíÉ„Éë„Çø„Éº„É≥
                const toPlayer = this.player.position.clone().sub(this.position);
                const distToPlayer = toPlayer.length();
                
                // Âü∫Êú¨ÁöÑ„Å´+ZÊñπÂêëÔºà„Éó„É¨„Ç§„É§„Éº„Å´Âêë„Åã„Å£„Å¶ÔºâÈÄ≤„ÇÄ
                const baseSpeed = this.speed * 0.8;
                
                // „Éó„É¨„Ç§„É§„Éº„ÇíÁãô„Å£„Å¶Â∞ë„ÅóËªåÈÅì‰øÆÊ≠£
                const aimFactor = 0.3; // „Å©„Çå„Åè„Çâ„ÅÑ„Éó„É¨„Ç§„É§„Éº„ÇíËøΩÂ∞æ„Åô„Çã„Åã
                this.targetPosition.set(
                    this.player.position.x * aimFactor + this.position.x * (1 - aimFactor),
                    this.player.position.y * aimFactor + this.position.y * (1 - aimFactor),
                    this.position.z + baseSpeed // Â∏∏„Å´ÂâçÈÄ≤
                );
                
                // ÁßªÂãï
                const toTarget = this.targetPosition.clone().sub(this.position);
                this.velocity.lerp(toTarget.normalize().multiplyScalar(baseSpeed), deltaTime * 3);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // „Éó„É¨„Ç§„É§„Éº„Å´Ëøë„ÅÑÊôÇ„ÅØÂ∞ÑÊíÉ
                if (this.fireTimer >= this.fireCooldown && distToPlayer < 60) {
                    this.fire(projectiles);
                    this.fireTimer = 0;
                }
                
                // Update mesh
                this.mesh.position.copy(this.position);
                
                // „Éó„É¨„Ç§„É§„Éº„ÅÆÊñπ„ÇíÂêë„Åè
                this.mesh.lookAt(this.player.position);
                
                // Engine glow pulse
                if (this.engineGlow) {
                    this.engineGlow.scale.setScalar(0.8 + Math.sin(Date.now() * 0.01) * 0.2);
                }
                
                // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÂâäÈô§
                if (this.position.z > 50) {
                    this.destroy();
                }
            }

            fire(projectiles) {
                const direction = this.player.position.clone().sub(this.position).normalize();
                const projectile = new Projectile(
                    this.scene,
                    this.position.clone().add(direction.clone().multiplyScalar(2)),
                    direction,
                    false
                );
                projectile.damage = 15;
                projectiles.push(projectile);
            }

            takeDamage(amount) {
                this.health -= amount;
                
                // Flash effect
                if (this.mesh.children[0]) {
                    this.mesh.children[0].material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (this.mesh.children[0]) {
                            this.mesh.children[0].material.emissiveIntensity = 0.3;
                        }
                    }, 100);
                }
                
                if (this.health <= 0) {
                    this.destroy();
                    return true;
                }
                return false;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                }
            }

            getCollisionRadius() {
                return this.radius;
            }
        }

        // ============================================
        // Enemy Bomber Class
        // ============================================
        class EnemyBomber {
            constructor(scene, position, playerRef, waveNumber = 1) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'bomber';
                this.waveNumber = waveNumber;
                
                // Stats scale with wave
                this.health = 80 + waveNumber * 20;
                this.maxHealth = this.health;
                this.score = 250 + waveNumber * 50;
                this.speed = 12 + waveNumber * 2;
                this.radius = 3;
                
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                
                this.mineTimer = 0;
                this.mineCooldown = 3;
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Heavy bomber body
                const bodyGeo = new THREE.BoxGeometry(3, 2, 5);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x444466,
                    metalness: 0.8,
                    roughness: 0.4,
                    emissive: 0x222233,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(body);
                
                // Large wings
                const wingGeo = new THREE.BoxGeometry(8, 0.3, 3);
                const wings = new THREE.Mesh(wingGeo, bodyMat);
                this.mesh.add(wings);
                
                // Engine pods
                const podGeo = new THREE.CylinderGeometry(0.5, 0.7, 2, 8);
                const podMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
                
                [-3, 3].forEach(x => {
                    const pod = new THREE.Mesh(podGeo, podMat);
                    pod.rotation.x = Math.PI / 2;
                    pod.position.set(x, 0, 1);
                    this.mesh.add(pod);
                    
                    // Engine glow
                    const glowGeo = new THREE.SphereGeometry(0.4, 8, 8);
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: 0x6600ff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const glow = new THREE.Mesh(glowGeo, glowMat);
                    glow.position.set(x, 0, 2);
                    this.mesh.add(glow);
                });
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime, mines) {
                if (!this.alive || !this.player) return;
                
                this.mineTimer += deltaTime;
                
                // ÂâçÊñπ„Åã„Çâ„ÇÜ„Å£„Åè„ÇäÊé•ËøëÔºàÁàÜÊíÉÊ©ü„ÅØÈÅÖ„ÅÑÔºâ
                const baseSpeed = this.speed * 0.6;
                const toPlayer = this.player.position.clone().sub(this.position);
                const distToPlayer = toPlayer.length();
                
                // „Éó„É¨„Ç§„É§„Éº„ÇíÁ∑©„ÅèËøΩÂ∞æ„Åó„Å™„Åå„ÇâÂâçÈÄ≤
                const aimFactor = 0.2;
                this.velocity.set(
                    (this.player.position.x * aimFactor - this.position.x * aimFactor) * 0.5,
                    (this.player.position.y * aimFactor - this.position.y * aimFactor) * 0.3,
                    baseSpeed
                );
                
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.player.position);
                
                // Drop mines
                if (this.mineTimer >= this.mineCooldown && distToPlayer < 50) {
                    this.dropMine(mines);
                    this.mineTimer = 0;
                }
                
                // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÂâäÈô§
                if (this.position.z > 50) {
                    this.destroy();
                }
            }

            dropMine(mines) {
                const mine = new Mine(this.scene, this.position.clone());
                mines.push(mine);
            }

            takeDamage(amount) {
                this.health -= amount;
                
                if (this.mesh.children[0]) {
                    this.mesh.children[0].material.emissiveIntensity = 0.8;
                    setTimeout(() => {
                        if (this.mesh.children[0]) {
                            this.mesh.children[0].material.emissiveIntensity = 0.2;
                        }
                    }, 100);
                }
                
                if (this.health <= 0) {
                    this.destroy();
                    return true;
                }
                return false;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                }
            }

            getCollisionRadius() {
                return this.radius;
            }
        }

        // ============================================
        // Enemy Interceptor Class (È´òÈÄü„ÉªÂõûÈÅøË°åÂãï)
        // Wave 2„Åã„ÇâÂá∫Áèæ
        // ============================================
        class EnemyInterceptor {
            constructor(scene, position, playerRef, waveNumber = 1) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'interceptor';
                this.waveNumber = waveNumber;
                
                // È´òÈÄü„Éª‰ΩéHP
                this.health = 25 + waveNumber * 5;
                this.maxHealth = this.health;
                this.score = 200 + waveNumber * 30;
                this.speed = 45 + waveNumber * 5;
                this.radius = 1.5;
                
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                
                // ÂõûÈÅøÊ©üÂãïÁî®
                this.dodgeTimer = 0;
                this.dodgeDirection = new THREE.Vector3();
                this.isDodging = false;
                
                this.fireTimer = 0;
                this.fireCooldown = Math.max(0.4, 1.2 - waveNumber * 0.1);
                this.burstCount = 0;
                this.burstMax = 3;
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // „Çπ„É™„É†„Å™‰∏âËßíÂΩ¢„Éú„Éá„Ç£
                const bodyGeo = new THREE.ConeGeometry(0.8, 5, 3);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x00aa66,
                    metalness: 0.9,
                    roughness: 0.2,
                    emissive: 0x003322,
                    emissiveIntensity: 0.4
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.rotation.x = Math.PI / 2;
                this.mesh.add(body);
                
                // Â∞è„Åï„Å™Áøº
                const wingGeo = new THREE.BoxGeometry(4, 0.1, 1);
                const wingMat = new THREE.MeshStandardMaterial({
                    color: 0x008855,
                    metalness: 0.8,
                    roughness: 0.3
                });
                const wings = new THREE.Mesh(wingGeo, wingMat);
                wings.position.z = 1;
                this.mesh.add(wings);
                
                // Á∑ë„ÅÆ„Ç®„É≥„Ç∏„É≥„Ç∞„É≠„Éº
                const engineGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const engineMat = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.9
                });
                this.engineGlow = new THREE.Mesh(engineGeo, engineMat);
                this.engineGlow.position.z = 2.5;
                this.mesh.add(this.engineGlow);
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                this.fireTimer += deltaTime;
                this.dodgeTimer += deltaTime;
                
                const toPlayer = this.player.position.clone().sub(this.position);
                const distToPlayer = toPlayer.length();
                
                // „É©„É≥„ÉÄ„É†„Å´ÂõûÈÅøÊ©üÂãï
                if (!this.isDodging && Math.random() < 0.02) {
                    this.isDodging = true;
                    this.dodgeTimer = 0;
                    this.dodgeDirection.set(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        0
                    ).normalize();
                }
                
                if (this.isDodging && this.dodgeTimer > 0.5) {
                    this.isDodging = false;
                }
                
                // Âü∫Êú¨ÁßªÂãï
                let moveDir = new THREE.Vector3(0, 0, this.speed);
                
                // „Éó„É¨„Ç§„É§„ÉºËøΩÂ∞æ
                if (distToPlayer < 80) {
                    moveDir.x += (this.player.position.x - this.position.x) * 0.5;
                    moveDir.y += (this.player.position.y - this.position.y) * 0.3;
                }
                
                // ÂõûÈÅø‰∏≠„ÅØÊ®™ÊñπÂêë„Å´È´òÈÄüÁßªÂãï
                if (this.isDodging) {
                    moveDir.x += this.dodgeDirection.x * this.speed * 2;
                    moveDir.y += this.dodgeDirection.y * this.speed * 2;
                }
                
                this.velocity.lerp(moveDir, deltaTime * 5);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // 3ÈÄ£Â∞Ñ„Éê„Éº„Çπ„Éà
                if (this.fireTimer >= this.fireCooldown && distToPlayer < 50) {
                    this.fire(projectiles);
                    this.burstCount++;
                    if (this.burstCount >= this.burstMax) {
                        this.fireTimer = -0.5; // „Éê„Éº„Çπ„ÉàÂæå„ÅÆÈñì
                        this.burstCount = 0;
                    } else {
                        this.fireTimer = this.fireCooldown - 0.1;
                    }
                }
                
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.player.position);
                
                // „Ç®„É≥„Ç∏„É≥„Ç∞„É≠„Éº
                if (this.engineGlow) {
                    const intensity = this.isDodging ? 1.5 : 1.0;
                    this.engineGlow.scale.setScalar(intensity + Math.sin(Date.now() * 0.02) * 0.3);
                }
                
                if (this.position.z > 50) this.destroy();
            }

            fire(projectiles) {
                const direction = this.player.position.clone().sub(this.position).normalize();
                const projectile = new Projectile(
                    this.scene,
                    this.position.clone().add(direction.clone().multiplyScalar(2)),
                    direction,
                    false
                );
                projectile.damage = 10;
                projectile.speed = 200; // È´òÈÄüÂºæ
                projectiles.push(projectile);
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.mesh.children[0]) {
                    this.mesh.children[0].material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (this.mesh.children[0]) this.mesh.children[0].material.emissiveIntensity = 0.4;
                    }, 100);
                }
                if (this.health <= 0) { this.destroy(); return true; }
                return false;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) this.scene.remove(this.mesh);
            }

            getCollisionRadius() { return this.radius; }
        }

        // ============================================
        // Enemy Tank Class (ÈáçË£ÖÁî≤„ÉªÈÅÖ„ÅÑ„ÉªÂº∑Âäõ„Å™ÊîªÊíÉ)
        // Wave 3„Åã„ÇâÂá∫Áèæ
        // ============================================
        class EnemyTank {
            constructor(scene, position, playerRef, waveNumber = 1) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'tank';
                this.waveNumber = waveNumber;
                
                // È´òHP„ÉªÈÅÖ„ÅÑ
                this.health = 200 + waveNumber * 40;
                this.maxHealth = this.health;
                this.score = 400 + waveNumber * 60;
                this.speed = 8 + waveNumber;
                this.radius = 4;
                
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                
                this.fireTimer = 0;
                this.fireCooldown = 2.5;
                this.chargeTime = 0;
                this.isCharging = false;
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // ÈáçÂéö„Å™Êú¨‰Ωì
                const bodyGeo = new THREE.BoxGeometry(5, 3, 6);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x665544,
                    metalness: 0.9,
                    roughness: 0.5,
                    emissive: 0x221100,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(body);
                this.bodyMesh = body;
                
                // Ë£ÖÁî≤„Éó„É¨„Éº„Éà
                const armorGeo = new THREE.BoxGeometry(6, 1, 4);
                const armorMat = new THREE.MeshStandardMaterial({
                    color: 0x554433,
                    metalness: 0.8,
                    roughness: 0.6
                });
                const topArmor = new THREE.Mesh(armorGeo, armorMat);
                topArmor.position.y = 2;
                this.mesh.add(topArmor);
                
                const bottomArmor = new THREE.Mesh(armorGeo, armorMat);
                bottomArmor.position.y = -2;
                this.mesh.add(bottomArmor);
                
                // Â§ßÂûã„Ç≠„É£„Éé„É≥
                const cannonGeo = new THREE.CylinderGeometry(0.6, 0.8, 4, 8);
                const cannonMat = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.9,
                    roughness: 0.3
                });
                this.cannon = new THREE.Mesh(cannonGeo, cannonMat);
                this.cannon.rotation.x = Math.PI / 2;
                this.cannon.position.z = -3;
                this.mesh.add(this.cannon);
                
                // „ÉÅ„É£„Éº„Ç∏„Ç®„Éï„Çß„ÇØ„Éà
                const chargeGeo = new THREE.SphereGeometry(0.5, 16, 16);
                const chargeMat = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    transparent: true,
                    opacity: 0
                });
                this.chargeEffect = new THREE.Mesh(chargeGeo, chargeMat);
                this.chargeEffect.position.z = -5;
                this.mesh.add(this.chargeEffect);
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                this.fireTimer += deltaTime;
                
                const toPlayer = this.player.position.clone().sub(this.position);
                const distToPlayer = toPlayer.length();
                
                // „ÇÜ„Å£„Åè„ÇäÂâçÈÄ≤
                this.velocity.set(0, 0, this.speed);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // „ÉÅ„É£„Éº„Ç∏ÊîªÊíÉ
                if (this.fireTimer >= this.fireCooldown && distToPlayer < 70 && !this.isCharging) {
                    this.isCharging = true;
                    this.chargeTime = 0;
                }
                
                if (this.isCharging) {
                    this.chargeTime += deltaTime;
                    // „ÉÅ„É£„Éº„Ç∏„Ç®„Éï„Çß„ÇØ„Éà
                    const chargeProgress = Math.min(this.chargeTime / 1.5, 1);
                    this.chargeEffect.material.opacity = chargeProgress * 0.8;
                    this.chargeEffect.scale.setScalar(1 + chargeProgress * 2);
                    
                    if (this.chargeTime >= 1.5) {
                        this.firePowerShot(projectiles);
                        this.isCharging = false;
                        this.fireTimer = 0;
                        this.chargeEffect.material.opacity = 0;
                        this.chargeEffect.scale.setScalar(1);
                    }
                }
                
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.player.position);
                
                if (this.position.z > 50) this.destroy();
            }

            firePowerShot(projectiles) {
                const direction = this.player.position.clone().sub(this.position).normalize();
                
                // Â§ßÂûãÂºæ„ÇíÁô∫Â∞Ñ
                const projectile = new Projectile(
                    this.scene,
                    this.position.clone().add(direction.clone().multiplyScalar(5)),
                    direction,
                    false
                );
                projectile.damage = 40;
                projectile.speed = 80;
                // Âºæ„ÇíÂ§ß„Åç„Åè
                if (projectile.mesh) {
                    projectile.mesh.scale.setScalar(3);
                }
                projectiles.push(projectile);
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.bodyMesh) {
                    this.bodyMesh.material.emissiveIntensity = 0.8;
                    setTimeout(() => {
                        if (this.bodyMesh) this.bodyMesh.material.emissiveIntensity = 0.2;
                    }, 100);
                }
                if (this.health <= 0) { this.destroy(); return true; }
                return false;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) this.scene.remove(this.mesh);
            }

            getCollisionRadius() { return this.radius; }
        }

        // ============================================
        // Enemy Sniper Class (ÈÅ†Ë∑ùÈõ¢„ÉªÁ≤æÂØÜÂ∞ÑÊíÉ)
        // Wave 4„Åã„ÇâÂá∫Áèæ
        // ============================================
        class EnemySniper {
            constructor(scene, position, playerRef, waveNumber = 1) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'sniper';
                this.waveNumber = waveNumber;
                
                this.health = 50 + waveNumber * 10;
                this.maxHealth = this.health;
                this.score = 300 + waveNumber * 40;
                this.speed = 5;
                this.radius = 2;
                
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                
                this.fireTimer = 0;
                this.fireCooldown = 3;
                this.aimTime = 0;
                this.isAiming = false;
                this.aimTarget = new THREE.Vector3();
                this.laserLine = null;
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Á¥∞Èï∑„ÅÑ„Éú„Éá„Ç£
                const bodyGeo = new THREE.BoxGeometry(1.5, 1.5, 7);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x2244aa,
                    metalness: 0.9,
                    roughness: 0.2,
                    emissive: 0x112255,
                    emissiveIntensity: 0.3
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(body);
                this.bodyMesh = body;
                
                // Èï∑„ÅÑÁ†≤Ë∫´
                const barrelGeo = new THREE.CylinderGeometry(0.2, 0.3, 6, 8);
                const barrelMat = new THREE.MeshStandardMaterial({
                    color: 0x1133aa,
                    metalness: 0.95,
                    roughness: 0.1
                });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.x = Math.PI / 2;
                barrel.position.z = -5;
                this.mesh.add(barrel);
                
                // „Çπ„Ç≥„Éº„Éó
                const scopeGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8);
                const scope = new THREE.Mesh(scopeGeo, barrelMat);
                scope.rotation.z = Math.PI / 2;
                scope.position.set(0, 1, -2);
                this.mesh.add(scope);
                
                // ÁÖßÊ∫ñ„É¨„Éº„Ç∂„ÉºÁî®
                const laserMat = new THREE.LineBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.5
                });
                const laserGeo = new THREE.BufferGeometry();
                laserGeo.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0, 0,0,-100], 3));
                this.laserLine = new THREE.Line(laserGeo, laserMat);
                this.laserLine.visible = false;
                this.mesh.add(this.laserLine);
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                this.fireTimer += deltaTime;
                
                const toPlayer = this.player.position.clone().sub(this.position);
                const distToPlayer = toPlayer.length();
                
                // „Åª„Å®„Çì„Å©Âãï„Åã„Å™„ÅÑÔºàÈÅ†Ë∑ùÈõ¢„Åã„ÇâÁãôÊíÉÔºâ
                this.velocity.set(0, 0, this.speed * 0.5);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // ÁÖßÊ∫ñÈñãÂßã
                if (this.fireTimer >= this.fireCooldown && !this.isAiming) {
                    this.isAiming = true;
                    this.aimTime = 0;
                    this.aimTarget.copy(this.player.position);
                    this.laserLine.visible = true;
                }
                
                if (this.isAiming) {
                    this.aimTime += deltaTime;
                    
                    // „É¨„Éº„Ç∂„ÉºÁÖßÊ∫ñÔºà„Éó„É¨„Ç§„É§„Éº‰ΩçÁΩÆ„Çí‰∫àÊ∏¨Ôºâ
                    this.aimTarget.lerp(this.player.position, deltaTime * 2);
                    
                    // „É¨„Éº„Ç∂„Éº„ÅÆÁÇπÊªÖ
                    this.laserLine.material.opacity = 0.3 + Math.sin(this.aimTime * 20) * 0.3;
                    
                    if (this.aimTime >= 2) {
                        this.fireSnipe(projectiles);
                        this.isAiming = false;
                        this.fireTimer = 0;
                        this.laserLine.visible = false;
                    }
                }
                
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.aimTarget);
                
                if (this.position.z > 30) this.destroy();
            }

            fireSnipe(projectiles) {
                const direction = this.aimTarget.clone().sub(this.position).normalize();
                
                const projectile = new Projectile(
                    this.scene,
                    this.position.clone().add(direction.clone().multiplyScalar(8)),
                    direction,
                    false
                );
                projectile.damage = 35;
                projectile.speed = 300; // Ë∂ÖÈ´òÈÄü
                projectiles.push(projectile);
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.bodyMesh) {
                    this.bodyMesh.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (this.bodyMesh) this.bodyMesh.material.emissiveIntensity = 0.3;
                    }, 100);
                }
                if (this.health <= 0) { this.destroy(); return true; }
                return false;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) this.scene.remove(this.mesh);
            }

            getCollisionRadius() { return this.radius; }
        }

        // ============================================
        // Enemy Swarm Class (Â∞èÂûã„ÉªÂ§ßÈáèÂá∫Áèæ)
        // Wave 2„Åã„ÇâÂá∫Áèæ
        // ============================================
        class EnemySwarm {
            constructor(scene, position, playerRef, waveNumber = 1) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'swarm';
                this.waveNumber = waveNumber;
                
                // ÈùûÂ∏∏„Å´‰ΩéHP
                this.health = 10 + waveNumber * 2;
                this.maxHealth = this.health;
                this.score = 50 + waveNumber * 10;
                this.speed = 35 + waveNumber * 3;
                this.radius = 0.8;
                
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                
                // Áæ§„ÇåË°åÂãïÁî®
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 3 + Math.random() * 2;
                
                this.fireTimer = Math.random() * 2;
                this.fireCooldown = 2;
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Â∞èÂûã„ÅÆ‰∏∏„ÅÑ„Éú„Éá„Ç£
                const bodyGeo = new THREE.SphereGeometry(0.6, 8, 8);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xaaaa00,
                    metalness: 0.6,
                    roughness: 0.4,
                    emissive: 0x555500,
                    emissiveIntensity: 0.5
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(body);
                this.bodyMesh = body;
                
                // Â∞è„Åï„Å™Áøº
                const wingGeo = new THREE.BoxGeometry(2, 0.1, 0.5);
                const wingMat = new THREE.MeshStandardMaterial({ color: 0x888800 });
                const wings = new THREE.Mesh(wingGeo, wingMat);
                this.mesh.add(wings);
                
                // Áô∫ÂÖâ
                const glowGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.6
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.z = 0.5;
                this.mesh.add(glow);
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                this.fireTimer += deltaTime;
                
                const toPlayer = this.player.position.clone().sub(this.position);
                const distToPlayer = toPlayer.length();
                
                // Ê≥¢Áä∂„Å´Âãï„Åç„Å™„Åå„ÇâÊé•Ëøë
                const wobble = Math.sin(Date.now() * 0.003 + this.wobbleOffset) * 15;
                
                this.velocity.set(
                    wobble * deltaTime * 10 + (this.player.position.x - this.position.x) * 0.3,
                    Math.cos(Date.now() * 0.004 + this.wobbleOffset) * 5 * deltaTime * 10,
                    this.speed
                );
                
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // ÊôÇ„ÄÖÁô∫Â∞Ñ
                if (this.fireTimer >= this.fireCooldown && distToPlayer < 40 && Math.random() < 0.3) {
                    this.fire(projectiles);
                    this.fireTimer = 0;
                }
                
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.player.position);
                this.mesh.rotation.z = wobble * 0.02;
                
                if (this.position.z > 50) this.destroy();
            }

            fire(projectiles) {
                const direction = this.player.position.clone().sub(this.position).normalize();
                const projectile = new Projectile(
                    this.scene,
                    this.position.clone().add(direction.clone().multiplyScalar(1)),
                    direction,
                    false
                );
                projectile.damage = 5;
                projectile.speed = 120;
                projectiles.push(projectile);
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.bodyMesh) {
                    this.bodyMesh.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (this.bodyMesh) this.bodyMesh.material.emissiveIntensity = 0.5;
                    }, 50);
                }
                if (this.health <= 0) { this.destroy(); return true; }
                return false;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) this.scene.remove(this.mesh);
            }

            getCollisionRadius() { return this.radius; }
        }

        // ============================================
        // Enemy Carrier Class (Á©∫ÊØç„Éª‰ªñ„ÅÆÊïµ„ÇíÁîüÊàê)
        // Wave 5„Åã„ÇâÂá∫Áèæ
        // ============================================
        class EnemyCarrier {
            constructor(scene, position, playerRef, waveNumber = 1) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'carrier';
                this.waveNumber = waveNumber;
                
                // Ë∂ÖÈ´òHP
                this.health = 400 + waveNumber * 80;
                this.maxHealth = this.health;
                this.score = 800 + waveNumber * 100;
                this.speed = 5 + waveNumber * 0.5;
                this.radius = 6;
                
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                
                this.spawnTimer = 0;
                this.spawnCooldown = 4;
                this.maxSpawns = 3 + Math.floor(waveNumber / 2);
                this.spawnCount = 0;
                
                this.fireTimer = 0;
                this.fireCooldown = 1.5;
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Â∑®Â§ß„Å™Êú¨‰Ωì
                const bodyGeo = new THREE.BoxGeometry(10, 4, 15);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x553355,
                    metalness: 0.85,
                    roughness: 0.4,
                    emissive: 0x221122,
                    emissiveIntensity: 0.3
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(body);
                this.bodyMesh = body;
                
                // „Éá„ÉÉ„Ç≠
                const deckGeo = new THREE.BoxGeometry(8, 0.5, 12);
                const deckMat = new THREE.MeshStandardMaterial({
                    color: 0x442244,
                    metalness: 0.7,
                    roughness: 0.5
                });
                const deck = new THREE.Mesh(deckGeo, deckMat);
                deck.position.y = 2.5;
                this.mesh.add(deck);
                
                // „Éñ„É™„ÉÉ„Ç∏
                const bridgeGeo = new THREE.BoxGeometry(3, 3, 4);
                const bridge = new THREE.Mesh(bridgeGeo, bodyMat);
                bridge.position.set(0, 4, -3);
                this.mesh.add(bridge);
                
                // „Ç®„É≥„Ç∏„É≥„Éù„ÉÉ„Éâ
                [-4, 4].forEach(x => {
                    const engineGeo = new THREE.CylinderGeometry(1, 1.5, 4, 8);
                    const engineMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                    const engine = new THREE.Mesh(engineGeo, engineMat);
                    engine.rotation.x = Math.PI / 2;
                    engine.position.set(x, 0, 8);
                    this.mesh.add(engine);
                    
                    // „Ç®„É≥„Ç∏„É≥„Ç∞„É≠„Éº
                    const glowGeo = new THREE.SphereGeometry(1.2, 8, 8);
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: 0x9900ff,
                        transparent: true,
                        opacity: 0.7
                    });
                    const glow = new THREE.Mesh(glowGeo, glowMat);
                    glow.position.set(x, 0, 10);
                    this.mesh.add(glow);
                });
                
                // Á†≤Âè∞
                [-3, 0, 3].forEach(x => {
                    const turretGeo = new THREE.CylinderGeometry(0.4, 0.5, 1.5, 8);
                    const turretMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
                    const turret = new THREE.Mesh(turretGeo, turretMat);
                    turret.position.set(x, 3, 0);
                    this.mesh.add(turret);
                });
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime, projectiles, enemies) {
                if (!this.alive || !this.player) return;
                
                this.spawnTimer += deltaTime;
                this.fireTimer += deltaTime;
                
                // „ÇÜ„Å£„Åè„ÇäÂâçÈÄ≤
                this.velocity.set(0, 0, this.speed);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Â∞èÂûãÊ©ü„Çí„Çπ„Éù„Éº„É≥
                if (this.spawnTimer >= this.spawnCooldown && this.spawnCount < this.maxSpawns) {
                    this.spawnFighter(enemies);
                    this.spawnTimer = 0;
                    this.spawnCount++;
                }
                
                // Êï£ÂºæÁô∫Â∞Ñ
                if (this.fireTimer >= this.fireCooldown) {
                    this.fireSpread(projectiles);
                    this.fireTimer = 0;
                }
                
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.player.position);
                
                if (this.position.z > 60) this.destroy();
            }

            spawnFighter(enemies) {
                // Â∑¶Âè≥„Åã„Çâ„Çπ„Ç¶„Ç©„Éº„É†„ÇíÁô∫ÈÄ≤
                [-6, 6].forEach(x => {
                    const spawnPos = this.position.clone().add(new THREE.Vector3(x, 2, -5));
                    const swarm = new EnemySwarm(this.scene, spawnPos, this.player, this.waveNumber);
                    enemies.push(swarm);
                });
            }

            fireSpread(projectiles) {
                // 5ÊñπÂêë„Å´Êï£Âºæ
                for (let i = -2; i <= 2; i++) {
                    const baseDir = this.player.position.clone().sub(this.position).normalize();
                    const spread = new THREE.Vector3(i * 0.15, 0, 0);
                    const direction = baseDir.add(spread).normalize();
                    
                    const projectile = new Projectile(
                        this.scene,
                        this.position.clone().add(new THREE.Vector3(i * 2, 3, -5)),
                        direction,
                        false
                    );
                    projectile.damage = 15;
                    projectile.speed = 100;
                    projectiles.push(projectile);
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.bodyMesh) {
                    this.bodyMesh.material.emissiveIntensity = 0.8;
                    setTimeout(() => {
                        if (this.bodyMesh) this.bodyMesh.material.emissiveIntensity = 0.3;
                    }, 100);
                }
                if (this.health <= 0) { this.destroy(); return true; }
                return false;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) this.scene.remove(this.mesh);
            }

            getCollisionRadius() { return this.radius; }
        }

        // ============================================
        // Mine Class
        // ============================================
        class Mine {
            constructor(scene, position) {
                this.scene = scene;
                this.alive = true;
                this.type = 'mine';
                
                this.position = position.clone();
                this.damage = 30;
                this.radius = 1.5;
                this.triggerRadius = 8;
                this.lifetime = 15;
                this.age = 0;
                this.armed = false;
                this.armTime = 1;
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Mine body
                const bodyGeo = new THREE.OctahedronGeometry(1, 0);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xff6600,
                    metalness: 0.7,
                    roughness: 0.3,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.3
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(body);
                this.mineBody = body;
                
                // Spikes
                const spikeGeo = new THREE.ConeGeometry(0.2, 0.8, 4);
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
                
                const spikeDirections = [
                    [1, 0, 0], [-1, 0, 0],
                    [0, 1, 0], [0, -1, 0],
                    [0, 0, 1], [0, 0, -1]
                ];
                
                spikeDirections.forEach(dir => {
                    const spike = new THREE.Mesh(spikeGeo, spikeMat);
                    spike.position.set(dir[0] * 1.2, dir[1] * 1.2, dir[2] * 1.2);
                    spike.lookAt(spike.position.clone().multiplyScalar(2));
                    this.mesh.add(spike);
                });
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime, playerPosition) {
                if (!this.alive) return false;
                
                this.age += deltaTime;
                
                // Arm after delay
                if (!this.armed && this.age >= this.armTime) {
                    this.armed = true;
                }
                
                // Expire
                if (this.age >= this.lifetime) {
                    this.destroy();
                    return false;
                }
                
                // Rotate
                this.mesh.rotation.y += deltaTime * 2;
                this.mesh.rotation.x += deltaTime;
                
                // Pulse when armed
                if (this.armed) {
                    const pulse = Math.sin(this.age * 10) * 0.5 + 0.5;
                    this.mineBody.material.emissiveIntensity = 0.3 + pulse * 0.7;
                    
                    // Check trigger radius
                    const dist = this.position.distanceTo(playerPosition);
                    if (dist < this.triggerRadius) {
                        return true; // Signal to explode
                    }
                }
                
                return false;
            }

            destroy() {
                this.alive = false;
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                }
            }

            explode() {
                this.destroy();
            }

            getCollisionRadius() {
                return this.radius;
            }
        }

        // ============================================
        // Boss Base Class (ÂÖ±ÈÄöÊ©üËÉΩ)
        // ============================================
        class BossAlien {
            constructor(scene, position, playerRef, waveNumber) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'boss';
                this.waveNumber = waveNumber;
                this.isBoss = true;
                
                // „Éú„ÇπÂÖ±ÈÄöË®≠ÂÆö
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                this.targetPosition = new THREE.Vector3();
                
                // ÊîªÊíÉ„Çø„Ç§„Éû„Éº
                this.attackTimer = 0;
                this.specialAttackTimer = 0;
                this.phaseTimer = 0;
                this.currentPhase = 0;
                
                // „Éú„É†„ÉÄ„É°„Éº„Ç∏Âà∂Èôê
                this.bombDamageLimit = 500;
            }

            // „Éú„É†„ÉÄ„É°„Éº„Ç∏Âà∂Èôê‰ªò„Åç„ÅÆ„ÉÄ„É°„Éº„Ç∏Âá¶ÁêÜ
            takeDamage(amount, isBomb = false) {
                const actualDamage = isBomb ? Math.min(amount, this.bombDamageLimit) : amount;
                this.health -= actualDamage;
                
                // „ÉÄ„É°„Éº„Ç∏„Éï„É©„ÉÉ„Ç∑„É•
                this.flashDamage();
                
                if (this.health <= 0) {
                    this.destroy();
                    return true;
                }
                return false;
            }

            flashDamage() {
                // Â≠ê„ÇØ„É©„Çπ„Åß„Ç™„Éº„Éê„Éº„É©„Ç§„Éâ
            }

            destroy() {
                this.alive = false;
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                }
            }

            getCollisionRadius() {
                return this.radius || 10;
            }
        }

        // ============================================
        // Wave 1 Boss: „É©„Éº„É¥„Ç°„Éª„Çπ„Éù„Éº„É≥ (Âπº‰Ωì„Ç®„Ç§„É™„Ç¢„É≥)
        // Â∞èÂûã„Å†„ÅåÁ¥†Êó©„ÅÑ„ÄÅÂü∫Êú¨ÊîªÊíÉ„ÅÆ„Åø
        // ============================================
        class BossLarvaSpawn extends BossAlien {
            constructor(scene, position, playerRef, waveNumber) {
                super(scene, position, playerRef, waveNumber);
                
                this.health = 800;
                this.maxHealth = this.health;
                this.score = 2000;
                this.speed = 25;
                this.radius = 8;
                
                this.fireRate = 0.8;
                this.burstCount = 0;
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Êú¨‰Ωì - Ê•ïÂÜÜÂΩ¢„ÅÆÊúâÊ©üÁöÑ„Å™„Éú„Éá„Ç£
                const bodyGeo = new THREE.SphereGeometry(6, 16, 12);
                bodyGeo.scale(1, 0.7, 1.3);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x44aa44,
                    metalness: 0.3,
                    roughness: 0.7,
                    emissive: 0x115511,
                    emissiveIntensity: 0.4
                });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(this.body);
                
                // ÁõÆ - Â§ß„Åç„Å™Ë§áÁúº
                const eyeGeo = new THREE.SphereGeometry(2, 16, 16);
                const eyeMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.9
                });
                this.leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                this.leftEye.position.set(-3, 2, -4);
                this.mesh.add(this.leftEye);
                
                this.rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                this.rightEye.position.set(3, 2, -4);
                this.mesh.add(this.rightEye);
                
                // Â∞è„Åï„Å™Ëß¶Êâã
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const tentacle = this.createTentacle(3, 0.5, 0x338833);
                    tentacle.position.set(
                        Math.cos(angle) * 5,
                        -2,
                        Math.sin(angle) * 5
                    );
                    tentacle.rotation.x = Math.PI / 4;
                    tentacle.rotation.y = angle;
                    this.mesh.add(tentacle);
                }
                
                // Âè£ - Áô∫ÂÖâ„Åô„ÇãÈñãÂè£ÈÉ®
                const mouthGeo = new THREE.CircleGeometry(2, 16);
                const mouthMat = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7
                });
                this.mouth = new THREE.Mesh(mouthGeo, mouthMat);
                this.mouth.position.set(0, -1, -6);
                this.mesh.add(this.mouth);
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            createTentacle(length, radius, color) {
                const group = new THREE.Group();
                const segments = 5;
                for (let i = 0; i < segments; i++) {
                    const segGeo = new THREE.SphereGeometry(radius * (1 - i * 0.15), 8, 8);
                    const segMat = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.2,
                        roughness: 0.8
                    });
                    const seg = new THREE.Mesh(segGeo, segMat);
                    seg.position.y = -i * (length / segments);
                    group.add(seg);
                }
                return group;
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                this.attackTimer += deltaTime;
                this.phaseTimer += deltaTime;
                
                // ÁîªÈù¢ÂÜÖ„ÇíÂãï„ÅçÂõû„Çã
                if (this.phaseTimer > 2) {
                    this.targetPosition.set(
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 25,
                        -40 + (Math.random() - 0.5) * 20
                    );
                    this.phaseTimer = 0;
                }
                
                // ÁßªÂãï
                const toTarget = this.targetPosition.clone().sub(this.position);
                this.velocity.lerp(toTarget.normalize().multiplyScalar(this.speed), deltaTime * 2);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // ÊîªÊíÉ
                if (this.attackTimer >= this.fireRate) {
                    this.fireSpread(projectiles);
                    this.attackTimer = 0;
                }
                
                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.player.position);
                
                // ÁõÆ„ÅÆËÑàÂãï
                const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                this.leftEye.scale.setScalar(pulse);
                this.rightEye.scale.setScalar(pulse);
                
                // Ëß¶Êâã„ÅÆ„ÅÜ„Å≠„Çä
                this.mesh.children.forEach((child, i) => {
                    if (i > 3) {
                        child.rotation.z = Math.sin(Date.now() * 0.003 + i) * 0.3;
                    }
                });
            }

            fireSpread(projectiles) {
                const baseDir = this.player.position.clone().sub(this.position).normalize();
                for (let i = -2; i <= 2; i++) {
                    const spread = new THREE.Vector3(i * 0.1, 0, 0);
                    const dir = baseDir.clone().add(spread).normalize();
                    const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                    proj.damage = 15;
                    proj.speed = 100;
                    projectiles.push(proj);
                }
            }

            flashDamage() {
                if (this.body) {
                    this.body.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (this.body) this.body.material.emissiveIntensity = 0.4;
                    }, 100);
                }
            }
        }

        // ============================================
        // Wave 2 Boss: „É¥„Çß„Éé„É†„Éª„ÇØ„É≠„Éº„É©„Éº (ÊØíËúòËõõ„Ç®„Ç§„É™„Ç¢„É≥)
        // 8Êú¨„ÅÆËÑö„ÄÅÊØíÂºæÊîªÊíÉ
        // ============================================
        class BossVenomCrawler extends BossAlien {
            constructor(scene, position, playerRef, waveNumber) {
                super(scene, position, playerRef, waveNumber);
                
                this.health = 1500;
                this.maxHealth = this.health;
                this.score = 4000;
                this.speed = 30;
                this.radius = 12;
                
                this.fireRate = 0.6;
                this.webTimer = 0;
                this.legs = [];
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Êú¨‰Ωì - ËúòËõõ„ÅÆ„Çà„ÅÜ„Å™Ê•ïÂÜÜÂΩ¢
                const bodyGeo = new THREE.SphereGeometry(8, 16, 12);
                bodyGeo.scale(1.2, 0.6, 1);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x550077,
                    metalness: 0.4,
                    roughness: 0.6,
                    emissive: 0x220033,
                    emissiveIntensity: 0.5
                });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(this.body);
                
                // ËÖπÈÉ®
                const abdomenGeo = new THREE.SphereGeometry(6, 16, 12);
                abdomenGeo.scale(1, 0.8, 1.5);
                const abdomenMat = new THREE.MeshStandardMaterial({
                    color: 0x440066,
                    metalness: 0.3,
                    roughness: 0.7,
                    emissive: 0x110022,
                    emissiveIntensity: 0.3
                });
                const abdomen = new THREE.Mesh(abdomenGeo, abdomenMat);
                abdomen.position.z = 8;
                this.mesh.add(abdomen);
                
                // 8Êú¨„ÅÆËÑö
                for (let i = 0; i < 8; i++) {
                    const side = i < 4 ? -1 : 1;
                    const index = i % 4;
                    const leg = this.createSpiderLeg(10, 0x660088);
                    leg.position.set(side * 6, 0, -3 + index * 3);
                    leg.rotation.z = side * Math.PI / 4;
                    this.mesh.add(leg);
                    this.legs.push(leg);
                }
                
                // Ë§áÊï∞„ÅÆÁõÆÔºà8„Å§Ôºâ
                for (let i = 0; i < 8; i++) {
                    const eyeGeo = new THREE.SphereGeometry(0.8, 8, 8);
                    const eyeMat = new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.9
                    });
                    const eye = new THREE.Mesh(eyeGeo, eyeMat);
                    const row = Math.floor(i / 4);
                    const col = i % 4;
                    eye.position.set(-3 + col * 2, 3 - row, -6);
                    this.mesh.add(eye);
                }
                
                // ÊØíÁâô
                const fangGeo = new THREE.ConeGeometry(0.8, 4, 8);
                const fangMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                const leftFang = new THREE.Mesh(fangGeo, fangMat);
                leftFang.position.set(-2, -2, -7);
                leftFang.rotation.x = Math.PI / 6;
                this.mesh.add(leftFang);
                
                const rightFang = new THREE.Mesh(fangGeo, fangMat);
                rightFang.position.set(2, -2, -7);
                rightFang.rotation.x = Math.PI / 6;
                this.mesh.add(rightFang);
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            createSpiderLeg(length, color) {
                const group = new THREE.Group();
                // ‰∏äÈÉ®
                const upperGeo = new THREE.CylinderGeometry(0.4, 0.6, length * 0.5, 8);
                const legMat = new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: 0.5,
                    roughness: 0.5
                });
                const upper = new THREE.Mesh(upperGeo, legMat);
                upper.rotation.z = Math.PI / 4;
                upper.position.y = length * 0.2;
                group.add(upper);
                
                // ‰∏ãÈÉ®
                const lowerGeo = new THREE.CylinderGeometry(0.2, 0.4, length * 0.6, 8);
                const lower = new THREE.Mesh(lowerGeo, legMat);
                lower.rotation.z = -Math.PI / 6;
                lower.position.set(length * 0.3, -length * 0.2, 0);
                group.add(lower);
                
                return group;
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                this.attackTimer += deltaTime;
                this.webTimer += deltaTime;
                this.phaseTimer += deltaTime;
                
                // Á¥†Êó©„ÅÑÁßªÂãï
                if (this.phaseTimer > 1.5) {
                    this.targetPosition.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 30,
                        -45 + (Math.random() - 0.5) * 25
                    );
                    this.phaseTimer = 0;
                }
                
                const toTarget = this.targetPosition.clone().sub(this.position);
                this.velocity.lerp(toTarget.normalize().multiplyScalar(this.speed), deltaTime * 3);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // ÈÄöÂ∏∏ÊîªÊíÉ
                if (this.attackTimer >= this.fireRate) {
                    this.fireVenom(projectiles);
                    this.attackTimer = 0;
                }
                
                // ËúòËõõ„ÅÆÂ∑£ÊîªÊíÉÔºàÁâπÊÆäÔºâ
                if (this.webTimer >= 4) {
                    this.fireWebSpread(projectiles);
                    this.webTimer = 0;
                }
                
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.player.position);
                
                // ËÑö„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.legs.forEach((leg, i) => {
                    leg.rotation.x = Math.sin(Date.now() * 0.005 + i * 0.5) * 0.3;
                });
            }

            fireVenom(projectiles) {
                const dir = this.player.position.clone().sub(this.position).normalize();
                const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                proj.damage = 20;
                proj.speed = 120;
                projectiles.push(proj);
            }

            fireWebSpread(projectiles) {
                // ÊîæÂ∞ÑÁä∂„Å´ÊØíÂºæ
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const dir = new THREE.Vector3(
                        Math.cos(angle),
                        Math.sin(angle) * 0.5,
                        -0.5
                    ).normalize();
                    const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                    proj.damage = 15;
                    proj.speed = 80;
                    projectiles.push(proj);
                }
            }

            flashDamage() {
                if (this.body) {
                    this.body.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (this.body) this.body.material.emissiveIntensity = 0.5;
                    }, 100);
                }
            }
        }

        // ============================================
        // Wave 3 Boss: „Ç§„É≥„Éï„Çß„É´„Éé„Éª„Éì„Éº„Çπ„Éà (ÁÇéÁç£„Ç®„Ç§„É™„Ç¢„É≥)
        // ÁÇé„ÅÆ„Éñ„É¨„ÇπÊîªÊíÉ„ÄÅÁ™ÅÈÄ≤
        // ============================================
        class BossInfernoBeast extends BossAlien {
            constructor(scene, position, playerRef, waveNumber) {
                super(scene, position, playerRef, waveNumber);
                
                this.health = 2500;
                this.maxHealth = this.health;
                this.score = 6000;
                this.speed = 35;
                this.radius = 15;
                
                this.fireRate = 0.5;
                this.breathTimer = 0;
                this.chargeTimer = 0;
                this.isCharging = false;
                this.chargeDirection = new THREE.Vector3();
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Â∑®Â§ß„Å™Êú¨‰Ωì
                const bodyGeo = new THREE.SphereGeometry(10, 16, 16);
                bodyGeo.scale(1.3, 1, 1.5);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xaa2200,
                    metalness: 0.5,
                    roughness: 0.5,
                    emissive: 0x551100,
                    emissiveIntensity: 0.6
                });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(this.body);
                
                // ËßíÔºàË§áÊï∞Ôºâ
                for (let i = 0; i < 4; i++) {
                    const hornGeo = new THREE.ConeGeometry(1.5, 8, 8);
                    const hornMat = new THREE.MeshStandardMaterial({
                        color: 0x111111,
                        metalness: 0.8,
                        roughness: 0.3
                    });
                    const horn = new THREE.Mesh(hornGeo, hornMat);
                    const angle = (i / 4) * Math.PI - Math.PI / 2;
                    horn.position.set(Math.cos(angle) * 6, 8, Math.sin(angle) * 3 - 5);
                    horn.rotation.x = -Math.PI / 4;
                    horn.rotation.z = Math.cos(angle) * 0.3;
                    this.mesh.add(horn);
                }
                
                // ÁáÉ„Åà„ÇãÁõÆ
                const eyeGeo = new THREE.SphereGeometry(2.5, 16, 16);
                const eyeMat = new THREE.MeshBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.95
                });
                this.leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                this.leftEye.position.set(-5, 4, -10);
                this.mesh.add(this.leftEye);
                
                this.rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                this.rightEye.position.set(5, 4, -10);
                this.mesh.add(this.rightEye);
                
                // Âè£ÔºàÁÇé„ÇíÂêê„ÅèÔºâ
                const mouthGeo = new THREE.BoxGeometry(8, 4, 3);
                const mouthMat = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    transparent: true,
                    opacity: 0.8
                });
                this.mouth = new THREE.Mesh(mouthGeo, mouthMat);
                this.mouth.position.set(0, -3, -12);
                this.mesh.add(this.mouth);
                
                // ÁÇé„ÅÆÁ≤íÂ≠êÈ¢®Ë£ÖÈ£æ
                for (let i = 0; i < 20; i++) {
                    const flameGeo = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);
                    const flameMat = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0xff6600 : 0xffaa00,
                        transparent: true,
                        opacity: 0.6
                    });
                    const flame = new THREE.Mesh(flameGeo, flameMat);
                    flame.position.set(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 20
                    );
                    flame.userData.offset = Math.random() * Math.PI * 2;
                    this.mesh.add(flame);
                }
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                this.attackTimer += deltaTime;
                this.breathTimer += deltaTime;
                this.chargeTimer += deltaTime;
                this.phaseTimer += deltaTime;
                
                // Á™ÅÈÄ≤ÊîªÊíÉ
                if (this.isCharging) {
                    this.position.add(this.chargeDirection.clone().multiplyScalar(this.speed * 3 * deltaTime));
                    if (this.chargeTimer > 1) {
                        this.isCharging = false;
                    }
                } else {
                    // ÈÄöÂ∏∏ÁßªÂãï
                    if (this.phaseTimer > 2) {
                        this.targetPosition.set(
                            (Math.random() - 0.5) * 50,
                            (Math.random() - 0.5) * 25,
                            -50 + (Math.random() - 0.5) * 20
                        );
                        this.phaseTimer = 0;
                    }
                    
                    const toTarget = this.targetPosition.clone().sub(this.position);
                    this.velocity.lerp(toTarget.normalize().multiplyScalar(this.speed), deltaTime * 2);
                    this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Á™ÅÈÄ≤ÈñãÂßã
                    if (this.chargeTimer > 5 && Math.random() < 0.02) {
                        this.isCharging = true;
                        this.chargeTimer = 0;
                        this.chargeDirection = this.player.position.clone().sub(this.position).normalize();
                    }
                }
                
                // ÁÇéÂºæÊîªÊíÉ
                if (this.attackTimer >= this.fireRate) {
                    this.fireFlame(projectiles);
                    this.attackTimer = 0;
                }
                
                // „Éñ„É¨„ÇπÊîªÊíÉ
                if (this.breathTimer >= 3) {
                    this.fireBreath(projectiles);
                    this.breathTimer = 0;
                }
                
                this.mesh.position.copy(this.position);
                this.mesh.lookAt(this.player.position);
                
                // ÁÇé„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.mesh.children.forEach((child, i) => {
                    if (child.userData.offset !== undefined) {
                        child.position.y += Math.sin(Date.now() * 0.01 + child.userData.offset) * 0.1;
                        child.scale.setScalar(0.8 + Math.sin(Date.now() * 0.02 + child.userData.offset) * 0.3);
                    }
                });
                
                // ÁõÆ„ÅÆËÑàÂãï
                const pulse = 1 + Math.sin(Date.now() * 0.008) * 0.3;
                this.leftEye.scale.setScalar(pulse);
                this.rightEye.scale.setScalar(pulse);
            }

            fireFlame(projectiles) {
                for (let i = -1; i <= 1; i++) {
                    const baseDir = this.player.position.clone().sub(this.position).normalize();
                    baseDir.x += i * 0.15;
                    const proj = new Projectile(this.scene, this.mouth.getWorldPosition(new THREE.Vector3()), baseDir.normalize(), false);
                    proj.damage = 20;
                    proj.speed = 110;
                    projectiles.push(proj);
                }
            }

            fireBreath(projectiles) {
                // ÊâáÁä∂„ÅÆÁÇé„Éñ„É¨„Çπ
                for (let i = 0; i < 15; i++) {
                    const spread = (i - 7) * 0.08;
                    const baseDir = this.player.position.clone().sub(this.position).normalize();
                    baseDir.x += spread;
                    baseDir.y += (Math.random() - 0.5) * 0.1;
                    const proj = new Projectile(this.scene, this.mouth.getWorldPosition(new THREE.Vector3()), baseDir.normalize(), false);
                    proj.damage = 15;
                    proj.speed = 90 + Math.random() * 30;
                    projectiles.push(proj);
                }
            }

            flashDamage() {
                if (this.body) {
                    this.body.material.emissiveIntensity = 1.2;
                    setTimeout(() => {
                        if (this.body) this.body.material.emissiveIntensity = 0.6;
                    }, 100);
                }
            }
        }

        // ============================================
        // Wave 4 Boss: „É¥„Ç©„Ç§„Éâ„Éª„ÉÜ„É©„Éº (ËôöÁ©∫„ÅÆÊÅêÊÄñ)
        // Ëß¶ÊâãÊîªÊíÉ„ÄÅ„Éì„Éº„É†„ÄÅ„ÉÜ„É¨„Éù„Éº„Éà
        // ============================================
        class BossVoidTerror extends BossAlien {
            constructor(scene, position, playerRef, waveNumber) {
                super(scene, position, playerRef, waveNumber);
                
                this.health = 4000;
                this.maxHealth = this.health;
                this.score = 10000;
                this.speed = 40;
                this.radius = 18;
                
                this.fireRate = 0.4;
                this.beamTimer = 0;
                this.tentacleTimer = 0;
                this.teleportTimer = 0;
                this.tentacles = [];
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // ‰∏≠ÂøÉÊ†∏ - Èóá„ÅÆ„Ç®„Éç„É´„ÇÆ„Éº
                const coreGeo = new THREE.IcosahedronGeometry(8, 2);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: 0x110033,
                    metalness: 0.9,
                    roughness: 0.2,
                    emissive: 0x220066,
                    emissiveIntensity: 0.8
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);
                this.mesh.add(this.core);
                
                // Â§ñÊÆª - ÂçäÈÄèÊòé
                const shellGeo = new THREE.IcosahedronGeometry(12, 1);
                const shellMat = new THREE.MeshStandardMaterial({
                    color: 0x330066,
                    metalness: 0.7,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.4
                });
                this.shell = new THREE.Mesh(shellGeo, shellMat);
                this.mesh.add(this.shell);
                
                // Â∑®Â§ß„Å™ÁõÆÔºà‰∏≠Â§ÆÔºâ
                const eyeGeo = new THREE.SphereGeometry(4, 32, 32);
                const eyeMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.95
                });
                this.centralEye = new THREE.Mesh(eyeGeo, eyeMat);
                this.centralEye.position.z = -10;
                this.mesh.add(this.centralEye);
                
                // Áû≥
                const pupilGeo = new THREE.SphereGeometry(2, 16, 16);
                const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                this.pupil = new THREE.Mesh(pupilGeo, pupilMat);
                this.pupil.position.z = -12;
                this.mesh.add(this.pupil);
                
                // 6Êú¨„ÅÆÂ∑®Â§ßËß¶Êâã
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const tentacle = this.createGiantTentacle(25, 2, 0x440088);
                    tentacle.position.set(
                        Math.cos(angle) * 10,
                        Math.sin(angle) * 10,
                        5
                    );
                    tentacle.userData.baseAngle = angle;
                    tentacle.userData.index = i;
                    this.mesh.add(tentacle);
                    this.tentacles.push(tentacle);
                }
                
                // Â∞è„Åï„Å™ÁõÆÔºàÂë®Âõ≤„Å´Êï£„Çâ„Å∞„ÇãÔºâ
                for (let i = 0; i < 12; i++) {
                    const smallEyeGeo = new THREE.SphereGeometry(1, 8, 8);
                    const smallEyeMat = new THREE.MeshBasicMaterial({
                        color: 0xaa00ff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const smallEye = new THREE.Mesh(smallEyeGeo, smallEyeMat);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    smallEye.position.set(
                        Math.sin(phi) * Math.cos(theta) * 14,
                        Math.sin(phi) * Math.sin(theta) * 14,
                        Math.cos(phi) * 14 - 5
                    );
                    this.mesh.add(smallEye);
                }
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            createGiantTentacle(length, radius, color) {
                const group = new THREE.Group();
                const segments = 12;
                for (let i = 0; i < segments; i++) {
                    const t = i / segments;
                    const segRadius = radius * (1 - t * 0.7);
                    const segGeo = new THREE.SphereGeometry(segRadius, 8, 8);
                    const segMat = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.4,
                        roughness: 0.6,
                        emissive: 0x220044,
                        emissiveIntensity: 0.3
                    });
                    const seg = new THREE.Mesh(segGeo, segMat);
                    seg.position.z = i * (length / segments);
                    seg.userData.segIndex = i;
                    group.add(seg);
                }
                // ÂÖàÁ´Ø„ÅÆÊ£ò
                const spikeGeo = new THREE.ConeGeometry(radius * 0.5, 3, 8);
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0xff00ff });
                const spike = new THREE.Mesh(spikeGeo, spikeMat);
                spike.position.z = length;
                spike.rotation.x = Math.PI / 2;
                group.add(spike);
                return group;
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                this.attackTimer += deltaTime;
                this.beamTimer += deltaTime;
                this.tentacleTimer += deltaTime;
                this.teleportTimer += deltaTime;
                this.phaseTimer += deltaTime;
                
                // „ÉÜ„É¨„Éù„Éº„Éà
                if (this.teleportTimer > 6 && Math.random() < 0.01) {
                    this.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 30,
                        -50
                    );
                    this.teleportTimer = 0;
                }
                
                // ÈÄöÂ∏∏ÁßªÂãï
                if (this.phaseTimer > 1) {
                    this.targetPosition.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 30,
                        -55 + (Math.random() - 0.5) * 20
                    );
                    this.phaseTimer = 0;
                }
                
                const toTarget = this.targetPosition.clone().sub(this.position);
                this.velocity.lerp(toTarget.normalize().multiplyScalar(this.speed), deltaTime * 2);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // ÈÄöÂ∏∏ÊîªÊíÉ
                if (this.attackTimer >= this.fireRate) {
                    this.fireVoidBolt(projectiles);
                    this.attackTimer = 0;
                }
                
                // „Éì„Éº„É†ÊîªÊíÉ
                if (this.beamTimer >= 4) {
                    this.fireBeam(projectiles);
                    this.beamTimer = 0;
                }
                
                // Ëß¶ÊâãÊîªÊíÉ
                if (this.tentacleTimer >= 2.5) {
                    this.tentacleAttack(projectiles);
                    this.tentacleTimer = 0;
                }
                
                this.mesh.position.copy(this.position);
                
                // Áû≥„Åå„Éó„É¨„Ç§„É§„Éº„ÇíËøΩË∑°
                const toPlayer = this.player.position.clone().sub(this.position).normalize();
                this.pupil.position.x = toPlayer.x * 2;
                this.pupil.position.y = toPlayer.y * 2;
                
                // Ê†∏„Å®„Ç∑„Çß„É´„ÅÆÂõûËª¢
                this.core.rotation.x += deltaTime * 0.5;
                this.core.rotation.y += deltaTime * 0.3;
                this.shell.rotation.x -= deltaTime * 0.2;
                this.shell.rotation.y -= deltaTime * 0.4;
                
                // Ëß¶Êâã„ÅÆ„ÅÜ„Å≠„Çä
                this.tentacles.forEach((tentacle, i) => {
                    const time = Date.now() * 0.002;
                    tentacle.rotation.x = Math.sin(time + i) * 0.5;
                    tentacle.rotation.y = Math.cos(time + i * 0.7) * 0.5;
                    
                    // ÂêÑ„Çª„Ç∞„É°„É≥„Éà„ÅÆ„ÅÜ„Å≠„Çä
                    tentacle.children.forEach((seg, j) => {
                        if (seg.userData.segIndex !== undefined) {
                            const wave = Math.sin(time * 2 + i + j * 0.3) * 0.5;
                            seg.position.x = wave;
                            seg.position.y = Math.cos(time * 2 + i + j * 0.3) * 0.5;
                        }
                    });
                });
            }

            fireVoidBolt(projectiles) {
                const dir = this.player.position.clone().sub(this.position).normalize();
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        if (!this.alive) return;
                        const proj = new Projectile(this.scene, this.centralEye.getWorldPosition(new THREE.Vector3()), dir.clone(), false);
                        proj.damage = 20;
                        proj.speed = 130;
                        projectiles.push(proj);
                    }, i * 100);
                }
            }

            fireBeam(projectiles) {
                // Âº∑Âäõ„Å™ÈÄ£Á∂ö„Éì„Éº„É†
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        if (!this.alive) return;
                        const dir = this.player.position.clone().sub(this.position).normalize();
                        dir.x += (Math.random() - 0.5) * 0.1;
                        dir.y += (Math.random() - 0.5) * 0.1;
                        const proj = new Projectile(this.scene, this.centralEye.getWorldPosition(new THREE.Vector3()), dir, false);
                        proj.damage = 10;
                        proj.speed = 200;
                        projectiles.push(proj);
                    }, i * 50);
                }
            }

            tentacleAttack(projectiles) {
                // ÂêÑËß¶Êâã„Åã„ÇâÂºæ„ÇíÁô∫Â∞Ñ
                this.tentacles.forEach((tentacle, i) => {
                    const worldPos = new THREE.Vector3();
                    tentacle.getWorldPosition(worldPos);
                    const dir = this.player.position.clone().sub(worldPos).normalize();
                    const proj = new Projectile(this.scene, worldPos, dir, false);
                    proj.damage = 15;
                    proj.speed = 100;
                    projectiles.push(proj);
                });
            }

            flashDamage() {
                if (this.core) {
                    this.core.material.emissiveIntensity = 1.5;
                    setTimeout(() => {
                        if (this.core) this.core.material.emissiveIntensity = 0.8;
                    }, 100);
                }
            }
        }

        // ============================================
        // Wave 5 Boss: „Ç≥„Ç∫„Éü„ÉÉ„ÇØ„Éª„Éá„É¥„Ç°„Ç¶„É©„Éº (ÂÆáÂÆô„ÇíÂñ∞„Çâ„ÅÜËÄÖ)
        // ÊúÄÁµÇ„Éú„Çπ - ÂÖ®ÊîªÊíÉ„Éë„Çø„Éº„É≥„ÄÅÂ∑®Â§ß„ÄÅÁ¶ç„ÄÖ„Åó„ÅÑ
        // ============================================
        class BossCosmicDevourer extends BossAlien {
            constructor(scene, position, playerRef, waveNumber) {
                super(scene, position, playerRef, waveNumber);
                
                this.health = 8000;
                this.maxHealth = this.health;
                this.score = 25000;
                this.speed = 30;
                this.radius = 25;
                
                this.fireRate = 0.3;
                this.beamTimer = 0;
                this.tentacleTimer = 0;
                this.novaTimer = 0;
                this.phase = 1; // 1, 2, 3 (HPÊ∏õÂ∞ë„ÅßÂ§âÂåñ)
                this.tentacles = [];
                this.maws = [];
                
                this.createMesh();
            }

            createMesh() {
                this.mesh = new THREE.Group();
                
                // Â∑®Â§ß„Å™Êú¨‰Ωì - ‰∏çÂÆöÂΩ¢„ÅÆÊÅêÊÄñ
                const bodyGeo = new THREE.IcosahedronGeometry(15, 3);
                // È†ÇÁÇπ„Çí„É©„É≥„ÉÄ„É†„Å´Ê≠™„Åæ„Åõ„Çã
                const positions = bodyGeo.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const noise = 1 + (Math.random() - 0.5) * 0.3;
                    positions.setXYZ(i, x * noise, y * noise, z * noise);
                }
                bodyGeo.computeVertexNormals();
                
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x0a0015,
                    metalness: 0.8,
                    roughness: 0.3,
                    emissive: 0x1a0030,
                    emissiveIntensity: 0.7
                });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(this.body);
                
                // ÂÜÖÈÉ®„ÅÆÂÖâ„ÇãÊ†∏
                const innerCoreGeo = new THREE.SphereGeometry(8, 32, 32);
                const innerCoreMat = new THREE.MeshBasicMaterial({
                    color: 0xff00aa,
                    transparent: true,
                    opacity: 0.6
                });
                this.innerCore = new THREE.Mesh(innerCoreGeo, innerCoreMat);
                this.mesh.add(this.innerCore);
                
                // „É°„Ç§„É≥„ÅÆÂ∑®Â§ß„Å™ÁõÆ
                const mainEyeGeo = new THREE.SphereGeometry(6, 32, 32);
                const mainEyeMat = new THREE.MeshBasicMaterial({
                    color: 0xff0066,
                    transparent: true,
                    opacity: 0.95
                });
                this.mainEye = new THREE.Mesh(mainEyeGeo, mainEyeMat);
                this.mainEye.position.z = -15;
                this.mesh.add(this.mainEye);
                
                // Áû≥ÔºàÊ∑±Ê∑µ„ÇíË¶ã„Å§„ÇÅ„ÇãÔºâ
                const mainPupilGeo = new THREE.SphereGeometry(3, 16, 16);
                const mainPupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                this.mainPupil = new THREE.Mesh(mainPupilGeo, mainPupilMat);
                this.mainPupil.position.z = -18;
                this.mesh.add(this.mainPupil);
                
                // Ë§áÊï∞„ÅÆÂè£ÔºàÂêÑÊñπÂêë„Å´Ôºâ
                for (let i = 0; i < 4; i++) {
                    const maw = this.createMaw(8, 0xff0033);
                    const angle = (i / 4) * Math.PI * 2;
                    maw.position.set(
                        Math.cos(angle) * 12,
                        Math.sin(angle) * 8,
                        -10
                    );
                    maw.rotation.z = angle;
                    this.mesh.add(maw);
                    this.maws.push(maw);
                }
                
                // 10Êú¨„ÅÆÂ∑®Â§ßËß¶Êâã
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2;
                    const tentacle = this.createMassiveTentacle(35, 3, 0x220044);
                    tentacle.position.set(
                        Math.cos(angle) * 15,
                        Math.sin(angle) * 15,
                        8
                    );
                    tentacle.userData.baseAngle = angle;
                    tentacle.userData.index = i;
                    this.mesh.add(tentacle);
                    this.tentacles.push(tentacle);
                }
                
                // Ê£ò„ÅÆ„Çà„ÅÜ„Å™Á™ÅËµ∑
                for (let i = 0; i < 30; i++) {
                    const spikeGeo = new THREE.ConeGeometry(1, 5 + Math.random() * 5, 6);
                    const spikeMat = new THREE.MeshStandardMaterial({
                        color: 0x330022,
                        metalness: 0.7,
                        roughness: 0.4
                    });
                    const spike = new THREE.Mesh(spikeGeo, spikeMat);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = 16;
                    spike.position.set(
                        Math.sin(phi) * Math.cos(theta) * r,
                        Math.sin(phi) * Math.sin(theta) * r,
                        Math.cos(phi) * r
                    );
                    spike.lookAt(spike.position.clone().multiplyScalar(2));
                    this.mesh.add(spike);
                }
                
                // Âë®Âõ≤„ÇíÊºÇ„ÅÜÂ∞è„Åï„Å™ÁõÆ
                for (let i = 0; i < 20; i++) {
                    const floatEyeGeo = new THREE.SphereGeometry(1.5, 8, 8);
                    const floatEyeMat = new THREE.MeshBasicMaterial({
                        color: 0xff00ff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const floatEye = new THREE.Mesh(floatEyeGeo, floatEyeMat);
                    floatEye.userData.orbitRadius = 20 + Math.random() * 10;
                    floatEye.userData.orbitSpeed = 0.5 + Math.random() * 0.5;
                    floatEye.userData.orbitOffset = Math.random() * Math.PI * 2;
                    floatEye.userData.isFloatingEye = true;
                    this.mesh.add(floatEye);
                }
                
                this.mesh.position.copy(this.position);
                this.scene.add(this.mesh);
            }

            createMaw(size, color) {
                const group = new THREE.Group();
                
                // Âè£„ÅÆÂ§ñÁ∏Å
                const ringGeo = new THREE.TorusGeometry(size, size * 0.3, 8, 16);
                const ringMat = new THREE.MeshStandardMaterial({
                    color: 0x220011,
                    metalness: 0.5,
                    roughness: 0.6
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                group.add(ring);
                
                // ÂÜÖÈÉ®„ÅÆÁô∫ÂÖâ
                const innerGeo = new THREE.CircleGeometry(size * 0.7, 16);
                const innerMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                const inner = new THREE.Mesh(innerGeo, innerMat);
                inner.position.z = 0.1;
                group.add(inner);
                
                // Ê≠Ø
                for (let i = 0; i < 12; i++) {
                    const toothGeo = new THREE.ConeGeometry(0.5, 2, 4);
                    const toothMat = new THREE.MeshStandardMaterial({ color: 0xffffcc });
                    const tooth = new THREE.Mesh(toothGeo, toothMat);
                    const angle = (i / 12) * Math.PI * 2;
                    tooth.position.set(
                        Math.cos(angle) * size * 0.8,
                        Math.sin(angle) * size * 0.8,
                        1
                    );
                    tooth.rotation.x = Math.PI;
                    group.add(tooth);
                }
                
                return group;
            }

            createMassiveTentacle(length, radius, color) {
                const group = new THREE.Group();
                const segments = 15;
                for (let i = 0; i < segments; i++) {
                    const t = i / segments;
                    const segRadius = radius * (1 - t * 0.6);
                    const segGeo = new THREE.SphereGeometry(segRadius, 8, 8);
                    const segMat = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.5,
                        roughness: 0.5,
                        emissive: 0x110022,
                        emissiveIntensity: 0.4
                    });
                    const seg = new THREE.Mesh(segGeo, segMat);
                    seg.position.z = i * (length / segments);
                    seg.userData.segIndex = i;
                    group.add(seg);
                    
                    // Âê∏Áõ§
                    if (i > 2 && i < segments - 2 && i % 2 === 0) {
                        const suckerGeo = new THREE.SphereGeometry(segRadius * 0.4, 8, 8);
                        const suckerMat = new THREE.MeshStandardMaterial({ color: 0x440044 });
                        const sucker = new THREE.Mesh(suckerGeo, suckerMat);
                        sucker.position.set(segRadius, 0, i * (length / segments));
                        group.add(sucker);
                    }
                }
                // ÂÖàÁ´Ø„ÅÆÈã≠„ÅÑÁà™
                const clawGeo = new THREE.ConeGeometry(radius * 0.8, 5, 6);
                const clawMat = new THREE.MeshStandardMaterial({
                    color: 0xff0066,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const claw = new THREE.Mesh(clawGeo, clawMat);
                claw.position.z = length;
                claw.rotation.x = Math.PI / 2;
                group.add(claw);
                return group;
            }

            update(deltaTime, projectiles) {
                if (!this.alive || !this.player) return;
                
                // „Éï„Çß„Éº„Ç∫Êõ¥Êñ∞
                const healthPercent = this.health / this.maxHealth;
                if (healthPercent < 0.3) this.phase = 3;
                else if (healthPercent < 0.6) this.phase = 2;
                else this.phase = 1;
                
                this.attackTimer += deltaTime;
                this.beamTimer += deltaTime;
                this.tentacleTimer += deltaTime;
                this.novaTimer += deltaTime;
                this.phaseTimer += deltaTime;
                
                // ÁßªÂãïÔºà„Éï„Çß„Éº„Ç∫„ÅßÈÄüÂ∫¶Â§âÂåñÔºâ
                const currentSpeed = this.speed * (1 + (3 - this.phase) * 0.3);
                
                if (this.phaseTimer > 1.5) {
                    this.targetPosition.set(
                        (Math.random() - 0.5) * 70,
                        (Math.random() - 0.5) * 35,
                        -60 + (Math.random() - 0.5) * 25
                    );
                    this.phaseTimer = 0;
                }
                
                const toTarget = this.targetPosition.clone().sub(this.position);
                this.velocity.lerp(toTarget.normalize().multiplyScalar(currentSpeed), deltaTime * 2);
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // ÈÄöÂ∏∏ÊîªÊíÉÔºà„Éï„Çß„Éº„Ç∫„ÅßÈ†ªÂ∫¶UPÔºâ
                const currentFireRate = this.fireRate / this.phase;
                if (this.attackTimer >= currentFireRate) {
                    this.fireChaosBolt(projectiles);
                    this.attackTimer = 0;
                }
                
                // „Éì„Éº„É†ÊîªÊíÉ
                const beamCooldown = 5 - this.phase;
                if (this.beamTimer >= beamCooldown) {
                    this.fireDeathBeam(projectiles);
                    this.beamTimer = 0;
                }
                
                // Ëß¶ÊâãÊîªÊíÉ
                const tentacleCooldown = 3 - this.phase * 0.5;
                if (this.tentacleTimer >= tentacleCooldown) {
                    this.tentacleSweep(projectiles);
                    this.tentacleTimer = 0;
                }
                
                // Á†¥ÊªÖ„ÅÆ„Éé„É¥„Ç°Ôºà„Éï„Çß„Éº„Ç∫3„ÅÆ„ÅøÔºâ
                if (this.phase === 3 && this.novaTimer >= 8) {
                    this.doomNova(projectiles);
                    this.novaTimer = 0;
                }
                
                this.mesh.position.copy(this.position);
                
                // Áû≥„ÅÆËøΩË∑°
                const toPlayer = this.player.position.clone().sub(this.position).normalize();
                this.mainPupil.position.x = toPlayer.x * 3;
                this.mainPupil.position.y = toPlayer.y * 3;
                
                // Êú¨‰Ωì„ÅÆËÑàÂãï
                const pulse = 1 + Math.sin(Date.now() * 0.003) * 0.05;
                this.body.scale.setScalar(pulse);
                
                // ÂÜÖÈÉ®Ê†∏„ÅÆÂõûËª¢
                this.innerCore.rotation.x += deltaTime;
                this.innerCore.rotation.y += deltaTime * 0.7;
                
                // ÊµÆÈÅä„Åô„ÇãÁõÆ„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                this.mesh.children.forEach(child => {
                    if (child.userData.isFloatingEye) {
                        const time = Date.now() * 0.001 * child.userData.orbitSpeed;
                        const r = child.userData.orbitRadius;
                        const offset = child.userData.orbitOffset;
                        child.position.set(
                            Math.cos(time + offset) * r,
                            Math.sin(time * 0.7 + offset) * r * 0.5,
                            Math.sin(time + offset) * r * 0.3
                        );
                    }
                });
                
                // Ëß¶Êâã„ÅÆ„ÅÜ„Å≠„Çä
                this.tentacles.forEach((tentacle, i) => {
                    const time = Date.now() * 0.002;
                    tentacle.rotation.x = Math.sin(time + i) * 0.6;
                    tentacle.rotation.y = Math.cos(time + i * 0.7) * 0.6;
                    
                    tentacle.children.forEach((seg, j) => {
                        if (seg.userData.segIndex !== undefined) {
                            const wave = Math.sin(time * 2 + i + j * 0.2) * (j * 0.1);
                            seg.position.x = wave;
                            seg.position.y = Math.cos(time * 2 + i + j * 0.2) * (j * 0.1);
                        }
                    });
                });
                
                // Âè£„ÅÆËÑàÂãï
                this.maws.forEach((maw, i) => {
                    const mawPulse = 1 + Math.sin(Date.now() * 0.005 + i) * 0.2;
                    maw.scale.setScalar(mawPulse);
                });
            }

            fireChaosBolt(projectiles) {
                // Ë§áÊï∞ÊñπÂêë„Åã„Çâ„ÅÆÊîªÊíÉ
                for (let i = 0; i < 3 + this.phase; i++) {
                    const baseDir = this.player.position.clone().sub(this.position).normalize();
                    baseDir.x += (Math.random() - 0.5) * 0.3;
                    baseDir.y += (Math.random() - 0.5) * 0.3;
                    const proj = new Projectile(this.scene, this.mainEye.getWorldPosition(new THREE.Vector3()), baseDir.normalize(), false);
                    proj.damage = 15;
                    proj.speed = 120 + this.phase * 20;
                    projectiles.push(proj);
                }
            }

            fireDeathBeam(projectiles) {
                // Á†¥Â£äÁöÑ„Å™„Éì„Éº„É†
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        if (!this.alive) return;
                        const dir = this.player.position.clone().sub(this.position).normalize();
                        dir.x += (Math.random() - 0.5) * 0.05;
                        dir.y += (Math.random() - 0.5) * 0.05;
                        const proj = new Projectile(this.scene, this.mainEye.getWorldPosition(new THREE.Vector3()), dir, false);
                        proj.damage = 12;
                        proj.speed = 250;
                        projectiles.push(proj);
                    }, i * 30);
                }
            }

            tentacleSweep(projectiles) {
                // ÂÖ®Ëß¶Êâã„Åã„Çâ‰∏ÄÊñâÊîªÊíÉ
                this.tentacles.forEach((tentacle, i) => {
                    setTimeout(() => {
                        if (!this.alive) return;
                        const worldPos = new THREE.Vector3();
                        tentacle.getWorldPosition(worldPos);
                        
                        // ÂêÑËß¶Êâã„Åã„Çâ3Áô∫
                        for (let j = 0; j < 3; j++) {
                            const dir = this.player.position.clone().sub(worldPos).normalize();
                            dir.x += (j - 1) * 0.1;
                            const proj = new Projectile(this.scene, worldPos.clone(), dir, false);
                            proj.damage = 10;
                            proj.speed = 100;
                            projectiles.push(proj);
                        }
                    }, i * 100);
                });
            }

            doomNova(projectiles) {
                // ÂÖ®Êñπ‰ΩçÁ†¥ÊªÖÊîªÊíÉ
                for (let i = 0; i < 36; i++) {
                    const angle = (i / 36) * Math.PI * 2;
                    for (let j = -1; j <= 1; j++) {
                        const dir = new THREE.Vector3(
                            Math.cos(angle),
                            j * 0.3,
                            Math.sin(angle) - 0.5
                        ).normalize();
                        const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                        proj.damage = 20;
                        proj.speed = 80;
                        projectiles.push(proj);
                    }
                }
            }

            flashDamage() {
                if (this.body) {
                    this.body.material.emissiveIntensity = 1.5;
                    setTimeout(() => {
                        if (this.body) this.body.material.emissiveIntensity = 0.7;
                    }, 100);
                }
            }
        }

        // ============================================
        // Boss Alien Classes (Wave 1-5)
        // ============================================
        
        // Wave 1 Boss: Ê∑±Ê∑µ„ÅÆÁúºÈ≠î - Â∑®Â§ß„Å™ËÇâÂ°ä„Å´ÁÑ°Êï∞„ÅÆÁõÆ„Å®Ëß¶Êâã„ÇíÊåÅ„Å§ÊÄ™Áâ©
        class BossAlien1 {
            constructor(scene, playerRef) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'boss';
                this.waveNumber = 1;
                
                this.maxHealth = 21600;
                this.health = this.maxHealth;
                this.score = 5000;
                
                this.position = new THREE.Vector3(0, 0, -80);
                this.velocity = new THREE.Vector3();
                this.targetPos = new THREE.Vector3(0, 0, -60);
                
                this.attackTimer = 0;
                this.specialAttackTimer = 0;
                this.moveTimer = 0;
                this.time = 0;
                this.movePhase = 0;
                
                this.createMesh();
            }
            
            createMesh() {
                this.group = new THREE.Group();
                
                // „É°„Ç§„É≥ËÇâÂ°äÔºà‰∏çË¶èÂâá„Å™ÂΩ¢Áä∂Ôºâ
                const bodyGeo = new THREE.IcosahedronGeometry(14, 2);
                // È†ÇÁÇπ„Çí„É©„É≥„ÉÄ„É†„Å´Â§âÂΩ¢„Åï„Åõ„Å¶ÊúâÊ©üÁöÑ„Å´
                const positions = bodyGeo.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const noise = 0.7 + Math.random() * 0.6;
                    positions[i] *= noise;
                    positions[i + 1] *= noise;
                    positions[i + 2] *= noise;
                }
                bodyGeo.computeVertexNormals();
                
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x662244,
                    emissive: 0x331122,
                    emissiveIntensity: 0.5,
                    metalness: 0.3,
                    roughness: 0.7
                });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.group.add(this.body);
                
                // Ë°®Èù¢„ÅÆËÜøÁñ±/ËÖ´Áòç
                this.tumors = [];
                for (let i = 0; i < 15; i++) {
                    const size = 1.5 + Math.random() * 2.5;
                    const tumorGeo = new THREE.SphereGeometry(size, 12, 12);
                    const tumorMat = new THREE.MeshStandardMaterial({
                        color: 0x993366,
                        emissive: 0x551133,
                        emissiveIntensity: 0.6
                    });
                    const tumor = new THREE.Mesh(tumorGeo, tumorMat);
                    // Ë°®Èù¢„Å´„É©„É≥„ÉÄ„É†ÈÖçÁΩÆ
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = 12 + Math.random() * 3;
                    tumor.position.set(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                    tumor.userData.basePos = tumor.position.clone();
                    this.tumors.push(tumor);
                    this.group.add(tumor);
                }
                
                // ‰∏≠Â§Æ„ÅÆÂ∑®Â§ß„Å™ÁõÆÔºà‰∏ªÁúºÔºâ
                const mainEyeGeo = new THREE.SphereGeometry(7, 32, 32);
                const mainEyeMat = new THREE.MeshStandardMaterial({
                    color: 0xffeecc,
                    emissive: 0xaa6633,
                    emissiveIntensity: 0.4
                });
                this.mainEye = new THREE.Mesh(mainEyeGeo, mainEyeMat);
                this.mainEye.position.z = 10;
                this.group.add(this.mainEye);
                
                // Ë°ÄÁÆ°Ê®°Êßò„ÅÆ„É™„É≥„Ç∞
                const irisGeo = new THREE.TorusGeometry(5, 0.8, 16, 32);
                const irisMat = new THREE.MeshBasicMaterial({ color: 0xaa0000 });
                this.mainIris = new THREE.Mesh(irisGeo, irisMat);
                this.mainIris.position.z = 12;
                this.group.add(this.mainIris);
                
                // Áû≥Â≠îÔºàÁ∏¶Èï∑Ôºâ
                const pupilGeo = new THREE.SphereGeometry(3, 16, 16);
                pupilGeo.scale(0.5, 1, 0.3);
                const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                this.mainPupil = new THREE.Mesh(pupilGeo, pupilMat);
                this.mainPupil.position.z = 14;
                this.group.add(this.mainPupil);
                
                // ÂâØÁúºÔºà‰Ωì‰∏≠„Å´Êï£„Çâ„Å∞„ÇãÂ∞è„Åï„Å™ÁõÆÔºâ
                this.subEyes = [];
                for (let i = 0; i < 12; i++) {
                    const eyeGroup = new THREE.Group();
                    const eyeSize = 1.5 + Math.random() * 1.5;
                    
                    const eyeballGeo = new THREE.SphereGeometry(eyeSize, 16, 16);
                    const eyeballMat = new THREE.MeshStandardMaterial({
                        color: 0xffddaa,
                        emissive: 0x663311,
                        emissiveIntensity: 0.5
                    });
                    const eyeball = new THREE.Mesh(eyeballGeo, eyeballMat);
                    eyeGroup.add(eyeball);
                    
                    const pupilGeo2 = new THREE.SphereGeometry(eyeSize * 0.4, 8, 8);
                    const pupilMat2 = new THREE.MeshBasicMaterial({ color: 0x110000 });
                    const pupil = new THREE.Mesh(pupilGeo2, pupilMat2);
                    pupil.position.z = eyeSize * 0.8;
                    eyeGroup.add(pupil);
                    
                    // „É©„É≥„ÉÄ„É†„Å™‰ΩçÁΩÆ
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI * 0.8 + 0.1;
                    const r = 13;
                    eyeGroup.position.set(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                    eyeGroup.lookAt(eyeGroup.position.clone().multiplyScalar(2));
                    eyeGroup.userData.basePos = eyeGroup.position.clone();
                    
                    this.subEyes.push(eyeGroup);
                    this.group.add(eyeGroup);
                }
                
                // Ëß¶ÊâãÔºà16Êú¨„ÅÆÈï∑„ÅÑÊúâÊ©üÁöÑ„Å™Ëß¶ÊâãÔºâ
                this.tentacles = [];
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const tentacle = this.createOrganicTentacle(20 + Math.random() * 10);
                    const startR = 12;
                    tentacle.position.x = Math.cos(angle) * startR;
                    tentacle.position.y = Math.sin(angle) * startR;
                    tentacle.userData = { angle: angle, index: i, segments: tentacle.children };
                    this.tentacles.push(tentacle);
                    this.group.add(tentacle);
                }
                
                // ËÑàÊâì„Å§Ë°ÄÁÆ°
                this.veins = [];
                for (let i = 0; i < 8; i++) {
                    const veinGeo = new THREE.TubeGeometry(
                        new THREE.CatmullRomCurve3([
                            new THREE.Vector3(0, 0, 0),
                            new THREE.Vector3(Math.random() * 10 - 5, Math.random() * 10 - 5, 8),
                            new THREE.Vector3(Math.random() * 15 - 7.5, Math.random() * 15 - 7.5, 15)
                        ]),
                        20, 0.3, 8, false
                    );
                    const veinMat = new THREE.MeshBasicMaterial({
                        color: 0x880022,
                        transparent: true,
                        opacity: 0.7
                    });
                    const vein = new THREE.Mesh(veinGeo, veinMat);
                    this.veins.push(vein);
                    this.group.add(vein);
                }
                
                // ‰∏çÊ∞óÂë≥„Å™„Ç™„Éº„É©
                const auraGeo = new THREE.SphereGeometry(25, 32, 32);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: 0x440033,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                });
                this.aura = new THREE.Mesh(auraGeo, auraMat);
                this.group.add(this.aura);
                
                this.group.position.copy(this.position);
                this.scene.add(this.group);
            }
            
            createOrganicTentacle(length) {
                const group = new THREE.Group();
                const segmentCount = Math.floor(length / 2);
                
                for (let i = 0; i < segmentCount; i++) {
                    const t = i / segmentCount;
                    const size = 2 * (1 - t * 0.7);
                    const geo = new THREE.SphereGeometry(size, 8, 8);
                    geo.scale(1, 1, 1.5);
                    
                    const hue = 0.85 + t * 0.1;
                    const mat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(hue, 0.6, 0.3),
                        emissive: new THREE.Color().setHSL(hue, 0.7, 0.15),
                        emissiveIntensity: 0.4 + t * 0.4
                    });
                    const seg = new THREE.Mesh(geo, mat);
                    seg.userData.index = i;
                    seg.userData.baseY = -i * 2.5;
                    group.add(seg);
                }
                
                // ÂÖàÁ´Ø„ÅÆÂÖâ„ÇãÊ£ò
                const tipGeo = new THREE.ConeGeometry(0.8, 3, 6);
                const tipMat = new THREE.MeshBasicMaterial({
                    color: 0xff0066,
                    transparent: true,
                    opacity: 0.9
                });
                const tip = new THREE.Mesh(tipGeo, tipMat);
                tip.rotation.x = Math.PI;
                tip.userData.index = segmentCount;
                tip.userData.baseY = -segmentCount * 2.5;
                group.add(tip);
                
                return group;
            }
            
            getCollisionRadius() { return 18; }
            
            takeDamage(amount, fromBomb = false) {
                const actualDamage = fromBomb ? Math.min(amount, 500) : amount;
                this.health -= actualDamage;
                this.flashDamage();
                
                if (this.health <= 0) {
                    this.health = 0;
                    this.alive = false;
                    return true;
                }
                return false;
            }
            
            flashDamage() {
                if (this.body) {
                    this.body.material.emissiveIntensity = 2.0;
                    setTimeout(() => {
                        if (this.body) this.body.material.emissiveIntensity = 0.5;
                    }, 100);
                }
            }
            
            update(deltaTime, projectiles) {
                if (!this.alive) return;
                
                this.time += deltaTime;
                this.moveTimer += deltaTime;
                this.attackTimer += deltaTime;
                this.specialAttackTimer += deltaTime;
                
                // 3DÁ©∫Èñì„ÇíÁ∏¶Ê®™ÁÑ°Â∞Ω„Å´Âãï„Åè
                if (this.moveTimer > 2.5) {
                    this.movePhase = (this.movePhase + 1) % 6;
                    switch(this.movePhase) {
                        case 0: // Âè≥‰∏ä„Å∏
                            this.targetPos.set(25, 15, -50);
                            this.moveSpeed = 1.5;
                            break;
                        case 1: // Â∑¶‰∏ã„Å∏
                            this.targetPos.set(-25, -10, -70);
                            this.moveSpeed = 1.5;
                            break;
                        case 2: // ‰∏≠Â§ÆÂâçÊñπ„Å∏ÊÄ•Êé•Ëøë
                            this.targetPos.set(0, 0, -35);
                            this.moveSpeed = 2.5;
                            break;
                        case 3: // ÂæåÊñπ„Å∏ÈÄÄÈÅø„Åó„Å™„Åå„ÇâÊ®™ÁßªÂãï
                            this.targetPos.set((Math.random() - 0.5) * 50, (Math.random() - 0.5) * 20, -80);
                            this.moveSpeed = 1.5;
                            break;
                        case 4: // ÈÅ†„Åè„Å∏Á¥†Êó©„ÅèÈÄÉ„Åí„Çã
                            this.targetPos.set((Math.random() - 0.5) * 40, (Math.random() - 0.5) * 30, -120);
                            this.moveSpeed = 4.0;
                            break;
                        case 5: // ÈÄÉ„Åí„ÅüÂæå„Å´Êàª„Å£„Å¶„Åè„Çã
                            this.targetPos.set((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 15, -55);
                            this.moveSpeed = 2.0;
                            break;
                    }
                    this.moveTimer = 0;
                }
                
                // „Çπ„É†„Éº„Ç∫„Å´ÁßªÂãïÔºàÈÄüÂ∫¶ÂèØÂ§âÔºâ
                this.position.lerp(this.targetPos, deltaTime * (this.moveSpeed || 1.5));
                
                // ‰ΩìÂÖ®‰Ωì„ÅÆËÑàÂãï
                const bodyPulse = 1 + Math.sin(this.time * 2) * 0.08;
                this.body.scale.setScalar(bodyPulse);
                
                // ËÖ´Áòç„ÅÆËÑàÂãï
                this.tumors.forEach((tumor, i) => {
                    const pulse = 1 + Math.sin(this.time * 3 + i) * 0.2;
                    tumor.scale.setScalar(pulse);
                });
                
                // ‰∏ªÁúº„Åå„Éó„É¨„Ç§„É§„Éº„ÇíËøΩË∑°
                if (this.player) {
                    const dir = new THREE.Vector3().subVectors(this.player.position, this.position).normalize();
                    this.mainPupil.position.x = dir.x * 2;
                    this.mainPupil.position.y = dir.y * 2;
                    
                    // ÂâØÁúº„ÇÇ„Éó„É¨„Ç§„É§„Éº„ÇíË¶ã„Çã
                    this.subEyes.forEach(eye => {
                        const localDir = dir.clone();
                        eye.children[1].position.x = localDir.x * 0.5;
                        eye.children[1].position.y = localDir.y * 0.5;
                    });
                }
                
                // Ëß¶Êâã„ÅÆ„É™„Ç¢„É´„Å™„ÅÜ„Å≠„Çä
                this.tentacles.forEach((tentacle, ti) => {
                    const baseAngle = tentacle.userData.angle;
                    tentacle.children.forEach((seg, si) => {
                        const wave1 = Math.sin(this.time * 3 + ti * 0.5 + si * 0.4) * (si * 0.15);
                        const wave2 = Math.cos(this.time * 2 + ti * 0.3 + si * 0.3) * (si * 0.1);
                        seg.position.x = wave1;
                        seg.position.z = wave2;
                        seg.position.y = seg.userData.baseY + Math.sin(this.time * 4 + si * 0.2) * 0.5;
                    });
                    // Ëß¶ÊâãÂÖ®‰Ωì„ÇÇÂãï„Åè
                    tentacle.rotation.z = baseAngle + Math.sin(this.time + ti) * 0.3;
                });
                
                // Ë°ÄÁÆ°„ÅÆËÑàÂãï
                this.veins.forEach((vein, i) => {
                    const pulse = 1 + Math.sin(this.time * 5 + i * 2) * 0.3;
                    vein.scale.x = pulse;
                    vein.scale.y = pulse;
                });
                
                // „Ç™„Éº„É©„ÅÆËÑàÂãï
                const auraPulse = 1 + Math.sin(this.time * 1.5) * 0.1;
                this.aura.scale.setScalar(auraPulse);
                
                // ÈÄöÂ∏∏ÊîªÊíÉ
                if (this.attackTimer > 1.8) {
                    this.attack(projectiles);
                    this.attackTimer = 0;
                }
                
                // ÁâπÊÆäÊîªÊíÉÔºöËß¶ÊâãËñô„ÅéÊâï„ÅÑ
                if (this.specialAttackTimer > 6) {
                    this.tentacleSwipe(projectiles);
                    this.specialAttackTimer = 0;
                }
                
                this.group.position.copy(this.position);
                this.group.rotation.y = Math.sin(this.time * 0.5) * 0.2;
                this.group.rotation.x = Math.cos(this.time * 0.3) * 0.1;
            }
            
            attack(projectiles) {
                // ‰∏ªÁúº„Åã„Çâ„Éì„Éº„É†Âºæ
                const eyePos = this.position.clone();
                eyePos.z += 14;
                
                if (this.player) {
                    const dir = new THREE.Vector3().subVectors(this.player.position, eyePos).normalize();
                    
                    // 3Áô∫„ÅÆËøΩÂ∞æÂºæ
                    for (let i = -1; i <= 1; i++) {
                        const spreadDir = dir.clone();
                        spreadDir.x += i * 0.15;
                        spreadDir.normalize();
                        
                        const proj = new Projectile(this.scene, eyePos.clone(), spreadDir, false);
                        proj.damage = 15;
                        proj.speed = 45;
                        projectiles.push(proj);
                    }
                }
                
                // ÂâØÁúº„Åã„Çâ„ÇÇÊï£Áô∫ÁöÑ„Å´Áô∫Â∞Ñ
                if (Math.random() < 0.5) {
                    const randomEye = this.subEyes[Math.floor(Math.random() * this.subEyes.length)];
                    const eyeWorldPos = new THREE.Vector3();
                    randomEye.getWorldPosition(eyeWorldPos);
                    
                    if (this.player) {
                        const dir = new THREE.Vector3().subVectors(this.player.position, eyeWorldPos).normalize();
                        const proj = new Projectile(this.scene, eyeWorldPos, dir, false);
                        proj.damage = 10;
                        proj.speed = 50;
                        projectiles.push(proj);
                    }
                }
            }
            
            // ÁâπÊÆäÊîªÊíÉÔºöËß¶ÊâãËñô„ÅéÊâï„ÅÑ
            tentacleSwipe(projectiles) {
                // ÂÖ®Ëß¶Êâã„Åã„ÇâÊîæÂ∞ÑÁä∂„Å´Âºæ„ÇíÁô∫Â∞Ñ
                this.tentacles.forEach((tentacle, i) => {
                    const angle = tentacle.userData.angle;
                    const tipPos = this.position.clone();
                    tipPos.x += Math.cos(angle) * 25;
                    tipPos.y += Math.sin(angle) * 25;
                    
                    // ÂêÑËß¶ÊâãÂÖàÁ´Ø„Åã„Çâ3Áô∫
                    for (let j = -1; j <= 1; j++) {
                        const dir = new THREE.Vector3(
                            Math.cos(angle + j * 0.2),
                            Math.sin(angle + j * 0.2),
                            0.5
                        ).normalize();
                        
                        const proj = new Projectile(this.scene, tipPos.clone(), dir, false);
                        proj.damage = 12;
                        proj.speed = 35;
                        projectiles.push(proj);
                    }
                });
            }
            
            destroy() {
                if (this.group) {
                    this.scene.remove(this.group);
                }
                this.alive = false;
            }
        }
        
        // Wave 2 Boss: Ê∑±Ê∑µ„ÅÆÂèåÈ†≠ËõáÁ´ú - Â∑®Â§ß„Å™‰∫å„Å§„ÅÆÈ†≠„ÇíÊåÅ„Å§ËõáÈæç
        class BossAlien2 {
            constructor(scene, playerRef) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'boss';
                this.waveNumber = 2;
                
                this.maxHealth = 32400;
                this.health = this.maxHealth;
                this.score = 8000;
                
                this.position = new THREE.Vector3(0, 0, -80);
                this.velocity = new THREE.Vector3();
                this.targetPos = new THREE.Vector3();
                
                this.attackTimer = 0;
                this.specialAttackTimer = 0;
                this.moveTimer = 0;
                this.time = 0;
                this.movePattern = 0;
                this.chargeMode = false;
                
                this.createMesh();
            }
            
            createMesh() {
                this.group = new THREE.Group();
                
                // Â∑®Â§ß„Å™ËÉ¥‰ΩìÔºà30„Çª„Ç∞„É°„É≥„ÉàÔºâ
                this.bodySegments = [];
                for (let i = 0; i < 30; i++) {
                    const t = i / 30;
                    const size = 5 - Math.abs(t - 0.3) * 8;
                    const clampedSize = Math.max(2, size);
                    
                    const segGeo = new THREE.SphereGeometry(clampedSize, 12, 12);
                    segGeo.scale(1, 1, 1.3);
                    
                    const hue = 0.35 + t * 0.1;
                    const segMat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(hue, 0.7, 0.25),
                        emissive: new THREE.Color().setHSL(hue, 0.8, 0.1),
                        emissiveIntensity: 0.5,
                        metalness: 0.4,
                        roughness: 0.6
                    });
                    const seg = new THREE.Mesh(segGeo, segMat);
                    seg.userData.index = i;
                    seg.userData.baseSize = clampedSize;
                    this.bodySegments.push(seg);
                    this.group.add(seg);
                    
                    // ËÉå„Å≥„ÇåÔºà‰∫§‰∫í„Å´Ôºâ
                    if (i > 5 && i < 25 && i % 2 === 0) {
                        const finGeo = new THREE.ConeGeometry(1, 4 + Math.sin(i * 0.3) * 2, 4);
                        const finMat = new THREE.MeshStandardMaterial({
                            color: 0x55dd99,
                            emissive: 0x228844,
                            emissiveIntensity: 0.4,
                            transparent: true,
                            opacity: 0.8
                        });
                        const fin = new THREE.Mesh(finGeo, finMat);
                        fin.position.y = clampedSize + 2;
                        seg.add(fin);
                    }
                }
                
                // 2„Å§„ÅÆÊÅê„Çç„Åó„ÅÑÈæçÈ†≠
                this.heads = [];
                this.necks = [];
                
                for (let side = -1; side <= 1; side += 2) {
                    // È¶ñÔºà10„Çª„Ç∞„É°„É≥„ÉàÔºâ
                    const neckGroup = new THREE.Group();
                    const neckSegs = [];
                    for (let n = 0; n < 10; n++) {
                        const neckSize = 4 - n * 0.2;
                        const neckGeo = new THREE.SphereGeometry(neckSize, 10, 10);
                        neckGeo.scale(1, 1, 1.2);
                        const neckMat = new THREE.MeshStandardMaterial({
                            color: 0x33aa77,
                            emissive: 0x116644,
                            emissiveIntensity: 0.4
                        });
                        const neckSeg = new THREE.Mesh(neckGeo, neckMat);
                        neckSeg.userData.index = n;
                        neckSegs.push(neckSeg);
                        neckGroup.add(neckSeg);
                    }
                    neckGroup.userData.segments = neckSegs;
                    neckGroup.userData.side = side;
                    this.necks.push(neckGroup);
                    this.group.add(neckGroup);
                    
                    // È†≠ÈÉ®
                    const headGroup = new THREE.Group();
                    
                    // È†≠ËìãÈ™®„ÅÆ„Çà„ÅÜ„Å™ÂΩ¢Áä∂
                    const skullGeo = new THREE.SphereGeometry(6, 16, 16);
                    skullGeo.scale(1.2, 0.8, 1.5);
                    const skullMat = new THREE.MeshStandardMaterial({
                        color: 0x228866,
                        emissive: 0x114433,
                        emissiveIntensity: 0.5,
                        metalness: 0.3,
                        roughness: 0.5
                    });
                    const skull = new THREE.Mesh(skullGeo, skullMat);
                    headGroup.add(skull);
                    
                    // È°é
                    const jawGeo = new THREE.SphereGeometry(5, 12, 12);
                    jawGeo.scale(1, 0.5, 1.3);
                    const jaw = new THREE.Mesh(jawGeo, skullMat.clone());
                    jaw.position.y = -3;
                    jaw.position.z = 2;
                    jaw.userData.isJaw = true;
                    headGroup.add(jaw);
                    
                    // ËßíÔºà4Êú¨Ôºâ
                    for (let h = 0; h < 4; h++) {
                        const hornGeo = new THREE.ConeGeometry(0.8, 10 - h * 2, 6);
                        const hornMat = new THREE.MeshStandardMaterial({
                            color: 0xddcc88,
                            emissive: 0x887744,
                            emissiveIntensity: 0.4
                        });
                        const horn = new THREE.Mesh(hornGeo, hornMat);
                        horn.position.x = (h % 2 === 0 ? -1 : 1) * (2 + h);
                        horn.position.y = 4;
                        horn.position.z = -2 - h;
                        horn.rotation.x = -0.3 - h * 0.1;
                        horn.rotation.z = (h % 2 === 0 ? 1 : -1) * 0.2;
                        headGroup.add(horn);
                    }
                    
                    // ÁõÆÔºà6„Å§„ÅÆÈÇ™ÊÇ™„Å™ÁõÆÔºâ
                    for (let e = 0; e < 6; e++) {
                        const row = Math.floor(e / 3);
                        const col = e % 3;
                        const eyeSize = col === 1 ? 1.8 : 1.2;
                        
                        const eyeGeo = new THREE.SphereGeometry(eyeSize, 12, 12);
                        const eyeMat = new THREE.MeshStandardMaterial({
                            color: 0xff3300,
                            emissive: 0xff2200,
                            emissiveIntensity: 1.5
                        });
                        const eye = new THREE.Mesh(eyeGeo, eyeMat);
                        eye.position.x = (col - 1) * 2.5;
                        eye.position.y = 1.5 - row * 2;
                        eye.position.z = 5;
                        
                        // Áû≥
                        const pupilGeo = new THREE.SphereGeometry(eyeSize * 0.4, 8, 8);
                        const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                        const pupil = new THREE.Mesh(pupilGeo, pupilMat);
                        pupil.position.z = eyeSize * 0.7;
                        eye.add(pupil);
                        
                        headGroup.add(eye);
                    }
                    
                    // ÁâôÔºà‰∏ä‰∏ã8Êú¨„Åö„Å§Ôºâ
                    for (let f = 0; f < 8; f++) {
                        const isUpper = f < 4;
                        const idx = f % 4;
                        const fangGeo = new THREE.ConeGeometry(0.4, 3 + (idx === 1 || idx === 2 ? 2 : 0), 6);
                        const fangMat = new THREE.MeshStandardMaterial({
                            color: 0xffffee,
                            emissive: 0xaaaa88,
                            emissiveIntensity: 0.3
                        });
                        const fang = new THREE.Mesh(fangGeo, fangMat);
                        fang.position.x = (idx - 1.5) * 1.8;
                        fang.position.y = isUpper ? -2 : -4;
                        fang.position.z = 6;
                        fang.rotation.x = isUpper ? Math.PI : 0;
                        headGroup.add(fang);
                    }
                    
                    headGroup.userData.side = side;
                    this.heads.push(headGroup);
                    this.group.add(headGroup);
                }
                
                // Â∞æ„ÅÆÂÖàÁ´ØÔºàÊØíÈáùÔºâ
                const tailGroup = new THREE.Group();
                for (let t = 0; t < 5; t++) {
                    const stingerGeo = new THREE.ConeGeometry(1 - t * 0.15, 6 - t, 6);
                    const stingerMat = new THREE.MeshStandardMaterial({
                        color: 0x88ff88,
                        emissive: 0x44aa44,
                        emissiveIntensity: 0.6
                    });
                    const stinger = new THREE.Mesh(stingerGeo, stingerMat);
                    stinger.position.z = -t * 3;
                    stinger.rotation.x = Math.PI / 2;
                    tailGroup.add(stinger);
                }
                this.tail = tailGroup;
                this.group.add(tailGroup);
                
                // „Ç®„Éç„É´„ÇÆ„Éº„Ç™„Éº„ÉñÔºà‰∏°È†≠„ÅÆÈñìÔºâ
                const orbGeo = new THREE.SphereGeometry(5, 32, 32);
                const orbMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffaa,
                    transparent: true,
                    opacity: 0.6
                });
                this.energyOrb = new THREE.Mesh(orbGeo, orbMat);
                this.group.add(this.energyOrb);
                
                this.group.position.copy(this.position);
                this.scene.add(this.group);
            }
            
            getCollisionRadius() { return 22; }
            
            takeDamage(amount, fromBomb = false) {
                const actualDamage = fromBomb ? Math.min(amount, 500) : amount;
                this.health -= actualDamage;
                this.flashDamage();
                
                if (this.health <= 0) {
                    this.health = 0;
                    this.alive = false;
                    return true;
                }
                return false;
            }
            
            flashDamage() {
                this.bodySegments.forEach(seg => {
                    seg.material.emissiveIntensity = 1.5;
                    setTimeout(() => {
                        seg.material.emissiveIntensity = 0.5;
                    }, 100);
                });
            }
            
            update(deltaTime, projectiles) {
                if (!this.alive) return;
                
                this.time += deltaTime;
                this.moveTimer += deltaTime;
                this.attackTimer += deltaTime;
                this.specialAttackTimer += deltaTime;
                
                // Ë§áÈõë„Å™3DÁßªÂãï„Éë„Çø„Éº„É≥
                if (this.moveTimer > 3) {
                    this.movePattern = (this.movePattern + 1) % 7;
                    this.moveTimer = 0;
                }
                
                // ËõáË°å„Åó„Å™„Åå„Çâ3DÁ©∫Èñì„ÇíÁßªÂãï
                const patternTime = this.time * 0.8;
                switch(this.movePattern) {
                    case 0: // Â§ß„Åç„Å™8„ÅÆÂ≠ó
                        this.position.x = Math.sin(patternTime) * 35;
                        this.position.y = Math.sin(patternTime * 2) * 15;
                        this.position.z = -60 + Math.cos(patternTime) * 20;
                        break;
                    case 1: // Ëû∫ÊóãÈôç‰∏ã
                        this.position.x = Math.cos(patternTime * 2) * 25;
                        this.position.y = Math.sin(patternTime * 2) * 25;
                        this.position.z = -50 + Math.sin(patternTime) * 15;
                        break;
                    case 2: // „Éó„É¨„Ç§„É§„Éº„Å´Á™ÅÈÄ≤
                        if (this.player) {
                            const targetZ = Math.max(-40, this.player.position.z - 30);
                            this.targetPos.set(this.player.position.x, this.player.position.y, targetZ);
                            this.position.lerp(this.targetPos, deltaTime * 2);
                        }
                        break;
                    case 3: // ‰∏ä‰∏ã„Å´Â§ß„Åç„ÅèÊè∫„Çå„Å™„Åå„ÇâÊ®™ÁßªÂãï
                        this.position.x = Math.sin(patternTime * 1.5) * 40;
                        this.position.y = Math.sin(patternTime * 3) * 20;
                        this.position.z = -55;
                        break;
                    case 4: // ÂõûÈÅø„Åó„Å™„Åå„ÇâÂæåÈÄÄ
                        this.position.x = Math.sin(patternTime * 2) * 30;
                        this.position.y = Math.cos(patternTime * 1.5) * 10;
                        this.position.z = -80 + Math.sin(patternTime * 0.5) * 10;
                        break;
                    case 5: // ÈÅ†„Åè„Å∏Á¥†Êó©„ÅèÈÄÉ„Åí„Çã
                        this.targetPos.set(
                            (Math.random() - 0.5) * 50,
                            (Math.random() - 0.5) * 25,
                            -130
                        );
                        this.position.lerp(this.targetPos, deltaTime * 4.5);
                        break;
                    case 6: // ÈÄÉ„Åí„ÅüÂæå„Å´È´òÈÄü„ÅßÊàª„Å£„Å¶„Åè„Çã
                        this.targetPos.set(
                            (Math.random() - 0.5) * 35,
                            (Math.random() - 0.5) * 15,
                            -50
                        );
                        this.position.lerp(this.targetPos, deltaTime * 3.0);
                        break;
                }
                
                // ËÉ¥‰Ωì„ÅÆ„É™„Ç¢„É´„Å™ËõáË°å
                this.bodySegments.forEach((seg, i) => {
                    const t = i / this.bodySegments.length;
                    const delay = i * 0.15;
                    seg.position.x = Math.sin(this.time * 2 - delay) * (3 + t * 5);
                    seg.position.y = Math.cos(this.time * 1.5 - delay) * (2 + t * 3);
                    seg.position.z = -i * 2.5;
                    
                    // ÂêÑ„Çª„Ç∞„É°„É≥„Éà„ÅÆÂõûËª¢
                    seg.rotation.z = Math.sin(this.time * 2 - delay) * 0.2;
                });
                
                // È¶ñ„ÅÆ„ÅÜ„Å≠„Çä
                this.necks.forEach((neck, ni) => {
                    const side = neck.userData.side;
                    neck.userData.segments.forEach((seg, i) => {
                        const delay = i * 0.2;
                        seg.position.x = side * (8 + i * 2) + Math.sin(this.time * 3 - delay) * 2;
                        seg.position.y = Math.cos(this.time * 2 - delay) * 3;
                        seg.position.z = i * 3 + 5;
                    });
                });
                
                // È†≠„ÅÆÂãï„Åç„Å®„Éó„É¨„Ç§„É§„ÉºËøΩË∑°
                this.heads.forEach((head, i) => {
                    const side = head.userData.side;
                    head.position.x = side * 20 + Math.sin(this.time * 2 + i * Math.PI) * 5;
                    head.position.y = Math.cos(this.time * 1.5) * 5;
                    head.position.z = 20 + Math.sin(this.time + i) * 5;
                    
                    // „Éó„É¨„Ç§„É§„Éº„ÇíË¶ã„Çã
                    if (this.player) {
                        const dir = new THREE.Vector3().subVectors(this.player.position, head.position);
                        head.rotation.y = Math.atan2(dir.x, dir.z) * 0.3;
                        head.rotation.x = Math.atan2(dir.y, dir.z) * 0.2;
                    }
                    
                    // È°é„ÅÆÈñãÈñâ
                    head.children.forEach(child => {
                        if (child.userData && child.userData.isJaw) {
                            child.rotation.x = Math.sin(this.time * 4) * 0.2;
                        }
                    });
                });
                
                // Â∞æ„ÅÆÂãï„Åç
                this.tail.position.z = -this.bodySegments.length * 2.5 - 5;
                this.tail.rotation.y = Math.sin(this.time * 3) * 0.5;
                this.tail.rotation.x = Math.cos(this.time * 2) * 0.3;
                
                // „Ç®„Éç„É´„ÇÆ„Éº„Ç™„Éº„Éñ
                const orbPulse = 1 + Math.sin(this.time * 5) * 0.3;
                this.energyOrb.scale.setScalar(orbPulse);
                this.energyOrb.position.z = 15;
                
                // ÈÄöÂ∏∏ÊîªÊíÉ
                if (this.attackTimer > 1.5) {
                    this.attack(projectiles);
                    this.attackTimer = 0;
                }
                
                // ÁâπÊÆäÊîªÊíÉÔºöÊØíÊ∂≤Âô¥Â∞Ñ
                if (this.specialAttackTimer > 5) {
                    this.poisonBreath(projectiles);
                    this.specialAttackTimer = 0;
                }
                
                this.group.position.copy(this.position);
            }
            
            attack(projectiles) {
                // ‰∏°È†≠„Åã„ÇâÁÇéÂºæ
                this.heads.forEach((head, idx) => {
                    const headWorldPos = new THREE.Vector3();
                    head.getWorldPosition(headWorldPos);
                    headWorldPos.z += 8;
                    
                    if (this.player) {
                        const dir = new THREE.Vector3()
                            .subVectors(this.player.position, headWorldPos)
                            .normalize();
                        
                        for (let i = -2; i <= 2; i++) {
                            const spreadDir = dir.clone();
                            spreadDir.x += i * 0.1;
                            spreadDir.y += Math.sin(this.time + i) * 0.05;
                            spreadDir.normalize();
                            
                            const proj = new Projectile(this.scene, headWorldPos.clone(), spreadDir, false);
                            proj.damage = 12;
                            proj.speed = 50;
                            projectiles.push(proj);
                        }
                    }
                });
            }
            
            // ÁâπÊÆäÊîªÊíÉÔºöÊØíÊ∂≤Âô¥Â∞ÑÔºàÂ∞æ„Åã„ÇâÔºâ
            poisonBreath(projectiles) {
                const tailPos = this.position.clone();
                tailPos.z -= this.bodySegments.length * 2.5 + 10;
                
                // ÊîæÂ∞ÑÁä∂„Å´ÊØíÂºæ„ÇíÁô∫Â∞Ñ
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const dir = new THREE.Vector3(
                        Math.cos(angle) * 0.5,
                        Math.sin(angle) * 0.5,
                        1
                    ).normalize();
                    
                    const proj = new Projectile(this.scene, tailPos.clone(), dir, false);
                    proj.damage = 15;
                    proj.speed = 35;
                    projectiles.push(proj);
                }
            }
            
            destroy() {
                if (this.group) {
                    this.scene.remove(this.group);
                }
                this.alive = false;
            }
        }
        
        // Wave 3 Boss: Ê∑±Ê∑µ„ÅÆ„ÇØ„É©„Éº„Ç±„É≥ - Â∑®Â§ß„Å™Ëß¶Êâã„ÇíÊåÅ„Å§Êµ∑Â∫ï„ÅÆÊÄ™Áâ©
        class BossAlien3 {
            constructor(scene, playerRef) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'boss';
                this.waveNumber = 3;
                
                this.maxHealth = 32400;
                this.health = this.maxHealth;
                this.score = 12000;
                
                this.position = new THREE.Vector3(0, 0, -80);
                this.targetPos = new THREE.Vector3();
                
                this.attackTimer = 0;
                this.tentacleAttackTimer = 0;
                this.moveTimer = 0;
                this.time = 0;
                this.movePhase = 0;
                this.isGrabbing = false;
                
                this.createMesh();
            }
            
            createMesh() {
                this.group = new THREE.Group();
                
                // Â∑®Â§ß„Å™ËÉ¥‰ΩìÔºà„Ç§„Ç´/„Çø„Ç≥„ÅÆ„Çà„ÅÜ„Å™ÂΩ¢Áä∂Ôºâ
                const bodyGeo = new THREE.SphereGeometry(12, 32, 32);
                bodyGeo.scale(1, 0.8, 1.5);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x334466,
                    emissive: 0x112233,
                    emissiveIntensity: 0.5,
                    metalness: 0.2,
                    roughness: 0.7
                });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.group.add(this.body);
                
                // Â§ñÂ•óËÜúÔºà„Éû„É≥„Éà„É´Ôºâ
                const mantleGeo = new THREE.ConeGeometry(14, 25, 8);
                const mantleMat = new THREE.MeshStandardMaterial({
                    color: 0x445577,
                    emissive: 0x223344,
                    emissiveIntensity: 0.4,
                    transparent: true,
                    opacity: 0.9
                });
                this.mantle = new THREE.Mesh(mantleGeo, mantleMat);
                this.mantle.position.z = -15;
                this.mantle.rotation.x = Math.PI / 2;
                this.group.add(this.mantle);
                
                // Â∑®Â§ß„Å™ÁõÆÔºà2„Å§Ôºâ
                this.eyes = [];
                for (let side = -1; side <= 1; side += 2) {
                    const eyeGroup = new THREE.Group();
                    
                    const eyeballGeo = new THREE.SphereGeometry(5, 24, 24);
                    const eyeballMat = new THREE.MeshStandardMaterial({
                        color: 0xffffcc,
                        emissive: 0x888844,
                        emissiveIntensity: 0.5
                    });
                    const eyeball = new THREE.Mesh(eyeballGeo, eyeballMat);
                    eyeGroup.add(eyeball);
                    
                    const irisGeo = new THREE.SphereGeometry(3, 16, 16);
                    const irisMat = new THREE.MeshStandardMaterial({
                        color: 0x00aa66,
                        emissive: 0x005533,
                        emissiveIntensity: 0.8
                    });
                    const iris = new THREE.Mesh(irisGeo, irisMat);
                    iris.position.z = 3;
                    eyeGroup.add(iris);
                    
                    const pupilGeo = new THREE.SphereGeometry(1.5, 12, 12);
                    pupilGeo.scale(0.5, 1, 0.3);
                    const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const pupil = new THREE.Mesh(pupilGeo, pupilMat);
                    pupil.position.z = 4.5;
                    eyeGroup.add(pupil);
                    eyeGroup.userData = { pupil: pupil };
                    
                    eyeGroup.position.x = side * 8;
                    eyeGroup.position.y = 3;
                    eyeGroup.position.z = 5;
                    this.eyes.push(eyeGroup);
                    this.group.add(eyeGroup);
                }
                
                // Âò¥Ôºà„Åè„Å°„Å∞„ÅóÔºâ
                const beakGeo = new THREE.ConeGeometry(4, 8, 6);
                const beakMat = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    emissive: 0x220000,
                    emissiveIntensity: 0.3,
                    metalness: 0.8
                });
                this.beak = new THREE.Mesh(beakGeo, beakMat);
                this.beak.position.z = 10;
                this.beak.position.y = -3;
                this.beak.rotation.x = Math.PI / 2;
                this.group.add(this.beak);
                
                // ‰∏ªËß¶ÊâãÔºà8Êú¨„ÅÆÂ∑®Â§ß„Å™Ëß¶ÊâãÔºâ
                this.tentacles = [];
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const tentacle = this.createMassiveTentacle(35 + (i % 2) * 10);
                    tentacle.position.x = Math.cos(angle) * 10;
                    tentacle.position.y = Math.sin(angle) * 8;
                    tentacle.position.z = 5;
                    tentacle.userData = { angle: angle, index: i, length: 35 + (i % 2) * 10 };
                    this.tentacles.push(tentacle);
                    this.group.add(tentacle);
                }
                
                // Ë£úÂä©Ëß¶ÊâãÔºàÁü≠„ÅÑËß¶Êâã16Êú¨Ôºâ
                this.subTentacles = [];
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const tentacle = this.createMassiveTentacle(15);
                    tentacle.position.x = Math.cos(angle) * 12;
                    tentacle.position.y = Math.sin(angle) * 10;
                    tentacle.position.z = -5;
                    tentacle.userData = { angle: angle, index: i };
                    this.subTentacles.push(tentacle);
                    this.group.add(tentacle);
                }
                
                // Âê∏Áõ§„ÅÆÂÖâÔºàËß¶Êâã„Å´Ê≤ø„Å£„Å¶Ôºâ
                this.suckers = [];
                this.tentacles.forEach((t, ti) => {
                    for (let s = 0; s < 8; s++) {
                        const suckerGeo = new THREE.CircleGeometry(0.8, 12);
                        const suckerMat = new THREE.MeshBasicMaterial({
                            color: 0xff6688,
                            transparent: true,
                            opacity: 0.6,
                            side: THREE.DoubleSide
                        });
                        const sucker = new THREE.Mesh(suckerGeo, suckerMat);
                        sucker.userData = { tentacleIndex: ti, segmentIndex: s };
                        this.suckers.push(sucker);
                        this.group.add(sucker);
                    }
                });
                
                // Áô∫ÂÖâÂô®ÂÆò
                this.biolights = [];
                for (let i = 0; i < 20; i++) {
                    const lightGeo = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);
                    const lightMat = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.5 + Math.random() * 0.2, 1, 0.6),
                        transparent: true,
                        opacity: 0.8
                    });
                    const light = new THREE.Mesh(lightGeo, lightMat);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    light.position.set(
                        Math.sin(phi) * Math.cos(theta) * 13,
                        Math.sin(phi) * Math.sin(theta) * 10,
                        Math.cos(phi) * 15 - 10
                    );
                    this.biolights.push(light);
                    this.group.add(light);
                }
                
                // „Ç§„É≥„ÇØ„ÅÆÈõ≤„Ç®„Éï„Çß„ÇØ„ÉàÁî®
                this.inkCloud = null;
                
                this.group.position.copy(this.position);
                this.scene.add(this.group);
            }
            
            createMassiveTentacle(length) {
                const group = new THREE.Group();
                const segmentCount = Math.floor(length / 3);
                
                for (let i = 0; i < segmentCount; i++) {
                    const t = i / segmentCount;
                    const size = 3 * (1 - t * 0.6);
                    const geo = new THREE.SphereGeometry(size, 10, 10);
                    geo.scale(1, 1, 1.8);
                    
                    const hue = 0.55 + t * 0.1;
                    const mat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(hue, 0.5, 0.35),
                        emissive: new THREE.Color().setHSL(hue, 0.6, 0.15),
                        emissiveIntensity: 0.3 + t * 0.3
                    });
                    const seg = new THREE.Mesh(geo, mat);
                    seg.userData = { index: i, basePos: new THREE.Vector3(0, 0, i * 4) };
                    group.add(seg);
                }
                
                // ÂÖàÁ´Ø„ÅÆÊ£ò
                const tipGeo = new THREE.ConeGeometry(1.5, 6, 6);
                const tipMat = new THREE.MeshBasicMaterial({
                    color: 0x00ffaa,
                    transparent: true,
                    opacity: 0.9
                });
                const tip = new THREE.Mesh(tipGeo, tipMat);
                tip.userData = { index: segmentCount, isTip: true };
                group.add(tip);
                
                return group;
            }
            
            getCollisionRadius() { return 20; }
            
            takeDamage(amount, fromBomb = false) {
                const actualDamage = fromBomb ? Math.min(amount, 500) : amount;
                this.health -= actualDamage;
                this.flashDamage();
                
                if (this.health <= 0) {
                    this.health = 0;
                    this.alive = false;
                    return true;
                }
                return false;
            }
            
            flashDamage() {
                this.body.material.emissiveIntensity = 1.5;
                setTimeout(() => {
                    if (this.body) this.body.material.emissiveIntensity = 0.5;
                }, 100);
            }
            
            update(deltaTime, projectiles) {
                if (!this.alive) return;
                
                this.time += deltaTime;
                this.moveTimer += deltaTime;
                this.attackTimer += deltaTime;
                this.tentacleAttackTimer += deltaTime;
                
                // Ë§áÈõë„Å™3DÁßªÂãï
                if (this.moveTimer > 3) {
                    this.movePhase = (this.movePhase + 1) % 8;
                    this.moveTimer = 0;
                }
                
                switch(this.movePhase) {
                    case 0: // ‰∏äÁ©∫„Åã„ÇâË¶ã‰∏ã„Çç„Åô
                        this.targetPos.set(0, 25, -50);
                        this.moveSpeed = 1.2;
                        break;
                    case 1: // Â∑¶ÂÅ¥„Åã„ÇâÂõû„ÇäËæº„ÇÄ
                        this.targetPos.set(-35, 0, -60);
                        this.moveSpeed = 1.2;
                        break;
                    case 2: // „Éó„É¨„Ç§„É§„Éº„Å´ÊÄ•Êé•Ëøë
                        if (this.player) {
                            this.targetPos.set(this.player.position.x, this.player.position.y + 10, -30);
                        }
                        this.moveSpeed = 2.5;
                        break;
                    case 3: // Âè≥ÂÅ¥„Å∏ÁßªÂãï
                        this.targetPos.set(35, -10, -55);
                        this.moveSpeed = 1.2;
                        break;
                    case 4: // ‰∏ã„Åã„ÇâÊµÆ‰∏ä
                        this.targetPos.set(0, -20, -70);
                        this.moveSpeed = 1.2;
                        break;
                    case 5: // ÂæåÊñπ„ÅßÂæÖÊ©ü
                        this.targetPos.set((Math.random() - 0.5) * 40, 0, -85);
                        this.moveSpeed = 1.2;
                        break;
                    case 6: // ÈÅ†„Åè„Å∏Á¥†Êó©„ÅèÈÄÉ„Åí„ÇãÔºà„Ç§„É≥„ÇØÂô¥Â∞ÑÈ¢®Ôºâ
                        this.targetPos.set((Math.random() - 0.5) * 45, (Math.random() - 0.5) * 30, -140);
                        this.moveSpeed = 5.0;
                        break;
                    case 7: // ÈÄÉ„Åí„ÅüÂæå„Å´Âõû„ÇäËæº„Çì„ÅßÊàª„Çã
                        this.targetPos.set((Math.random() - 0.5) * 40, (Math.random() - 0.5) * 20, -45);
                        this.moveSpeed = 2.5;
                        break;
                }
                
                this.position.lerp(this.targetPos, deltaTime * (this.moveSpeed || 1.2));
                
                // ‰Ωì„ÅÆÊè∫„Çå
                this.body.rotation.x = Math.sin(this.time * 0.5) * 0.1;
                this.body.rotation.z = Math.cos(this.time * 0.4) * 0.1;
                this.mantle.rotation.z = Math.sin(this.time * 0.3) * 0.05;
                
                // ÁõÆ„Åå„Éó„É¨„Ç§„É§„Éº„ÇíËøΩË∑°
                if (this.player) {
                    this.eyes.forEach(eye => {
                        const dir = new THREE.Vector3().subVectors(this.player.position, this.position).normalize();
                        eye.userData.pupil.position.x = dir.x * 1.5;
                        eye.userData.pupil.position.y = dir.y * 1.5;
                    });
                }
                
                // ‰∏ªËß¶Êâã„ÅÆ„É™„Ç¢„É´„Å™„ÅÜ„Å≠„Çä
                this.tentacles.forEach((tentacle, ti) => {
                    const baseAngle = tentacle.userData.angle;
                    tentacle.children.forEach((seg, si) => {
                        if (seg.userData.isTip) {
                            seg.position.z = (tentacle.userData.length / 3) * 4;
                            seg.position.x = Math.sin(this.time * 2 + ti + si) * si * 0.8;
                            seg.position.y = Math.cos(this.time * 1.5 + ti + si) * si * 0.6;
                        } else {
                            const wave1 = Math.sin(this.time * 2.5 + ti * 0.7 + si * 0.4) * (si * 0.5);
                            const wave2 = Math.cos(this.time * 2 + ti * 0.5 + si * 0.3) * (si * 0.4);
                            seg.position.x = wave1;
                            seg.position.y = wave2;
                            seg.position.z = si * 4;
                        }
                    });
                    tentacle.rotation.z = baseAngle + Math.sin(this.time * 0.8 + ti) * 0.4;
                    tentacle.rotation.x = Math.cos(this.time * 0.6 + ti) * 0.3;
                });
                
                // Ë£úÂä©Ëß¶Êâã
                this.subTentacles.forEach((tentacle, ti) => {
                    tentacle.children.forEach((seg, si) => {
                        const wave = Math.sin(this.time * 3 + ti * 0.5 + si * 0.5) * si * 0.3;
                        seg.position.x = wave;
                        seg.position.z = si * 3;
                    });
                });
                
                // Âê∏Áõ§„ÅÆ‰ΩçÁΩÆÊõ¥Êñ∞
                this.suckers.forEach((sucker, si) => {
                    const ti = sucker.userData.tentacleIndex;
                    const segi = sucker.userData.segmentIndex;
                    if (this.tentacles[ti] && this.tentacles[ti].children[segi]) {
                        const seg = this.tentacles[ti].children[segi];
                        const worldPos = new THREE.Vector3();
                        seg.getWorldPosition(worldPos);
                        sucker.position.copy(worldPos).sub(this.position);
                        sucker.position.y -= 1;
                        sucker.lookAt(this.position);
                    }
                });
                
                // Áô∫ÂÖâÂô®ÂÆò
                this.biolights.forEach((light, i) => {
                    light.material.opacity = 0.5 + Math.sin(this.time * 4 + i) * 0.4;
                });
                
                // ÈÄöÂ∏∏ÊîªÊíÉ
                if (this.attackTimer > 1.5) {
                    this.attack(projectiles);
                    this.attackTimer = 0;
                }
                
                // ÁâπÊÆäÊîªÊíÉÔºöËß¶ÊâãËñô„ÅéÊâï„ÅÑ
                if (this.tentacleAttackTimer > 5) {
                    this.tentacleSweep(projectiles);
                    this.tentacleAttackTimer = 0;
                }
                
                this.group.position.copy(this.position);
                this.group.rotation.y = Math.sin(this.time * 0.3) * 0.2;
            }
            
            attack(projectiles) {
                // ÁõÆ„Åã„Çâ„Éì„Éº„É†
                this.eyes.forEach((eye, i) => {
                    const eyeWorldPos = new THREE.Vector3();
                    eye.getWorldPosition(eyeWorldPos);
                    
                    if (this.player) {
                        const dir = new THREE.Vector3().subVectors(this.player.position, eyeWorldPos).normalize();
                        
                        for (let j = -1; j <= 1; j++) {
                            const spreadDir = dir.clone();
                            spreadDir.x += j * 0.1;
                            spreadDir.normalize();
                            
                            const proj = new Projectile(this.scene, eyeWorldPos, spreadDir, false);
                            proj.damage = 12;
                            proj.speed = 45;
                            projectiles.push(proj);
                        }
                    }
                });
            }
            
            // ÁâπÊÆäÊîªÊíÉÔºöËß¶ÊâãËñô„ÅéÊâï„ÅÑ
            tentacleSweep(projectiles) {
                // ÂÖ®Ëß¶Êâã„ÅÆÂÖàÁ´Ø„Åã„ÇâÊîæÂ∞ÑÁä∂„Å´Âºæ„ÇíÁô∫Â∞Ñ
                this.tentacles.forEach((tentacle, i) => {
                    const tipSeg = tentacle.children[tentacle.children.length - 1];
                    const tipWorldPos = new THREE.Vector3();
                    tipSeg.getWorldPosition(tipWorldPos);
                    
                    // ÂêÑËß¶Êâã„Åã„Çâ5ÊñπÂêë„Å´Áô∫Â∞Ñ
                    for (let j = 0; j < 5; j++) {
                        const angle = (j / 5) * Math.PI * 2 + this.time;
                        const dir = new THREE.Vector3(
                            Math.cos(angle) * 0.4,
                            Math.sin(angle) * 0.4,
                            0.7
                        ).normalize();
                        
                        const proj = new Projectile(this.scene, tipWorldPos, dir, false);
                        proj.damage = 10;
                        proj.speed = 40;
                        projectiles.push(proj);
                    }
                });
            }
            
            destroy() {
                if (this.group) {
                    this.scene.remove(this.group);
                }
                this.alive = false;
            }
        }
        
        // Wave 4 Boss: Ëü≤Âûã„Ç®„Ç§„É™„Ç¢„É≥ÔºàÂàÜË£ÇÊîªÊíÉÔºâ- HP2ÂÄç
        class BossAlien4 {
            constructor(scene, playerRef) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'boss';
                this.waveNumber = 4;
                
                this.maxHealth = 45000; // 7500 * 3 * 2
                this.health = this.maxHealth;
                this.score = 18000;
                
                this.position = new THREE.Vector3(0, 0, -80);
                this.targetPos = new THREE.Vector3();
                
                this.attackTimer = 0;
                this.chargeTimer = 0;
                this.isCharging = false;
                this.moveTimer = 0;
                this.time = 0;
                
                this.createMesh();
            }
            
            createMesh() {
                this.group = new THREE.Group();
                
                // Êú¨‰ΩìÔºàÁØÄ„ÅÆ„ÅÇ„Çã„Ç≠„ÉÅ„É≥Ë≥™„ÅÆËô´Âûã„ÄÅ„Çà„ÇäË§áÈõë„Å´Ôºâ
                this.segments = [];
                for (let i = 0; i < 9; i++) {
                    const size = i === 0 ? 12 : (i === 8 ? 5 : 9 - Math.abs(i - 4) * 0.6);
                    const segGeo = new THREE.DodecahedronGeometry(size, 0);
                    const hue = 0.05 + (i / 9) * 0.08;
                    const segMat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(hue, 0.8, 0.25),
                        emissive: new THREE.Color().setHSL(hue, 0.9, 0.1),
                        emissiveIntensity: 0.5,
                        metalness: 0.7,
                        roughness: 0.3
                    });
                    const seg = new THREE.Mesh(segGeo, segMat);
                    seg.position.z = -i * 10;
                    seg.rotation.y = i * 0.2;
                    this.segments.push(seg);
                    this.group.add(seg);
                    
                    // ÂêÑÁØÄ„Å´„Éà„Ç≤
                    if (i > 0 && i < 8) {
                        for (let s = 0; s < 4; s++) {
                            const spikeGeo = new THREE.ConeGeometry(1, 5, 4);
                            const spikeMat = new THREE.MeshStandardMaterial({
                                color: 0x441100,
                                emissive: 0x220000
                            });
                            const spike = new THREE.Mesh(spikeGeo, spikeMat);
                            const angle = (s / 4) * Math.PI * 2;
                            spike.position.x = Math.cos(angle) * (size - 1);
                            spike.position.y = Math.sin(angle) * (size - 1);
                            spike.position.z = -i * 10;
                            spike.rotation.z = -angle + Math.PI / 2;
                            this.group.add(spike);
                        }
                    }
                }
                
                // È†≠ÈÉ®„ÅÆÂ∑®Â§ß„Å™ÈéåÈ°é
                this.jaws = [];
                for (let side = -1; side <= 1; side += 2) {
                    const jawGroup = new THREE.Group();
                    
                    // Èéå„ÅÆÂΩ¢Áä∂
                    const jawGeo = new THREE.ConeGeometry(3, 18, 6);
                    const jawMat = new THREE.MeshStandardMaterial({
                        color: 0x220000,
                        emissive: 0x440000,
                        emissiveIntensity: 0.3,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const jaw = new THREE.Mesh(jawGeo, jawMat);
                    jaw.rotation.x = -Math.PI / 2.5;
                    jawGroup.add(jaw);
                    
                    // Èéå„ÅÆÂàÉÂÖà
                    const bladeGeo = new THREE.ConeGeometry(1, 8, 4);
                    const bladeMat = new THREE.MeshBasicMaterial({
                        color: 0xff4400,
                        transparent: true,
                        opacity: 0.8
                    });
                    const blade = new THREE.Mesh(bladeGeo, bladeMat);
                    blade.position.y = 12;
                    blade.rotation.x = -0.3;
                    jawGroup.add(blade);
                    
                    jawGroup.position.x = side * 8;
                    jawGroup.position.z = 10;
                    jawGroup.userData = { side: side };
                    this.jaws.push(jawGroup);
                    this.group.add(jawGroup);
                }
                
                // Ë§áÁúºÔºàË§áÊï∞„ÅÆÂ∞è„Åï„Å™ÁõÆ„ÅÆÈõÜÂêàÔºâ
                this.compoundEyes = [];
                for (let side = -1; side <= 1; side += 2) {
                    const eyeGroup = new THREE.Group();
                    for (let ex = 0; ex < 12; ex++) {
                        const eyeGeo = new THREE.SphereGeometry(1.2 - (ex % 3) * 0.2, 8, 8);
                        const eyeMat = new THREE.MeshStandardMaterial({
                            color: 0xff2200,
                            emissive: 0xff0000,
                            emissiveIntensity: 0.8 + Math.random() * 0.4
                        });
                        const eye = new THREE.Mesh(eyeGeo, eyeMat);
                        const row = Math.floor(ex / 4);
                        const col = ex % 4;
                        eye.position.x = (col - 1.5) * 2;
                        eye.position.y = (row - 1) * 2;
                        eye.position.z = 2;
                        eyeGroup.add(eye);
                    }
                    eyeGroup.position.x = side * 8;
                    eyeGroup.position.y = 5;
                    eyeGroup.position.z = 5;
                    this.compoundEyes.push(eyeGroup);
                    this.group.add(eyeGroup);
                }
                
                // Ëß¶Ëßí
                this.antennae = [];
                for (let side = -1; side <= 1; side += 2) {
                    const antennaGroup = new THREE.Group();
                    for (let a = 0; a < 8; a++) {
                        const antGeo = new THREE.SphereGeometry(0.8 - a * 0.08, 6, 6);
                        const antMat = new THREE.MeshStandardMaterial({
                            color: 0x553322,
                            emissive: 0x221100
                        });
                        const ant = new THREE.Mesh(antGeo, antMat);
                        ant.position.y = a * 3;
                        ant.position.z = a * 2;
                        antennaGroup.add(ant);
                    }
                    antennaGroup.position.x = side * 5;
                    antennaGroup.position.y = 8;
                    antennaGroup.position.z = 8;
                    this.antennae.push(antennaGroup);
                    this.group.add(antennaGroup);
                }
                
                // ËÑöÔºà8ÂØæ„ÄÅ„Çà„ÇäË§áÈõë„Å™Èñ¢ÁØÄÔºâ
                this.legs = [];
                for (let i = 0; i < 8; i++) {
                    for (let side = -1; side <= 1; side += 2) {
                        const legGroup = new THREE.Group();
                        
                        // Â§ßËÖøÈÉ®
                        const upperGeo = new THREE.CylinderGeometry(1.5, 1.0, 12, 6);
                        const upperMat = new THREE.MeshStandardMaterial({
                            color: 0x553311,
                            emissive: 0x221100,
                            metalness: 0.5,
                            roughness: 0.4
                        });
                        const upper = new THREE.Mesh(upperGeo, upperMat);
                        upper.rotation.z = side * 0.7;
                        upper.position.x = side * 6;
                        legGroup.add(upper);
                        
                        // ËÑõÈÉ®
                        const lowerGeo = new THREE.CylinderGeometry(1.0, 0.5, 10, 6);
                        const lower = new THREE.Mesh(lowerGeo, upperMat);
                        lower.position.x = side * 12;
                        lower.position.y = -5;
                        lower.rotation.z = side * 1.3;
                        legGroup.add(lower);
                        
                        // Áà™
                        const clawGeo = new THREE.ConeGeometry(0.5, 4, 4);
                        const clawMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
                        const claw = new THREE.Mesh(clawGeo, clawMat);
                        claw.position.x = side * 16;
                        claw.position.y = -9;
                        claw.rotation.z = side * 1.5;
                        legGroup.add(claw);
                        
                        legGroup.position.z = -i * 9 - 5;
                        legGroup.userData = { side: side, index: i };
                        this.legs.push(legGroup);
                        this.group.add(legGroup);
                    }
                }
                
                // Â∞æ„ÅÆÊØíÈáù
                const stingerGeo = new THREE.ConeGeometry(3, 15, 6);
                const stingerMat = new THREE.MeshStandardMaterial({
                    color: 0x440000,
                    emissive: 0x880000,
                    emissiveIntensity: 0.6
                });
                this.stinger = new THREE.Mesh(stingerGeo, stingerMat);
                this.stinger.position.z = -80;
                this.stinger.rotation.x = Math.PI / 2;
                this.group.add(this.stinger);
                
                // ÊØíÊª¥„Ç®„Éï„Çß„ÇØ„Éà
                const venomGeo = new THREE.SphereGeometry(2, 16, 16);
                const venomMat = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.7
                });
                this.venom = new THREE.Mesh(venomGeo, venomMat);
                this.venom.position.z = -88;
                this.group.add(this.venom);
                
                this.group.position.copy(this.position);
                this.scene.add(this.group);
            }
            
            getCollisionRadius() { return 22; }
            
            takeDamage(amount, fromBomb = false) {
                const actualDamage = fromBomb ? Math.min(amount, 500) : amount;
                this.health -= actualDamage;
                this.flashDamage();
                
                if (this.health <= 0) {
                    this.health = 0;
                    this.alive = false;
                    return true;
                }
                return false;
            }
            
            flashDamage() {
                this.segments.forEach(s => {
                    s.material.emissiveIntensity = 1.5;
                    setTimeout(() => {
                        s.material.emissiveIntensity = 0.5;
                    }, 100);
                });
                this.compoundEyes.forEach(eye => {
                    eye.children.forEach(e => {
                        e.material.emissiveIntensity = 2.0;
                        setTimeout(() => {
                            e.material.emissiveIntensity = 0.8;
                        }, 100);
                    });
                });
            }
            
            update(deltaTime, projectiles) {
                if (!this.alive) return;
                
                this.time += deltaTime;
                this.attackTimer += deltaTime;
                this.chargeTimer += deltaTime;
                this.moveTimer = (this.moveTimer || 0) + deltaTime;
                
                // ÁßªÂãï„Éï„Çß„Éº„Ç∫„ÅÆÁÆ°ÁêÜ
                if (this.moveTimer > 4) {
                    this.movePhase = ((this.movePhase || 0) + 1) % 5;
                    this.moveTimer = 0;
                }
                
                // 3DÁ©∫Èñì„ÇíÁ∏¶Ê®™ÁÑ°Â∞Ω„Å´Âãï„Åè
                if (!this.isCharging) {
                    const t = this.time * 0.7;
                    const phase = this.movePhase || 0;
                    
                    switch(phase) {
                        case 0: // Ë§áÈõë„Å™Ëû∫ÊóãËªåÈÅì
                            this.position.x = Math.sin(t) * 30 + Math.sin(t * 2.3) * 10;
                            this.position.y = Math.cos(t * 1.3) * 20 + Math.sin(t * 0.7) * 8;
                            this.position.z = -55 + Math.sin(t * 0.5) * 25;
                            break;
                        case 1: // È´òÈÄü„ÅßÈÅ†„Åè„Å∏ÈÄÉ„Åí„Çã
                            this.targetPos.set(
                                (Math.random() - 0.5) * 50,
                                (Math.random() - 0.5) * 30,
                                -135
                            );
                            this.position.lerp(this.targetPos, deltaTime * 4.5);
                            break;
                        case 2: // ÈÄÉ„Åí„ÅüÂæå„Å´ÈÄô„ÅÑÊàª„Çã
                            this.targetPos.set(
                                Math.sin(t * 2) * 35,
                                Math.cos(t * 1.5) * 20,
                                -60
                            );
                            this.position.lerp(this.targetPos, deltaTime * 2.5);
                            break;
                        case 3: // Ê®™ÊñπÂêë„Å´Â§ß„Åç„ÅèÁßªÂãï
                            this.position.x = Math.sin(t * 0.8) * 45;
                            this.position.y = Math.cos(t * 0.6) * 15;
                            this.position.z = -50 + Math.sin(t * 0.4) * 15;
                            break;
                        case 4: // „Éó„É¨„Ç§„É§„Éº„ÇíÁãô„Å£„Å¶Êé•Ëøë
                            if (this.player) {
                                this.targetPos.copy(this.player.position);
                                this.targetPos.z -= 25;
                                this.position.lerp(this.targetPos, deltaTime * 1.8);
                            }
                            break;
                    }
                    
                    // Á™ÅÈÄ≤Ê∫ñÂÇôÔºà‰∏ÄÂÆöÊôÇÈñì„Åî„Å®Ôºâ
                    if (this.chargeTimer > 10 && this.player && phase !== 1) {
                        this.isCharging = true;
                        this.chargeTimer = 0;
                        this.targetPos.copy(this.player.position);
                        this.targetPos.z -= 10;
                    }
                } else {
                    // Á™ÅÈÄ≤ÊîªÊíÉ
                    this.position.lerp(this.targetPos, deltaTime * 3);
                    if (this.position.distanceTo(this.targetPos) < 5) {
                        this.isCharging = false;
                    }
                }
                
                // ‰ΩìÁØÄ„ÅÆ„ÅÜ„Å≠„ÇäÔºà„Çà„ÇäË§áÈõëÔºâ
                this.segments.forEach((seg, i) => {
                    if (i > 0) {
                        const delay = i * 0.2;
                        const wave = Math.sin(this.time * 3 - delay) * (3 + i * 0.5);
                        const wave2 = Math.cos(this.time * 2.5 - delay) * (2 + i * 0.3);
                        seg.position.x = wave;
                        seg.position.y = wave2;
                        seg.position.z = -i * 10 + Math.sin(this.time * 2 - delay) * 2;
                        seg.rotation.y = Math.sin(this.time * 2 - i * 0.2) * 0.3;
                        seg.rotation.z = Math.cos(this.time * 1.5 - i * 0.15) * 0.2;
                    }
                });
                
                // È°é„ÅÆÂãï„ÅçÔºàÊîªÊíÉÁöÑ„Å´Ôºâ
                this.jaws.forEach((jaw, i) => {
                    const openAngle = Math.sin(this.time * 4) * 0.4 + (this.isCharging ? 0.5 : 0);
                    jaw.rotation.y = jaw.userData.side * (0.3 + openAngle);
                    jaw.rotation.x = Math.sin(this.time * 3) * 0.1;
                });
                
                // Ëß¶Ëßí„ÅÆ„ÅÜ„Å≠„Çä
                this.antennae.forEach((ant, ai) => {
                    ant.children.forEach((seg, i) => {
                        seg.position.x = Math.sin(this.time * 5 + i * 0.5) * (i * 0.4);
                        seg.position.y = i * 3 + Math.cos(this.time * 4 + i * 0.3) * 0.5;
                    });
                });
                
                // Ë§áÁúº„ÅÆËÑàÂãï
                this.compoundEyes.forEach(eye => {
                    eye.children.forEach((e, i) => {
                        const pulse = 0.8 + Math.sin(this.time * 6 + i * 0.3) * 0.3;
                        e.scale.setScalar(pulse);
                    });
                });
                
                // ËÑö„ÅÆÂãï„ÅçÔºàÊ≠©Ë°å„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ôºâ
                this.legs.forEach((leg, i) => {
                    const phase = this.time * 10 + leg.userData.index * 0.8;
                    leg.rotation.x = Math.sin(phase) * 0.6;
                    leg.rotation.y = Math.cos(phase * 0.5) * 0.3 * leg.userData.side;
                    leg.children.forEach((part, pi) => {
                        if (pi > 0) {
                            part.rotation.z += Math.sin(this.time * 8 + leg.userData.index) * 0.02;
                        }
                    });
                });
                
                // ÊØíÈáù„ÅÆËÑàÂãï„Å®Âãï„Åç
                const venomPulse = 1 + Math.sin(this.time * 4) * 0.4;
                this.venom.scale.setScalar(venomPulse);
                this.stinger.rotation.y = Math.sin(this.time * 2) * 0.3;
                this.stinger.rotation.x = Math.PI / 2 + Math.cos(this.time * 1.5) * 0.2;
                
                // ÈÄöÂ∏∏ÊîªÊíÉ
                if (this.attackTimer > 1.2) {
                    this.attack(projectiles);
                    this.attackTimer = 0;
                }
                
                // ÁâπÊÆäÊîªÊíÉÔºöÈéåÊîªÊíÉ
                if (Math.floor(this.time) % 7 === 0 && Math.floor(this.time * 10) % 10 === 0) {
                    this.scytheAttack(projectiles);
                }
                
                this.group.position.copy(this.position);
                this.group.rotation.y = Math.atan2(
                    this.player ? this.player.position.x - this.position.x : 0,
                    this.player ? this.player.position.z - this.position.z : 1
                ) * 0.3;
            }
            
            attack(projectiles) {
                const pattern = Math.floor(Math.random() * 4);
                
                if (pattern === 0) {
                    // ÈÖ∏ÂºæÔºàÊâáÁä∂Ôºâ
                    for (let i = -4; i <= 4; i++) {
                        const angle = i * 0.12;
                        const dir = new THREE.Vector3(
                            Math.sin(angle),
                            Math.sin(this.time + i) * 0.2,
                            Math.cos(angle)
                        ).normalize();
                        
                        const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                        proj.damage = 12;
                        proj.speed = 55;
                        projectiles.push(proj);
                    }
                } else if (pattern === 1) {
                    // ËøΩÂ∞æÂºæ
                    for (let i = 0; i < 5; i++) {
                        if (this.player) {
                            setTimeout(() => {
                                if (!this.alive) return;
                                const dir = new THREE.Vector3()
                                    .subVectors(this.player.position, this.position)
                                    .normalize();
                                
                                const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                                proj.damage = 12;
                                proj.speed = 60;
                                projectiles.push(proj);
                            }, i * 150);
                        }
                    }
                } else if (pattern === 2) {
                    // ÊØíÈáù„Åã„ÇâÊØíÊ∂≤Áô∫Â∞Ñ
                    const stingerPos = this.position.clone();
                    stingerPos.z -= 85;
                    
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const dir = new THREE.Vector3(
                            Math.cos(angle) * 0.6,
                            Math.sin(angle) * 0.6,
                            0.8
                        ).normalize();
                        
                        const proj = new Projectile(this.scene, stingerPos.clone(), dir, false);
                        proj.damage = 15;
                        proj.speed = 45;
                        projectiles.push(proj);
                    }
                } else {
                    // ÂÖ®Êñπ‰ΩçÂºæÂπï
                    for (let i = 0; i < 20; i++) {
                        const angle = (i / 20) * Math.PI * 2 + this.time;
                        const dir = new THREE.Vector3(
                            Math.sin(angle),
                            Math.cos(angle) * 0.3,
                            0.5
                        ).normalize();
                        
                        const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                        proj.damage = 8;
                        proj.speed = 40;
                        projectiles.push(proj);
                    }
                }
            }
            
            // ÁâπÊÆäÊîªÊíÉÔºöÈéå„ÅÆËñô„ÅéÊâï„ÅÑ
            scytheAttack(projectiles) {
                // ‰∏°È°é„Åã„ÇâÂºß„ÇíÊèè„Åè„Çà„ÅÜ„Å´Âºæ„ÇíÁô∫Â∞Ñ
                this.jaws.forEach((jaw, ji) => {
                    const jawWorldPos = new THREE.Vector3();
                    jaw.getWorldPosition(jawWorldPos);
                    
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI - Math.PI / 2;
                        const dir = new THREE.Vector3(
                            Math.cos(angle) * jaw.userData.side,
                            Math.sin(angle) * 0.5,
                            0.6
                        ).normalize();
                        
                        const proj = new Projectile(this.scene, jawWorldPos.clone(), dir, false);
                        proj.damage = 18;
                        proj.speed = 50;
                        projectiles.push(proj);
                    }
                });
            }
            
            destroy() {
                if (this.group) {
                    this.scene.remove(this.group);
                }
                this.alive = false;
            }
        }
        
        // Wave 5 Final Boss: ÂÆáÂÆô„ÅÆÊîØÈÖçËÄÖÔºàÂ∑®Â§ß„Å™Á¶ç„ÄÖ„Åó„ÅÑ„Ç®„Ç§„É™„Ç¢„É≥Ôºâ
        class BossAlien5 {
            constructor(scene, playerRef) {
                this.scene = scene;
                this.player = playerRef;
                this.alive = true;
                this.type = 'boss';
                this.waveNumber = 5;
                this.isFinalBoss = true;
                
                // ‚òÖ HP 6ÂÄç: 12000 ‚Üí 72000
                this.maxHealth = 72000;
                this.health = this.maxHealth;
                this.score = 30000;
                
                this.position = new THREE.Vector3(0, 0, -90);
                this.targetPos = new THREE.Vector3();
                
                this.attackTimer = 0;
                this.phase = 1; // 3ÊÆµÈöé„ÅÆ„Éï„Çß„Éº„Ç∫
                this.moveTimer = 0;
                this.time = 0;
                this.rageMode = false;
                
                this.createMesh();
            }
            
            createMesh() {
                this.group = new THREE.Group();
                
                // ========================================
                // ÂÆáÂÆô„ÇíÁµ±„Åπ„ÇãÁµÇÁÑâ„ÅÆÂ∏ùÁéã
                // Â§öÊ¨°ÂÖÉ„ÅÆÊ¨°ÂÖÉÊ†∏„ÇíÊåÅ„Å§Á©∂Ê•µ„ÅÆÂ≠òÂú®
                // ========================================
                
                // Â§öÂ±§Ê¨°ÂÖÉ„Ç∑„Éº„É´„ÉâÔºà3Â±§Ôºâ
                this.shields = [];
                [30, 36, 42].forEach((radius, i) => {
                    const shieldGeo = new THREE.IcosahedronGeometry(radius, 2);
                    const shieldMat = new THREE.MeshStandardMaterial({
                        color: [0x440066, 0x330055, 0x220044][i],
                        emissive: [0x660088, 0x550077, 0x440066][i],
                        emissiveIntensity: 0.4 - i * 0.1,
                        transparent: true,
                        opacity: 0.3 - i * 0.05,
                        wireframe: i > 0,
                        metalness: 0.9,
                        roughness: 0.2
                    });
                    const shield = new THREE.Mesh(shieldGeo, shieldMat);
                    shield.userData.baseRadius = radius;
                    this.shields.push(shield);
                    this.group.add(shield);
                });
                
                // Â∑®Â§ß„Å™‰∏≠Â§Æ„Ç≥„Ç¢ÔºàÊúâÊ©üÁöÑ„Å™Â§öÈù¢‰ΩìÔºâ
                const coreGeo = new THREE.IcosahedronGeometry(18, 3);
                // È†ÇÁÇπ„ÇíÊ≠™„Åæ„Åõ„Å¶ÊúâÊ©üÁöÑ„Å´
                const corePos = coreGeo.attributes.position;
                for (let i = 0; i < corePos.count; i++) {
                    const x = corePos.getX(i);
                    const y = corePos.getY(i);
                    const z = corePos.getZ(i);
                    const dist = Math.sqrt(x*x + y*y + z*z);
                    const noise = 1 + Math.sin(x * 0.5) * Math.cos(y * 0.5) * 0.15;
                    corePos.setXYZ(i, x * noise, y * noise, z * noise);
                }
                coreGeo.computeVertexNormals();
                
                const coreMat = new THREE.MeshStandardMaterial({
                    color: 0x110011,
                    emissive: 0x880088,
                    emissiveIntensity: 1.0,
                    metalness: 0.8,
                    roughness: 0.2
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);
                this.group.add(this.core);
                
                // Ê¨°ÂÖÉÊ†∏Ôºà‰∏≠ÂøÉ„ÅßËÑàÂãï„Åô„ÇãÁ©∂Ê•µ„ÅÆ„Ç®„Éç„É´„ÇÆ„ÉºÔºâ
                this.dimensionCores = [];
                for (let i = 0; i < 5; i++) {
                    const coreGroup = new THREE.Group();
                    
                    // Â§ñÊÆª
                    const outerGeo = new THREE.DodecahedronGeometry(6 - i, 1);
                    const outerMat = new THREE.MeshStandardMaterial({
                        color: 0xff00ff,
                        emissive: 0xff00ff,
                        emissiveIntensity: 1.2,
                        transparent: true,
                        opacity: 0.7 - i * 0.1,
                        metalness: 1.0
                    });
                    const outer = new THREE.Mesh(outerGeo, outerMat);
                    coreGroup.add(outer);
                    
                    // ÂÜÖÊ†∏
                    const innerGeo = new THREE.IcosahedronGeometry(4 - i * 0.7, 0);
                    const innerMat = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.9
                    });
                    const inner = new THREE.Mesh(innerGeo, innerMat);
                    coreGroup.add(inner);
                    
                    coreGroup.userData.layer = i;
                    this.dimensionCores.push(coreGroup);
                    this.group.add(coreGroup);
                }
                
                // Á¶ç„ÄÖ„Åó„ÅÑÁéãÂÜ†Ôºà12Êú¨„ÅÆËßíÔºâ
                this.crownHorns = [];
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const hornGroup = new THREE.Group();
                    
                    // Âü∫ÈÉ®
                    const baseGeo = new THREE.CylinderGeometry(2.5, 3.5, 6, 6);
                    const baseMat = new THREE.MeshStandardMaterial({
                        color: 0x220022,
                        emissive: 0x330033,
                        emissiveIntensity: 0.5,
                        metalness: 0.9
                    });
                    const base = new THREE.Mesh(baseGeo, baseMat);
                    base.rotation.x = Math.PI / 2;
                    hornGroup.add(base);
                    
                    // ‰∏ªËßí
                    const mainHornGeo = new THREE.ConeGeometry(2, 22, 5);
                    const mainHornMat = new THREE.MeshStandardMaterial({
                        color: 0x330033,
                        emissive: 0x660066,
                        emissiveIntensity: 0.6,
                        metalness: 0.95
                    });
                    const mainHorn = new THREE.Mesh(mainHornGeo, mainHornMat);
                    mainHorn.position.z = -14;
                    mainHorn.rotation.x = -Math.PI / 2;
                    hornGroup.add(mainHorn);
                    
                    // Ëßí„ÅÆÂÖàÁ´ØÔºàÂÖâ„Çã„Ç∏„É•„Ç®„É´Ôºâ
                    const tipGeo = new THREE.OctahedronGeometry(1.2, 0);
                    const tipMat = new THREE.MeshBasicMaterial({
                        color: 0xff00ff,
                        transparent: true,
                        opacity: 0.9
                    });
                    const tip = new THREE.Mesh(tipGeo, tipMat);
                    tip.position.z = -26;
                    hornGroup.add(tip);
                    
                    // „Çµ„ÉñËßíÔºà2Êú¨Ôºâ
                    for (let j = 0; j < 2; j++) {
                        const subAngle = (j === 0 ? -1 : 1) * 0.4;
                        const subHornGeo = new THREE.ConeGeometry(1, 10, 4);
                        const subHorn = new THREE.Mesh(subHornGeo, mainHornMat.clone());
                        subHorn.position.z = -8;
                        subHorn.position.x = (j === 0 ? -2 : 2);
                        subHorn.rotation.x = -Math.PI / 2 + subAngle;
                        subHorn.rotation.z = subAngle;
                        hornGroup.add(subHorn);
                    }
                    
                    hornGroup.position.x = Math.cos(angle) * 18;
                    hornGroup.position.y = Math.sin(angle) * 18;
                    hornGroup.position.z = -5;
                    hornGroup.rotation.z = angle + Math.PI / 2;
                    
                    this.crownHorns.push(hornGroup);
                    this.group.add(hornGroup);
                }
                
                // ÂÖ®„Å¶„ÇíË¶ãÈÄö„ÅôÈÇ™ÁúºÔºà7„Å§ - ‰∏≠Â§Æ1 + Âë®Âõ≤6Ôºâ
                this.evilEyes = [];
                // ‰∏≠Â§Æ„ÅÆÂ∑®Â§ßÈÇ™Áúº
                const mainEyeGroup = this.createEvilEye(5);
                mainEyeGroup.position.set(0, 0, 20);
                this.evilEyes.push(mainEyeGroup);
                this.group.add(mainEyeGroup);
                
                // Âë®Âõ≤„ÅÆÈÇ™Áúº
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const eyeGroup = this.createEvilEye(3);
                    eyeGroup.position.set(
                        Math.cos(angle) * 12,
                        Math.sin(angle) * 12,
                        15
                    );
                    this.evilEyes.push(eyeGroup);
                    this.group.add(eyeGroup);
                }
                
                // Ê¨°ÂÖÉ„ÅÆË£Ç„ÅëÁõÆ„Åã„Çâ‰º∏„Å≥„ÇãËß¶ÊâãÔºà12Êú¨Ôºâ
                this.voidTentacles = [];
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const tentacle = this.createVoidTentacle();
                    tentacle.position.x = Math.cos(angle) * 14;
                    tentacle.position.y = Math.sin(angle) * 14;
                    tentacle.position.z = -10;
                    tentacle.userData = { angle: angle, index: i };
                    this.voidTentacles.push(tentacle);
                    this.group.add(tentacle);
                }
                
                // È≠îÊ≥ïÈô£Ôºà3Â±§ÂõûËª¢Ôºâ
                this.magicCircles = [];
                [25, 32, 40].forEach((radius, i) => {
                    const circleGroup = new THREE.Group();
                    
                    // Â§ñÁí∞
                    const ringGeo = new THREE.TorusGeometry(radius, 0.5, 8, 64);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: [0xff00ff, 0x00ffff, 0xffff00][i],
                        transparent: true,
                        opacity: 0.6
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2;
                    circleGroup.add(ring);
                    
                    // „É´„Éº„É≥ÊñáÂ≠óÔºà„Ç∑„É≥„Éú„É´Ôºâ
                    const symbolCount = 8 + i * 4;
                    for (let j = 0; j < symbolCount; j++) {
                        const sAngle = (j / symbolCount) * Math.PI * 2;
                        const symbolGeo = new THREE.BoxGeometry(1.5, 3, 0.3);
                        const symbol = new THREE.Mesh(symbolGeo, ringMat.clone());
                        symbol.position.x = Math.cos(sAngle) * radius;
                        symbol.position.z = Math.sin(sAngle) * radius;
                        symbol.rotation.y = -sAngle;
                        circleGroup.add(symbol);
                    }
                    
                    circleGroup.position.z = -5 - i * 5;
                    circleGroup.userData.speed = (i % 2 === 0 ? 1 : -1) * (0.5 + i * 0.2);
                    this.magicCircles.push(circleGroup);
                    this.group.add(circleGroup);
                });
                
                // ÊöóÈªí„Ç™„Éº„É©Ôºà‰∫åÈáçÔºâ
                const innerAuraGeo = new THREE.SphereGeometry(35, 32, 32);
                const innerAuraMat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.BackSide
                });
                this.innerAura = new THREE.Mesh(innerAuraGeo, innerAuraMat);
                this.group.add(this.innerAura);
                
                const outerAuraGeo = new THREE.SphereGeometry(50, 32, 32);
                const outerAuraMat = new THREE.MeshBasicMaterial({
                    color: 0x4400ff,
                    transparent: true,
                    opacity: 0.08,
                    side: THREE.BackSide
                });
                this.outerAura = new THREE.Mesh(outerAuraGeo, outerAuraMat);
                this.group.add(this.outerAura);
                
                // ÁµÇÁÑâ„ÅÆÁøºÔºà4ÊûöÔºâ
                this.doomWings = [];
                for (let i = 0; i < 4; i++) {
                    const wing = this.createDoomWing(i);
                    this.doomWings.push(wing);
                    this.group.add(wing);
                }
                
                this.group.position.copy(this.position);
                this.scene.add(this.group);
            }
            
            createEvilEye(size) {
                const group = new THREE.Group();
                
                // Âº∑ËÜúÔºàÁôΩÁõÆÔºâ
                const scleraGeo = new THREE.SphereGeometry(size, 16, 16);
                const scleraMat = new THREE.MeshStandardMaterial({
                    color: 0x331111,
                    emissive: 0x220000,
                    emissiveIntensity: 0.3
                });
                const sclera = new THREE.Mesh(scleraGeo, scleraMat);
                group.add(sclera);
                
                // ËôπÂΩ©ÔºàËº™Ôºâ
                const irisGeo = new THREE.TorusGeometry(size * 0.6, size * 0.15, 8, 24);
                const irisMat = new THREE.MeshBasicMaterial({
                    color: 0xff0066
                });
                const iris = new THREE.Mesh(irisGeo, irisMat);
                iris.position.z = size * 0.5;
                group.add(iris);
                
                // Áû≥Â≠îÔºàÁ∏¶Èï∑Ôºâ
                const pupilGeo = new THREE.SphereGeometry(size * 0.35, 8, 16);
                pupilGeo.scale(0.3, 1, 0.5);
                const pupilMat = new THREE.MeshBasicMaterial({
                    color: 0x000000
                });
                const pupil = new THREE.Mesh(pupilGeo, pupilMat);
                pupil.position.z = size * 0.7;
                group.add(pupil);
                
                // ÂÜÖÈÉ®„ÅÆÂÖâ
                const glowGeo = new THREE.SphereGeometry(size * 0.2, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.z = size * 0.65;
                group.add(glow);
                
                return group;
            }
            
            createVoidTentacle() {
                const group = new THREE.Group();
                const segments = 16;
                
                for (let i = 0; i < segments; i++) {
                    const size = 3.5 - i * 0.18;
                    const segGroup = new THREE.Group();
                    
                    // „É°„Ç§„É≥„Çª„Ç∞„É°„É≥„Éà
                    const geo = new THREE.DodecahedronGeometry(size, 0);
                    const mat = new THREE.MeshStandardMaterial({
                        color: 0x330033,
                        emissive: 0x440044,
                        emissiveIntensity: 0.4 + (i / segments) * 0.4
                    });
                    const seg = new THREE.Mesh(geo, mat);
                    segGroup.add(seg);
                    
                    // Ê£ò
                    if (i % 2 === 0) {
                        for (let j = 0; j < 3; j++) {
                            const spikeAngle = (j / 3) * Math.PI * 2;
                            const spikeGeo = new THREE.ConeGeometry(0.5, 2, 4);
                            const spike = new THREE.Mesh(spikeGeo, mat.clone());
                            spike.position.x = Math.cos(spikeAngle) * size;
                            spike.position.y = Math.sin(spikeAngle) * size;
                            spike.rotation.z = -spikeAngle - Math.PI / 2;
                            segGroup.add(spike);
                        }
                    }
                    
                    segGroup.position.z = -i * 5;
                    group.add(segGroup);
                }
                
                // ÂÖàÁ´Ø„ÅÆÁà™
                const clawGeo = new THREE.ConeGeometry(1.5, 6, 4);
                const clawMat = new THREE.MeshStandardMaterial({
                    color: 0x660066,
                    emissive: 0xff00ff,
                    emissiveIntensity: 0.8
                });
                const claw = new THREE.Mesh(clawGeo, clawMat);
                claw.position.z = -segments * 5 - 3;
                claw.rotation.x = -Math.PI / 2;
                group.add(claw);
                
                return group;
            }
            
            createDoomWing(index) {
                const group = new THREE.Group();
                const isRight = index < 2;
                const isUpper = index % 2 === 0;
                
                // Áøº„ÅÆÈ™®Ê†º
                const boneCount = 5;
                for (let i = 0; i < boneCount; i++) {
                    const boneGeo = new THREE.CylinderGeometry(0.8 - i * 0.1, 0.3, 15 - i * 2, 6);
                    const boneMat = new THREE.MeshStandardMaterial({
                        color: 0x220022,
                        emissive: 0x440044,
                        emissiveIntensity: 0.5
                    });
                    const bone = new THREE.Mesh(boneGeo, boneMat);
                    bone.position.x = (isRight ? 1 : -1) * (8 + i * 6);
                    bone.position.y = (isUpper ? 1 : -1) * i * 2;
                    bone.position.z = -5 - i;
                    bone.rotation.z = (isRight ? -1 : 1) * (0.3 + i * 0.15);
                    bone.rotation.x = (isUpper ? -1 : 1) * 0.2;
                    group.add(bone);
                }
                
                // ÁøºËÜúÔºàÈÄèÊòé„Å™„Ç®„Éç„É´„ÇÆ„ÉºÔºâ
                const wingShape = new THREE.Shape();
                wingShape.moveTo(0, 0);
                wingShape.lineTo((isRight ? 1 : -1) * 35, (isUpper ? 1 : -1) * 5);
                wingShape.lineTo((isRight ? 1 : -1) * 30, (isUpper ? 1 : -1) * 20);
                wingShape.lineTo((isRight ? 1 : -1) * 20, (isUpper ? 1 : -1) * 15);
                wingShape.lineTo((isRight ? 1 : -1) * 10, (isUpper ? 1 : -1) * 12);
                wingShape.lineTo(0, 0);
                
                const membraneGeo = new THREE.ShapeGeometry(wingShape);
                const membraneMat = new THREE.MeshBasicMaterial({
                    color: 0x8800ff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const membrane = new THREE.Mesh(membraneGeo, membraneMat);
                membrane.position.z = -8;
                group.add(membrane);
                
                group.userData.isRight = isRight;
                group.userData.isUpper = isUpper;
                
                return group;
            }
            
            getCollisionRadius() { return 25; }
            
            takeDamage(amount, fromBomb = false) {
                const actualDamage = fromBomb ? Math.min(amount, 500) : amount;
                this.health -= actualDamage;
                this.flashDamage();
                
                // „Éï„Çß„Éº„Ç∫Â§âÂåñ
                const healthPercent = this.health / this.maxHealth;
                if (healthPercent <= 0.3 && this.phase < 3) {
                    this.phase = 3;
                    this.rageMode = true;
                } else if (healthPercent <= 0.6 && this.phase < 2) {
                    this.phase = 2;
                }
                
                if (this.health <= 0) {
                    this.health = 0;
                    this.alive = false;
                    return true;
                }
                return false;
            }
            
            flashDamage() {
                this.core.material.emissiveIntensity = 3.0;
                this.dimensionCores.forEach(c => {
                    c.children[0].material.emissiveIntensity = 2.0;
                    c.children[1].material.opacity = 1.0;
                });
                setTimeout(() => {
                    this.core.material.emissiveIntensity = 1.0;
                    this.dimensionCores.forEach(c => {
                        c.children[0].material.emissiveIntensity = 1.2;
                        c.children[1].material.opacity = 0.9;
                    });
                }, 100);
            }
            
            update(deltaTime, projectiles) {
                if (!this.alive) return;
                
                this.time += deltaTime;
                this.attackTimer += deltaTime;
                this.moveTimer += deltaTime;
                
                // „Éï„Çß„Éº„Ç∫„Å´Âøú„Åò„Åü3DÁ©∫Èñì„Åß„ÅÆË§áÈõë„Å™ÁßªÂãï
                const speed = this.rageMode ? 1.8 : 1.0;
                const t = this.time * speed;
                
                // ÁßªÂãï„Éï„Çß„Éº„Ç∫„ÅÆÂàá„ÇäÊõø„Åà
                const movePhase = Math.floor(this.moveTimer / 5) % 8;
                
                switch(movePhase) {
                    case 0: // ÂÖ´„ÅÆÂ≠óÈ£õË°å
                        this.position.x = Math.sin(t * 0.5) * 35;
                        this.position.y = Math.sin(t) * 18;
                        this.position.z = -75 + Math.cos(t * 0.3) * 15;
                        break;
                    case 1: // ÊÄ•Èôç‰∏ã„ÉªÊÄ•‰∏äÊòá
                        this.position.x = Math.sin(t * 0.7) * 25;
                        this.position.y = Math.sin(t * 2) * 25;
                        this.position.z = -70 + Math.sin(t * 0.4) * 20;
                        break;
                    case 2: // Ëû∫ÊóãÈôç‰∏ã
                        this.position.x = Math.cos(t * 1.5) * (20 + Math.sin(t * 0.3) * 10);
                        this.position.y = Math.sin(t * 1.5) * (20 + Math.cos(t * 0.3) * 10);
                        this.position.z = -60 + Math.sin(t * 0.5) * 25;
                        break;
                    case 3: // Áû¨ÈñìÁßªÂãïÈ¢®„ÅÆÈ´òÈÄüÁßªÂãï
                        const targetX = Math.sin(t * 3) * 30;
                        const targetY = Math.cos(t * 2.5) * 20;
                        this.position.x += (targetX - this.position.x) * 0.1;
                        this.position.y += (targetY - this.position.y) * 0.1;
                        this.position.z = -65 + Math.sin(t * 0.6) * 15;
                        break;
                    case 4: // „Éó„É¨„Ç§„É§„ÉºËøΩË∑°
                        if (this.player) {
                            this.targetPos.copy(this.player.position);
                            this.targetPos.z -= 40;
                            this.position.lerp(this.targetPos, deltaTime * 0.5);
                        }
                        break;
                    case 5: // Â∑®Â§ß„Å™ÂÜÜÈÅãÂãïÔºàÂ®ÅÂúßÔºâ
                        this.position.x = Math.sin(t * 0.4) * 40;
                        this.position.y = Math.cos(t * 0.4) * 30;
                        this.position.z = -80 + Math.sin(t * 0.2) * 10;
                        break;
                    case 6: // ÈÅ†„Åè„Å∏Á¥†Êó©„ÅèÈÄÉ„Åí„ÇãÔºàÊ¨°ÂÖÉË∑≥Ë∫çÈ¢®Ôºâ
                        this.targetPos.set(
                            (Math.random() - 0.5) * 60,
                            (Math.random() - 0.5) * 40,
                            -150
                        );
                        this.position.lerp(this.targetPos, deltaTime * 5.0);
                        break;
                    case 7: // Ê¨°ÂÖÉ„ÇíË∂Ö„Åà„Å¶Êàª„Å£„Å¶„Åè„ÇãÔºà„ÉØ„Éº„ÉóÈ¢®Ôºâ
                        this.targetPos.set(
                            Math.sin(t) * 30,
                            Math.cos(t * 0.8) * 20,
                            -55
                        );
                        this.position.lerp(this.targetPos, deltaTime * 3.5);
                        break;
                }
                
                // Ê¨°ÂÖÉ„Ç∑„Éº„É´„Éâ„ÅÆÂõûËª¢„Å®ËÑàÂãï
                this.shields.forEach((shield, i) => {
                    shield.rotation.x += deltaTime * (0.2 + i * 0.1) * (i % 2 === 0 ? 1 : -1);
                    shield.rotation.y += deltaTime * (0.25 + i * 0.05);
                    shield.rotation.z += deltaTime * (0.15 - i * 0.02);
                    const shieldPulse = 1 + Math.sin(this.time * 3 + i) * 0.08;
                    shield.scale.setScalar(shieldPulse);
                    shield.material.opacity = (this.rageMode ? 0.5 : 0.3) - i * 0.05 + Math.sin(this.time * 4 + i) * 0.15;
                });
                
                // Ê¨°ÂÖÉÊ†∏„ÅÆÂõûËª¢„Å®ËÑàÂãï
                this.dimensionCores.forEach((core, i) => {
                    core.rotation.x = this.time * (1.5 + i * 0.4) * (i % 2 === 0 ? 1 : -1);
                    core.rotation.y = this.time * (1.2 + i * 0.3);
                    core.rotation.z = this.time * 0.8 * (i % 2 === 0 ? 1 : -1);
                    const pulse = 1 + Math.sin(this.time * (5 + i) + i) * 0.2;
                    core.scale.setScalar(pulse);
                    // ÊÄí„Çä„É¢„Éº„Éâ„Åß„Çà„ÇäÊøÄ„Åó„ÅèËÑàÂãï
                    if (this.rageMode) {
                        core.children[0].material.emissiveIntensity = 1.5 + Math.sin(this.time * 10) * 0.5;
                    }
                });
                
                // ÁéãÂÜ†„ÅÆËßí„ÅÆËÑàÂãï„Å®ÂõûËª¢
                this.crownHorns.forEach((horn, i) => {
                    const tip = horn.children[2];
                    const pulse = 0.8 + Math.sin(this.time * 6 + i * 0.5) * 0.5;
                    tip.scale.setScalar(pulse);
                    tip.material.opacity = 0.7 + Math.sin(this.time * 7 + i) * 0.3;
                    
                    // ËßíÂÖ®‰Ωì„ÅÆÂæÆÂãï
                    horn.rotation.x += Math.sin(this.time * 3 + i) * 0.005;
                    horn.rotation.y += Math.cos(this.time * 2.5 + i) * 0.003;
                    
                    if (this.rageMode) {
                        horn.rotation.x += Math.sin(this.time * 25 + i) * 0.03;
                    }
                });
                
                // ÈÇ™Áúº„ÅÆÂãï„ÅçÔºà„Éó„É¨„Ç§„É§„ÉºËøΩË∑° + ËÑàÂãïÔºâ
                this.evilEyes.forEach((eye, i) => {
                    if (this.player) {
                        const dir = new THREE.Vector3()
                            .subVectors(this.player.position, this.position)
                            .normalize();
                        eye.lookAt(this.position.clone().add(dir.multiplyScalar(50)));
                    }
                    const pupil = eye.children[2];
                    const pupilScale = 0.7 + Math.sin(this.time * 5 + i) * 0.25;
                    pupil.scale.y = pupilScale;
                    
                    const glow = eye.children[3];
                    glow.material.opacity = 0.6 + Math.sin(this.time * 7 + i * 0.5) * 0.4;
                    
                    // ËôπÂΩ©„ÅÆÂõûËª¢
                    const iris = eye.children[1];
                    iris.rotation.z = this.time * (0.5 + i * 0.1);
                });
                
                // ËôöÁ©∫Ëß¶Êâã„ÅÆÊúâÊ©üÁöÑ„Å™„ÅÜ„Å≠„Çä
                this.voidTentacles.forEach((t, i) => {
                    const baseAngle = t.userData.angle + this.time * 0.3;
                    t.position.x = Math.cos(baseAngle) * (14 + Math.sin(this.time * 2 + i) * 3);
                    t.position.y = Math.sin(baseAngle) * (14 + Math.cos(this.time * 1.8 + i) * 3);
                    
                    t.children.forEach((seg, j) => {
                        if (j < t.children.length - 1) {
                            const wave = Math.sin(this.time * 5 + i * 0.6 + j * 0.4) * (j + 1) * 0.8;
                            const wave2 = Math.cos(this.time * 4 + i * 0.4 + j * 0.3) * (j + 1) * 0.6;
                            const wave3 = Math.sin(this.time * 3 + j * 0.5) * (j * 0.3);
                            seg.position.x = wave;
                            seg.position.y = wave2;
                            seg.position.z = -j * 5 + wave3;
                            seg.rotation.z = Math.sin(this.time * 3 + j * 0.25) * 0.3;
                            seg.rotation.x = Math.cos(this.time * 2.5 + j * 0.2) * 0.2;
                        }
                    });
                });
                
                // È≠îÊ≥ïÈô£„ÅÆÂõûËª¢
                this.magicCircles.forEach((circle, i) => {
                    circle.rotation.y = this.time * circle.userData.speed * (this.rageMode ? 2.5 : 1);
                    circle.position.z = -5 - i * 5 + Math.sin(this.time * 2 + i) * 2;
                    circle.children.forEach((child, j) => {
                        if (j > 0) {
                            child.material.opacity = 0.5 + Math.sin(this.time * 4 + j * 0.3) * 0.4;
                        }
                    });
                });
                
                // „Ç™„Éº„É©„ÅÆËÑàÂãï
                const innerAuraPulse = 1 + Math.sin(this.time * 2.5) * 0.12;
                const outerAuraPulse = 1 + Math.sin(this.time * 2 + 0.5) * 0.18;
                this.innerAura.scale.setScalar(innerAuraPulse);
                this.outerAura.scale.setScalar(outerAuraPulse);
                this.innerAura.material.opacity = this.rageMode ? 0.25 : 0.12;
                this.outerAura.material.opacity = this.rageMode ? 0.2 : 0.1;
                
                // ÁµÇÁÑâ„ÅÆÁøº„ÅÆÁæΩ„Å∞„Åü„Åç
                this.doomWings.forEach((wing, i) => {
                    const flapSpeed = this.rageMode ? 5 : 2.5;
                    const flapAngle = Math.sin(this.time * flapSpeed + (i < 2 ? 0 : Math.PI)) * 0.4;
                    wing.rotation.z = (wing.userData.isRight ? -1 : 1) * flapAngle;
                    wing.rotation.x = (wing.userData.isUpper ? -1 : 1) * Math.abs(flapAngle) * 0.6;
                    
                    const membrane = wing.children[wing.children.length - 1];
                    membrane.material.opacity = 0.25 + Math.abs(flapAngle) * 0.35;
                });
                
                // „Ç≥„Ç¢„ÅÆÂõûËª¢
                this.core.rotation.x += deltaTime * 0.4;
                this.core.rotation.y += deltaTime * 0.5;
                this.core.rotation.z += deltaTime * 0.3;
                
                // ÊîªÊíÉ„Éë„Çø„Éº„É≥Ôºà„Éï„Çß„Éº„Ç∫„ÅßÊøÄÂåñÔºâ
                const attackInterval = this.phase === 3 ? 0.6 : (this.phase === 2 ? 1.0 : 1.5);
                if (this.attackTimer > attackInterval) {
                    this.attack(projectiles);
                    this.attackTimer = 0;
                }
                
                // ÁâπÊÆäÊîªÊíÉÔºàËß¶ÊâãËñô„ÅéÊâï„ÅÑÔºâ
                if (Math.floor(this.time) % 5 === 0 && Math.floor(this.time * 10) % 10 === 0) {
                    this.voidTentacleSlash(projectiles);
                }
                
                // ÁâπÊÆäÊîªÊíÉÔºàÊ¨°ÂÖÉÊ†∏„Éì„Éº„É†Ôºâ- ÊÄí„Çä„É¢„Éº„Éâ„ÅÆ„Åø
                if (this.rageMode && Math.floor(this.time) % 4 === 0 && Math.floor(this.time * 10) % 10 === 0) {
                    this.dimensionCoreBeam(projectiles);
                }
                
                this.group.position.copy(this.position);
                this.group.rotation.y = Math.sin(this.time * 0.3) * 0.1;
            }
            
            attack(projectiles) {
                const patterns = this.rageMode ? 6 : this.phase + 2;
                const pattern = Math.floor(Math.random() * patterns);
                
                if (pattern === 0) {
                    // ÈÇ™Áúº„Åã„Çâ„ÅÆÂÖ®Êñπ‰ΩçÂºæÂπï
                    this.evilEyes.forEach((eye, ei) => {
                        const eyePos = this.position.clone().add(eye.position);
                        const bulletCount = ei === 0 ? 16 : 10;
                        for (let i = 0; i < bulletCount; i++) {
                            const angle = (i / bulletCount) * Math.PI * 2 + this.time;
                            const dir = new THREE.Vector3(
                                Math.sin(angle) * 0.6,
                                Math.cos(angle) * 0.6,
                                1
                            ).normalize();
                            
                            const proj = new Projectile(this.scene, eyePos.clone(), dir, false);
                            proj.damage = 10;
                            proj.speed = 55;
                            projectiles.push(proj);
                        }
                    });
                } else if (pattern === 1) {
                    // ‰∏âÈáçËû∫ÊóãÂºæÂπï
                    for (let spiral = 0; spiral < 3; spiral++) {
                        for (let i = 0; i < 20; i++) {
                            const angle = (i / 20) * Math.PI * 2 + this.time * 2.5 + spiral * (Math.PI * 2 / 3);
                            const height = (i / 20 - 0.5) * 2;
                            const dir = new THREE.Vector3(
                                Math.sin(angle) * 0.7,
                                height * 0.4,
                                1
                            ).normalize();
                            
                            const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                            proj.damage = 12;
                            proj.speed = 60;
                            projectiles.push(proj);
                        }
                    }
                } else if (pattern === 2) {
                    // ËôöÁ©∫Ëß¶Êâã„Åã„Çâ„ÅÆÈõÜ‰∏≠Á†≤ÁÅ´
                    this.voidTentacles.forEach((t, i) => {
                        if (this.player) {
                            const tentacleEnd = this.position.clone();
                            tentacleEnd.x += Math.cos(t.userData.angle) * 14;
                            tentacleEnd.y += Math.sin(t.userData.angle) * 14;
                            tentacleEnd.z -= 75;
                            
                            const dir = new THREE.Vector3()
                                .subVectors(this.player.position, tentacleEnd)
                                .normalize();
                            
                            // 3Áô∫„Åö„Å§Áô∫Â∞Ñ
                            for (let j = 0; j < 3; j++) {
                                setTimeout(() => {
                                    if (!this.alive) return;
                                    const proj = new Projectile(this.scene, tentacleEnd.clone(), dir.clone(), false);
                                    proj.damage = 15;
                                    proj.speed = 70;
                                    projectiles.push(proj);
                                }, j * 100);
                            }
                        }
                    });
                } else if (pattern === 3) {
                    // È≠îÊ≥ïÈô£„Åã„Çâ„ÅÆÂÜÜÂΩ¢ÂºæÂπïÔºàÂõûËª¢ÂºèÔºâ
                    this.magicCircles.forEach((circle, ci) => {
                        const radius = [25, 32, 40][ci];
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2 + circle.rotation.y;
                            const startPos = this.position.clone();
                            startPos.x += Math.cos(angle) * radius;
                            startPos.y += Math.sin(angle) * radius * 0.5;
                            startPos.z += -5 - ci * 5;
                            
                            const dir = new THREE.Vector3(
                                Math.sin(angle) * 0.2,
                                Math.cos(angle) * 0.2,
                                1
                            ).normalize();
                            const proj = new Projectile(this.scene, startPos, dir, false);
                            proj.damage = 10;
                            proj.speed = 50;
                            projectiles.push(proj);
                        }
                    });
                } else if (pattern === 4 && this.phase >= 2) {
                    // ÁéãÂÜ†„Åã„Çâ„ÅÆ„É¨„Éº„Ç∂„ÉºÂºæ
                    this.crownHorns.forEach((horn, i) => {
                        const hornWorldPos = new THREE.Vector3();
                        horn.children[2].getWorldPosition(hornWorldPos);
                        
                        if (this.player) {
                            const dir = new THREE.Vector3()
                                .subVectors(this.player.position, hornWorldPos)
                                .normalize();
                            
                            const proj = new Projectile(this.scene, hornWorldPos.clone(), dir, false);
                            proj.damage = 18;
                            proj.speed = 80;
                            projectiles.push(proj);
                        }
                    });
                } else if (pattern === 5 && this.rageMode) {
                    // ÁµÇÁÑâ„ÅÆÂÖ®Êñπ‰ΩçÊîªÊíÉÔºà„Åï„Çâ„Å´ÊøÄÂåñÔºâ
                    for (let layer = 0; layer < 3; layer++) {
                        for (let i = 0; i < 36; i++) {
                            const angle = (i / 36) * Math.PI * 2 + layer * 0.2;
                            const vAngle = (layer - 1) * 0.3;
                            const dir = new THREE.Vector3(
                                Math.sin(angle) * Math.cos(vAngle),
                                Math.sin(vAngle) * 0.6,
                                Math.cos(angle) * 0.5 + 0.5
                            ).normalize();
                            
                            const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                            proj.damage = 8;
                            proj.speed = 45 + layer * 5;
                            projectiles.push(proj);
                        }
                    }
                }
            }
            
            // ÁâπÊÆäÊîªÊíÉÔºöËôöÁ©∫Ëß¶Êâã„ÅÆËñô„ÅéÊâï„ÅÑ
            voidTentacleSlash(projectiles) {
                // ÂÖ®Ëß¶Êâã„Åã„ÇâÂºß„ÇíÊèè„Åè„Çà„ÅÜ„Å´Âºæ„ÇíÁô∫Â∞Ñ
                this.voidTentacles.forEach((t, ti) => {
                    const tentacleEnd = this.position.clone();
                    tentacleEnd.x += Math.cos(t.userData.angle) * 14;
                    tentacleEnd.y += Math.sin(t.userData.angle) * 14;
                    tentacleEnd.z -= 60;
                    
                    for (let i = 0; i < 6; i++) {
                        const sweepAngle = (i / 6) * Math.PI - Math.PI / 2;
                        const dir = new THREE.Vector3(
                            Math.cos(sweepAngle + t.userData.angle),
                            Math.sin(sweepAngle + t.userData.angle) * 0.5,
                            0.7
                        ).normalize();
                        
                        const proj = new Projectile(this.scene, tentacleEnd.clone(), dir, false);
                        proj.damage = 20;
                        proj.speed = 55;
                        projectiles.push(proj);
                    }
                });
            }
            
            // ÁâπÊÆäÊîªÊíÉÔºöÊ¨°ÂÖÉÊ†∏„Éì„Éº„É†
            dimensionCoreBeam(projectiles) {
                // Ê¨°ÂÖÉÊ†∏„Åã„ÇâÂèéÊùü„Åô„Çã„Éì„Éº„É†
                if (this.player) {
                    const targetDir = new THREE.Vector3()
                        .subVectors(this.player.position, this.position)
                        .normalize();
                    
                    // ÂêÑÊ¨°ÂÖÉÊ†∏„Åã„ÇâÈÄ£Á∂öÂºæ
                    this.dimensionCores.forEach((core, ci) => {
                        for (let i = 0; i < 8; i++) {
                            setTimeout(() => {
                                if (!this.alive) return;
                                const spread = new THREE.Vector3(
                                    (Math.random() - 0.5) * 0.1,
                                    (Math.random() - 0.5) * 0.1,
                                    0
                                );
                                const dir = targetDir.clone().add(spread).normalize();
                                
                                const proj = new Projectile(this.scene, this.position.clone(), dir, false);
                                proj.damage = 25;
                                proj.speed = 90;
                                projectiles.push(proj);
                            }, ci * 50 + i * 30);
                        }
                    });
                }
            }
            
            destroy() {
                if (this.group) {
                    this.scene.remove(this.group);
                }
                this.alive = false;
            }
        }

        // ============================================
        // Explosion Effect Class
        // ============================================
        class Explosion {
            constructor(scene, position, size = 'medium', color = 0xff6600) {
                this.scene = scene;
                this.alive = true;
                this.position = position.clone();
                this.age = 0;
                
                // Size configurations
                const sizeConfig = {
                    small: { scale: 1, particles: 30, duration: 0.5 },
                    medium: { scale: 2, particles: 60, duration: 0.8 },
                    large: { scale: 4, particles: 120, duration: 1.2 },
                    boss: { scale: 8, particles: 250, duration: 2.0 }
                };
                
                const config = sizeConfig[size] || sizeConfig.medium;
                this.scale = config.scale;
                this.duration = config.duration;
                this.particleCount = config.particles;
                this.color = new THREE.Color(color);
                
                this.createExplosion();
            }

            createExplosion() {
                this.particles = [];
                this.meshes = new THREE.Group();
                
                // Core flash
                const flashGeo = new THREE.SphereGeometry(this.scale * 2, 16, 16);
                const flashMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1
                });
                this.flash = new THREE.Mesh(flashGeo, flashMat);
                this.flash.position.copy(this.position);
                this.scene.add(this.flash);
                
                // Particle debris
                for (let i = 0; i < this.particleCount; i++) {
                    const isDebris = Math.random() < 0.3;
                    const particle = {
                        position: this.position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 50 * this.scale,
                            (Math.random() - 0.5) * 50 * this.scale,
                            (Math.random() - 0.5) * 50 * this.scale
                        ),
                        size: (isDebris ? 0.3 : 0.15) * this.scale * (0.5 + Math.random()),
                        life: 0,
                        maxLife: this.duration * (0.5 + Math.random() * 0.5),
                        isDebris: isDebris,
                        rotationSpeed: new THREE.Vector3(
                            Math.random() * 10,
                            Math.random() * 10,
                            Math.random() * 10
                        )
                    };
                    
                    // Create mesh
                    let geo, mat;
                    if (isDebris) {
                        geo = new THREE.TetrahedronGeometry(particle.size);
                        mat = new THREE.MeshBasicMaterial({
                            color: this.color,
                            transparent: true,
                            opacity: 1
                        });
                    } else {
                        geo = new THREE.SphereGeometry(particle.size, 4, 4);
                        const fireColor = new THREE.Color().lerpColors(
                            new THREE.Color(0xffff00),
                            this.color,
                            Math.random()
                        );
                        mat = new THREE.MeshBasicMaterial({
                            color: fireColor,
                            transparent: true,
                            opacity: 1
                        });
                    }
                    
                    particle.mesh = new THREE.Mesh(geo, mat);
                    particle.mesh.position.copy(particle.position);
                    this.meshes.add(particle.mesh);
                    this.particles.push(particle);
                }
                
                this.scene.add(this.meshes);
                
                // Shockwave ring
                this.createShockwave();
            }

            createShockwave() {
                const ringGeo = new THREE.RingGeometry(0.1, this.scale * 0.5, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: this.color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                this.shockwave = new THREE.Mesh(ringGeo, ringMat);
                this.shockwave.position.copy(this.position);
                this.shockwave.rotation.x = Math.PI / 2;
                this.scene.add(this.shockwave);
            }

            update(deltaTime) {
                if (!this.alive) return;
                
                this.age += deltaTime;
                const progress = this.age / this.duration;
                
                if (progress >= 1) {
                    this.destroy();
                    return;
                }
                
                // Update flash
                if (this.flash) {
                    const flashProgress = Math.min(1, this.age / 0.1);
                    this.flash.scale.setScalar(1 + flashProgress * 3);
                    this.flash.material.opacity = 1 - flashProgress;
                    
                    if (flashProgress >= 1) {
                        this.scene.remove(this.flash);
                        this.flash = null;
                    }
                }
                
                // Update particles
                this.particles.forEach(p => {
                    p.life += deltaTime;
                    const lifeProgress = p.life / p.maxLife;
                    
                    if (lifeProgress < 1) {
                        // Apply gravity and drag
                        p.velocity.multiplyScalar(0.98);
                        p.velocity.y -= deltaTime * 10;
                        
                        // Move particle
                        p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
                        p.mesh.position.copy(p.position);
                        
                        // Rotate debris
                        if (p.isDebris) {
                            p.mesh.rotation.x += p.rotationSpeed.x * deltaTime;
                            p.mesh.rotation.y += p.rotationSpeed.y * deltaTime;
                        }
                        
                        // Fade out
                        p.mesh.material.opacity = 1 - lifeProgress;
                        p.mesh.scale.setScalar(1 - lifeProgress * 0.5);
                    } else {
                        p.mesh.visible = false;
                    }
                });
                
                // Update shockwave
                if (this.shockwave) {
                    const shockProgress = progress * 2;
                    if (shockProgress < 1) {
                        const scale = 1 + shockProgress * 20 * this.scale;
                        this.shockwave.scale.setScalar(scale);
                        this.shockwave.material.opacity = 0.8 * (1 - shockProgress);
                    } else {
                        this.scene.remove(this.shockwave);
                        this.shockwave = null;
                    }
                }
            }

            destroy() {
                this.alive = false;
                
                if (this.flash) {
                    this.scene.remove(this.flash);
                }
                if (this.meshes) {
                    this.scene.remove(this.meshes);
                }
                if (this.shockwave) {
                    this.scene.remove(this.shockwave);
                }
            }
        }

        // ============================================
        // Screen Shake Manager
        // ============================================
        class ScreenShake {
            constructor() {
                this.intensity = 0;
                this.duration = 0;
                this.elapsed = 0;
                this.offset = new THREE.Vector3();
            }

            shake(intensity, duration) {
                this.intensity = Math.max(this.intensity, intensity);
                this.duration = Math.max(this.duration, duration);
                this.elapsed = 0;
            }

            update(deltaTime) {
                if (this.duration <= 0) {
                    this.offset.set(0, 0, 0);
                    return this.offset;
                }
                
                this.elapsed += deltaTime;
                
                if (this.elapsed >= this.duration) {
                    this.duration = 0;
                    this.intensity = 0;
                    this.offset.set(0, 0, 0);
                    return this.offset;
                }
                
                const remaining = 1 - (this.elapsed / this.duration);
                const shake = this.intensity * remaining;
                
                this.offset.set(
                    (Math.random() - 0.5) * shake,
                    (Math.random() - 0.5) * shake,
                    (Math.random() - 0.5) * shake * 0.5
                );
                
                return this.offset;
            }
        }

        // ============================================
        // VFX Manager
        // ============================================
        class VFXManager {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.audioManager = null; // Set externally
                this.explosions = [];
                this.muzzleFlashes = [];
                this.killMarkers = [];
                this.screenShake = new ScreenShake();
                this.slowMotion = 1.0;
                this.slowMotionTarget = 1.0;
                this.damageIndicator = new DamageIndicator();
            }

            createExplosion(position, size = 'medium', color = 0xff6600) {
                const explosion = new Explosion(this.scene, position, size, color);
                this.explosions.push(explosion);
                
                // Play explosion sound
                if (this.audioManager && size !== 'small') {
                    this.audioManager.playExplosion(size);
                }
                
                // Screen shake based on size
                const shakeConfig = {
                    small: { intensity: 0.3, duration: 0.2 },
                    medium: { intensity: 0.8, duration: 0.3 },
                    large: { intensity: 1.5, duration: 0.5 },
                    boss: { intensity: 3, duration: 1.0 }
                };
                
                const shake = shakeConfig[size] || shakeConfig.medium;
                this.screenShake.shake(shake.intensity, shake.duration);
                
                // Slow motion for large explosions
                if (size === 'large' || size === 'boss') {
                    this.triggerSlowMotion(0.3, 0.5);
                }
            }

            triggerSlowMotion(scale, duration) {
                this.slowMotionTarget = scale;
                setTimeout(() => {
                    this.slowMotionTarget = 1.0;
                }, duration * 1000);
            }

            update(deltaTime) {
                // Update explosions
                this.explosions.forEach(exp => exp.update(deltaTime));
                this.explosions = this.explosions.filter(exp => exp.alive);
                
                // Update muzzle flashes
                this.muzzleFlashes.forEach(flash => flash.update(deltaTime));
                this.muzzleFlashes = this.muzzleFlashes.filter(flash => flash.alive);
                
                // Update kill markers
                this.killMarkers.forEach(marker => marker.update(deltaTime));
                this.killMarkers = this.killMarkers.filter(marker => marker.alive);
                
                // Update slow motion
                this.slowMotion += (this.slowMotionTarget - this.slowMotion) * deltaTime * 5;
            }

            createMuzzleFlash(position, direction, color = 0x00ffff) {
                const flash = new MuzzleFlash(this.scene, position, direction, color);
                this.muzzleFlashes.push(flash);
            }

            createKillMarker(position) {
                const marker = new KillMarker(this.scene, position, this.camera);
                this.killMarkers.push(marker);
            }

            showDamageDirection(fromPosition, playerPosition) {
                const direction = fromPosition.clone().sub(playerPosition).normalize();
                this.damageIndicator.show(direction, this.camera);
            }

            getShakeOffset() {
                return this.screenShake.offset;
            }

            updateShake(deltaTime) {
                return this.screenShake.update(deltaTime);
            }

            getTimeScale() {
                return this.slowMotion;
            }
        }

        // ============================================
        // Muzzle Flash Effect
        // ============================================
        class MuzzleFlash {
            constructor(scene, position, direction, color) {
                this.scene = scene;
                this.alive = true;
                this.age = 0;
                this.duration = 0.08;
                
                this.createFlash(position, direction, color);
            }

            createFlash(position, direction, color) {
                this.meshes = new THREE.Group();
                
                // Core flash
                const coreGeo = new THREE.SphereGeometry(0.5, 8, 8);
                const coreMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1
                });
                this.core = new THREE.Mesh(coreGeo, coreMat);
                this.meshes.add(this.core);
                
                // Outer glow
                const glowGeo = new THREE.SphereGeometry(1.2, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6
                });
                this.glow = new THREE.Mesh(glowGeo, glowMat);
                this.meshes.add(this.glow);
                
                // Flash spikes
                const spikeGeo = new THREE.ConeGeometry(0.2, 1.5, 4);
                const spikeMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });
                
                for (let i = 0; i < 6; i++) {
                    const spike = new THREE.Mesh(spikeGeo, spikeMat.clone());
                    const angle = (i / 6) * Math.PI * 2;
                    spike.position.set(
                        Math.cos(angle) * 0.3,
                        Math.sin(angle) * 0.3,
                        0.5
                    );
                    spike.rotation.x = Math.PI / 2;
                    spike.rotation.z = angle;
                    this.meshes.add(spike);
                }
                
                this.meshes.position.copy(position);
                this.meshes.lookAt(position.clone().add(direction));
                this.scene.add(this.meshes);
            }

            update(deltaTime) {
                if (!this.alive) return;
                
                this.age += deltaTime;
                const progress = this.age / this.duration;
                
                if (progress >= 1) {
                    this.destroy();
                    return;
                }
                
                // Fade out
                const opacity = 1 - progress;
                this.core.material.opacity = opacity;
                this.glow.material.opacity = opacity * 0.6;
                
                // Scale up slightly
                const scale = 1 + progress * 0.5;
                this.meshes.scale.setScalar(scale);
            }

            destroy() {
                this.alive = false;
                if (this.meshes) {
                    this.scene.remove(this.meshes);
                }
            }
        }

        // ============================================
        // Kill Marker Effect
        // ============================================
        class KillMarker {
            constructor(scene, position, camera) {
                this.scene = scene;
                this.camera = camera;
                this.alive = true;
                this.age = 0;
                this.duration = 0.6;
                this.position = position.clone();
                
                this.createMarker();
            }

            createMarker() {
                this.group = new THREE.Group();
                
                // X-mark using two crossed lines
                const lineMat = new THREE.LineBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 1,
                    linewidth: 3
                });
                
                // First line of X
                const line1Geo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-1, -1, 0),
                    new THREE.Vector3(1, 1, 0)
                ]);
                this.line1 = new THREE.Line(line1Geo, lineMat);
                this.group.add(this.line1);
                
                // Second line of X
                const line2Geo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-1, 1, 0),
                    new THREE.Vector3(1, -1, 0)
                ]);
                this.line2 = new THREE.Line(line2Geo, lineMat.clone());
                this.group.add(this.line2);
                
                // Circle around X
                const circleGeo = new THREE.RingGeometry(1.3, 1.5, 16);
                const circleMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                this.circle = new THREE.Mesh(circleGeo, circleMat);
                this.group.add(this.circle);
                
                this.group.position.copy(this.position);
                this.scene.add(this.group);
            }

            update(deltaTime) {
                if (!this.alive) return;
                
                this.age += deltaTime;
                const progress = this.age / this.duration;
                
                if (progress >= 1) {
                    this.destroy();
                    return;
                }
                
                // Billboard - face camera
                this.group.lookAt(this.camera.position);
                
                // Animation
                const scaleIn = Math.min(1, progress * 4); // Quick scale in
                const fadeOut = 1 - Math.pow(progress, 2);
                
                this.group.scale.setScalar(scaleIn * 2);
                
                this.line1.material.opacity = fadeOut;
                this.line2.material.opacity = fadeOut;
                this.circle.material.opacity = fadeOut * 0.8;
                
                // Expand circle
                this.circle.scale.setScalar(1 + progress * 0.5);
            }

            destroy() {
                this.alive = false;
                if (this.group) {
                    this.scene.remove(this.group);
                }
            }
        }

        // ============================================
        // Audio Manager - Procedural Sound Generation
        // ============================================
        class AudioManager {
            constructor() {
                this.enabled = true;
                this.masterVolume = 0.5;
                this.sfxVolume = 0.7;
                this.musicVolume = 0.4;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = this.masterVolume;
                    
                    this.sfxGain = this.audioContext.createGain();
                    this.sfxGain.connect(this.masterGain);
                    this.sfxGain.gain.value = this.sfxVolume;
                    
                    this.musicGain = this.audioContext.createGain();
                    this.musicGain.connect(this.masterGain);
                    this.musicGain.gain.value = this.musicVolume;
                    
                    this.initialized = true;
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.initialized = false;
                }
            }

            resume() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }

            // Laser shot sound
            playLaser() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.sfxGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(880, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(220, this.audioContext.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.1);
            }

            // Explosion sound
            playExplosion(size = 'medium') {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                const duration = size === 'large' ? 0.8 : size === 'small' ? 0.2 : 0.4;
                const volume = size === 'large' ? 0.6 : size === 'small' ? 0.2 : 0.4;
                
                // Noise generator
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
                }
                
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                
                // Low-pass filter for rumble
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                filter.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + duration);
                
                const gain = this.audioContext.createGain();
                gain.gain.setValueAtTime(volume, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.sfxGain);
                
                noise.start();
            }

            // Hit sound (bullet hits enemy but doesn't destroy)
            playHit() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.sfxGain);
                
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.1);
            }
            
            // Bullet impact sound (hitting asteroids/enemies)
            playBulletImpact() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                const osc = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(this.sfxGain);
                
                // „É°„Çø„É™„ÉÉ„ÇØ„Å™„Éí„ÉÉ„ÉàÈü≥
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.05);
                
                osc2.type = 'square';
                osc2.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(300, this.audioContext.currentTime + 0.03);
                
                gain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.08);
                
                osc.start();
                osc2.start();
                osc.stop(this.audioContext.currentTime + 0.08);
                osc2.stop(this.audioContext.currentTime + 0.05);
            }
            
            // Enemy/asteroid destroyed sound
            playEnemyDestroyed() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                // Á†¥Â£äÈü≥Ôºö‰ΩéÈü≥„ÅÆÁàÜÁô∫ + È´òÈü≥„ÅÆ„Åç„Çâ„ÇÅ„Åç
                const duration = 0.35;
                
                // ‰ΩéÈü≥„ÅÆÁàÜÁô∫ÈÉ®ÂàÜ
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    const t = i / bufferSize;
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, 1.5) * 0.5;
                }
                
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, this.audioContext.currentTime);
                filter.frequency.exponentialRampToValueAtTime(150, this.audioContext.currentTime + duration);
                
                const noiseGain = this.audioContext.createGain();
                noiseGain.gain.setValueAtTime(0.35, this.audioContext.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(this.sfxGain);
                noise.start();
                
                // È´òÈü≥„ÅÆ„Åç„Çâ„ÇÅ„ÅçÈÉ®ÂàÜÔºà„Çπ„Ç≥„Ç¢Áç≤ÂæóÊÑüÔºâ
                const osc = this.audioContext.createOscillator();
                const oscGain = this.audioContext.createGain();
                
                osc.connect(oscGain);
                oscGain.connect(this.sfxGain);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, this.audioContext.currentTime);
                osc.frequency.setValueAtTime(800, this.audioContext.currentTime + 0.05);
                osc.frequency.setValueAtTime(1000, this.audioContext.currentTime + 0.1);
                
                oscGain.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                oscGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.2);
            }
            
            // Asteroid destroyed sound (slightly different from enemy)
            playAsteroidDestroyed() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                // Â≤©„Å£„ÅΩ„ÅÑÁ†¥Â£äÈü≥
                const duration = 0.25;
                
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    const t = i / bufferSize;
                    // „Çà„ÇäÁ≤ó„ÅÑ„Éé„Ç§„Ç∫
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, 2) * 0.6;
                }
                
                const noise = this.audioContext.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(400, this.audioContext.currentTime);
                filter.Q.value = 1;
                
                const gain = this.audioContext.createGain();
                gain.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.sfxGain);
                noise.start();
            }

            // Player damage sound
            playDamage() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.sfxGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);
                
                gain.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.3);
            }

            // Power-up / combo sound
            playPowerUp() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                gain.connect(this.sfxGain);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.15);
                
                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                osc.start();
                osc.stop(this.audioContext.currentTime + 0.2);
            }

            // Wave start sound
            playWaveStart() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                const notes = [262, 330, 392, 523]; // C4, E4, G4, C5
                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        osc.connect(gain);
                        gain.connect(this.sfxGain);
                        
                        osc.type = 'triangle';
                        osc.frequency.value = freq;
                        
                        gain.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        
                        osc.start();
                        osc.stop(this.audioContext.currentTime + 0.3);
                    }, i * 100);
                });
            }
            
            // Bomb launch soundÔºà„Éú„É†Áô∫Â∞ÑÈü≥Ôºâ
            playBombLaunch() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                // ‰ΩéÈü≥„ÅÆ„Äå„Éâ„Ç•„Éº„É≥„Äç„Å®„ÅÑ„ÅÜÁô∫Â∞ÑÈü≥
                const osc = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(this.sfxGain);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(60, this.audioContext.currentTime + 0.3);
                
                osc2.type = 'sawtooth';
                osc2.frequency.setValueAtTime(100, this.audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(40, this.audioContext.currentTime + 0.3);
                
                gain.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
                
                osc.start();
                osc2.start();
                osc.stop(this.audioContext.currentTime + 0.4);
                osc2.stop(this.audioContext.currentTime + 0.4);
            }
            
            // Power-up pickup soundÔºà„Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÂèñÂæóÈü≥Ôºâ
            playPowerUp() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                // Êòé„Çã„ÅÑ‰∏äÊòáÈü≥
                const osc = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(this.sfxGain);
                
                // „É°„Ç§„É≥Èü≥Ôºà‰∏äÊòáÔºâ
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.2);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.4);
                
                // „Éè„Éº„É¢„Éã„Éº
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(600, this.audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(1800, this.audioContext.currentTime + 0.2);
                osc2.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.4);
                
                gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                
                osc.start();
                osc2.start();
                osc.stop(this.audioContext.currentTime + 0.5);
                osc2.stop(this.audioContext.currentTime + 0.5);
            }
            
            // Health pickup soundÔºàHPÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†ÂèñÂæóÈü≥Ôºâ
            playHealthPickup() {
                if (!this.initialized || !this.enabled) return;
                this.resume();
                
                // ÂÑ™„Åó„ÅÑÂõûÂæ©Èü≥ÔºàÁ∑ë„Å£„ÅΩ„ÅÑ„Ç§„É°„Éº„Ç∏Ôºâ
                const osc = this.audioContext.createOscillator();
                const osc2 = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(this.sfxGain);
                
                // Á©è„ÇÑ„Åã„Å™‰∏äÊòáÈü≥
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.15);
                osc.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.3);
                osc.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.5);
                
                // „Éè„Éº„É¢„Éã„ÉºÔºà5Â∫¶‰∏äÔºâ
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(450, this.audioContext.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.15);
                osc2.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.3);
                osc2.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.5);
                
                gain.gain.setValueAtTime(0.25, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.6);
                
                osc.start();
                osc2.start();
                osc.stop(this.audioContext.currentTime + 0.6);
                osc2.stop(this.audioContext.currentTime + 0.6);
            }

            // Engine hum (looping)
            startEngineSound() {
                if (!this.initialized || !this.enabled || this.engineOsc) return;
                this.resume();
                
                this.engineOsc = this.audioContext.createOscillator();
                this.engineGain = this.audioContext.createGain();
                
                this.engineOsc.connect(this.engineGain);
                this.engineGain.connect(this.sfxGain);
                
                this.engineOsc.type = 'sawtooth';
                this.engineOsc.frequency.value = 60;
                this.engineGain.gain.value = 0.05;
                
                this.engineOsc.start();
            }

            stopEngineSound() {
                if (this.engineOsc) {
                    this.engineOsc.stop();
                    this.engineOsc = null;
                }
            }

            setMasterVolume(value) {
                this.masterVolume = value;
                if (this.masterGain) {
                    this.masterGain.gain.value = value;
                }
            }

            toggleSound() {
                this.enabled = !this.enabled;
                return this.enabled;
            }
        }

        // ============================================
        // Damage Direction Indicator
        // ============================================
        class DamageIndicator {
            constructor() {
                this.indicators = [];
                this.container = document.createElement('div');
                this.container.id = 'damage-indicators';
                this.container.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 100;
                `;
                document.body.appendChild(this.container);
            }

            show(direction, camera) {
                // Calculate screen-space angle
                const screenDir = direction.clone().applyQuaternion(camera.quaternion.clone().invert());
                const angle = Math.atan2(screenDir.x, -screenDir.y) * (180 / Math.PI);
                
                const indicator = document.createElement('div');
                indicator.className = 'damage-indicator';
                indicator.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 100px;
                    height: 100px;
                    margin: -50px;
                    transform: rotate(${angle}deg);
                    pointer-events: none;
                `;
                
                const arrow = document.createElement('div');
                arrow.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 0;
                    height: 0;
                    border-left: 15px solid transparent;
                    border-right: 15px solid transparent;
                    border-bottom: 40px solid rgba(255, 0, 0, 0.8);
                    filter: drop-shadow(0 0 10px red);
                    animation: damage-pulse 0.5s ease-out;
                `;
                indicator.appendChild(arrow);
                
                this.container.appendChild(indicator);
                
                // Remove after animation
                setTimeout(() => {
                    indicator.remove();
                }, 500);
            }
        }

        // ============================================
        // Wave Manager
        // ============================================
        class WaveManager {
            constructor(scene, playerRef) {
                this.scene = scene;
                this.player = playerRef;
                
                this.currentWave = 0;
                this.enemiesRemaining = 0;
                this.waveActive = false;
                this.waveDelay = 3;
                this.waveTimer = 0;
                
                // Wave duration system - 3ÂÄç„ÅÆÈï∑„Åï
                this.waveDuration = 0;      // Current wave elapsed time
                this.waveMaxDuration = 90;  // Base wave duration in seconds (Á¥Ñ1.5ÂàÜ)
                this.spawnTimer = 0;        // Timer for spawning enemies
                this.spawnInterval = 4;     // Base spawn interval (Â∫èÁõ§„ÅØÈÅÖ„ÇÅ)
                this.totalSpawned = 0;      // Total spawned this wave
                this.maxSpawnsPerWave = 30; // Base max spawns per wave
                
                // ÊÆµÈöéÁöÑ„Çπ„Éù„Éº„É≥„Ç∑„Çπ„ÉÜ„É†
                this.wavePhase = 0;         // 0: Â∫èÁõ§, 1: ‰∏≠Áõ§, 2: ÁµÇÁõ§
                this.phaseTimer = 0;
                
                // „Éú„Çπ„Ç∑„Çπ„ÉÜ„É†
                this.boss = null;           // ÁèæÂú®„ÅÆ„Éú„Çπ
                this.bossPhase = false;     // „Éú„ÇπÊà¶‰∏≠„Åã„Å©„ÅÜ„Åã
                this.bossDefeated = false;  // „Éú„Çπ„ÇíÂÄí„Åó„Åü„Åã
                this.gameCleared = false;   // „Ç≤„Éº„É†„ÇØ„É™„Ç¢„Éï„É©„Ç∞
                
                this.asteroids = [];
                this.enemies = [];
                this.projectiles = [];
                this.mines = [];
                this.bombs = [];  // „Éú„É†ÈÖçÂàóËøΩÂä†
                this.powerUpItems = [];  // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†ÈÖçÂàó
                this.healthItems = [];   // HPÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†ÈÖçÂàó
                
                this.score = 0;
                this.asteroidsDestroyed = 0;
                this.enemiesDestroyed = 0;
            }

            startWave(waveNumber) {
                this.currentWave = waveNumber;
                this.waveActive = true;
                this.waveDuration = 0;
                this.spawnTimer = 0;
                this.totalSpawned = 0;
                this.wavePhase = 0;
                this.phaseTimer = 0;
                
                // Wave 5‰ª•Èôç„ÅØÁï∞Ê¨°ÂÖÉÁ©∫Èñì„ÅÆËÉåÊôØ„Å´Â§âÊõ¥
                if (waveNumber >= 5 && this.scene) {
                    this.setDimensionalRiftBackground();
                }
                
                // Get difficulty multipliers
                const diff = GameSettings.getDifficultyMultipliers();
                
                // Wave difficulty scaling - 3ÂÄç„ÅÆÈï∑„Åï
                // Wave1: 90s, Wave2: 105s, Wave3: 120s...
                this.waveMaxDuration = 90 + waveNumber * 15;
                
                // „Çπ„Éù„Éº„É≥ÈñìÈöîÔºà„Çà„ÇäÁü≠„ÅèÔºâ- WaveÈÄ≤Ë°å„Åß„Åï„Çâ„Å´Áü≠„Åè
                // Èõ£ÊòìÂ∫¶„Åß„Çπ„Éù„Éº„É≥ÈñìÈöîË™øÊï¥
                this.spawnInterval = Math.max(0.5, (2.5 - waveNumber * 0.2) / diff.spawnRate);
                
                // Max spawns increases with wave (Â§ßÂπÖÂ¢óÂä†)
                this.maxSpawnsPerWave = Math.floor((40 + waveNumber * 20) * diff.spawnRate); // More enemies each wave
                
                // Initial spawn - ÊúÄÂàù„Åã„ÇâÂ§ö„ÇÅ„Å´Âá∫Áèæ
                const initialSpawns = 2 + Math.floor(waveNumber / 2);
                for (let i = 0; i < initialSpawns; i++) {
                    this.spawnRandomEnemy(waveNumber);
                }
                
                this.enemiesRemaining = this.asteroids.length + this.enemies.length;
                
                // „Éú„É†„Çí„É™„Çª„ÉÉ„ÉàÔºàÊØéWaveÈñãÂßãÊôÇ„Å´3ÂÄãÊîØÁµ¶Ôºâ
                if (this.player) {
                    this.player.bombCount = this.player.maxBombs;
                }
                
                // „Éú„Çπ„Éï„Çß„Éº„Ç∫„Çí„É™„Çª„ÉÉ„Éà
                this.bossPhase = false;
                this.bossDefeated = false;
                if (this.boss) {
                    this.boss.destroy();
                    this.boss = null;
                }
                
                // Show wave announcement
                this.showWaveAnnouncement(waveNumber);
                
                // Update UI
                this.updateUI();
            }
            
            spawnRandomEnemy(waveNumber) {
                // Determine what to spawn based on wave and randomness
                const roll = Math.random();
                const pos = this.getSpawnPosition();
                
                // WaveÂà•„ÅÆÂá∫ÁèæÁ¢∫Áéá
                // Wave 1: Fighter, Asteroid
                // Wave 2+: + Bomber, Interceptor, Swarm
                // Wave 3+: + Tank
                // Wave 4+: + Sniper
                // Wave 5+: + Carrier
                
                // Âü∫Êú¨Á¢∫ÁéáÔºàWaveÈÄ≤Ë°å„ÅßÂº∑Êïµ„ÅÆÂá∫ÁèæÁéáUPÔºâ
                const asteroidChance = Math.max(0.2, 0.5 - waveNumber * 0.03);
                const fighterChance = 0.2;
                const interceptorChance = waveNumber >= 2 ? 0.1 + (waveNumber - 2) * 0.02 : 0;
                const swarmChance = waveNumber >= 2 ? 0.15 + (waveNumber - 2) * 0.02 : 0;
                const bomberChance = waveNumber >= 2 ? 0.08 + (waveNumber - 2) * 0.02 : 0;
                const tankChance = waveNumber >= 3 ? 0.06 + (waveNumber - 3) * 0.02 : 0;
                const sniperChance = waveNumber >= 4 ? 0.05 + (waveNumber - 4) * 0.02 : 0;
                const carrierChance = waveNumber >= 5 ? 0.03 + (waveNumber - 5) * 0.015 : 0;
                
                let cumulative = 0;
                
                // Carrier (Wave 5+) - ÊúÄ„ÇÇÂ∏åÂ∞ë
                cumulative += carrierChance;
                if (roll < cumulative && waveNumber >= 5) {
                    const enemy = new EnemyCarrier(this.scene, pos, this.player, waveNumber);
                    this.applyDifficultyToEnemy(enemy);
                    this.enemies.push(enemy);
                    this.totalSpawned++;
                    return;
                }
                
                // Sniper (Wave 4+)
                cumulative += sniperChance;
                if (roll < cumulative && waveNumber >= 4) {
                    const enemy = new EnemySniper(this.scene, pos, this.player, waveNumber);
                    this.applyDifficultyToEnemy(enemy);
                    this.enemies.push(enemy);
                    this.totalSpawned++;
                    return;
                }
                
                // Tank (Wave 3+)
                cumulative += tankChance;
                if (roll < cumulative && waveNumber >= 3) {
                    const enemy = new EnemyTank(this.scene, pos, this.player, waveNumber);
                    this.applyDifficultyToEnemy(enemy);
                    this.enemies.push(enemy);
                    this.totalSpawned++;
                    return;
                }
                
                // Bomber (Wave 2+)
                cumulative += bomberChance;
                if (roll < cumulative && waveNumber >= 2) {
                    const enemy = new EnemyBomber(this.scene, pos, this.player, waveNumber);
                    this.applyDifficultyToEnemy(enemy);
                    this.enemies.push(enemy);
                    this.totalSpawned++;
                    return;
                }
                
                // Swarm (Wave 2+) - Áæ§„Çå„ÅßÂá∫Áèæ
                cumulative += swarmChance;
                if (roll < cumulative && waveNumber >= 2) {
                    // 3-5‰Ωì„ÅÆÁæ§„Çå„Åß„Çπ„Éù„Éº„É≥
                    const swarmSize = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < swarmSize; i++) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 5
                        );
                        const enemy = new EnemySwarm(this.scene, pos.clone().add(offset), this.player, waveNumber);
                        this.applyDifficultyToEnemy(enemy);
                        this.enemies.push(enemy);
                    }
                    this.totalSpawned++;
                    return;
                }
                
                // Interceptor (Wave 2+)
                cumulative += interceptorChance;
                if (roll < cumulative && waveNumber >= 2) {
                    const enemy = new EnemyInterceptor(this.scene, pos, this.player, waveNumber);
                    this.applyDifficultyToEnemy(enemy);
                    this.enemies.push(enemy);
                    this.totalSpawned++;
                    return;
                }
                
                // Fighter
                cumulative += fighterChance;
                if (roll < cumulative) {
                    const enemy = new EnemyFighter(this.scene, pos, this.player, waveNumber);
                    this.applyDifficultyToEnemy(enemy);
                    this.enemies.push(enemy);
                    this.totalSpawned++;
                    return;
                }
                
                // Asteroid („Éá„Éï„Ç©„É´„Éà)
                const sizeRoll = Math.random();
                const size = sizeRoll < 0.2 ? 'large' : (sizeRoll < 0.5 ? 'medium' : 'small');
                const asteroid = new Asteroid(this.scene, pos, size);
                this.applyDifficultyToEnemy(asteroid);
                this.asteroids.push(asteroid);
                this.totalSpawned++;
            }
            
            // Êïµ„Å´Èõ£ÊòìÂ∫¶Ë®≠ÂÆö„ÇíÈÅ©Áî®
            applyDifficultyToEnemy(enemy) {
                const diff = GameSettings.getDifficultyMultipliers();
                
                // HPË™øÊï¥
                if (enemy.health !== undefined) {
                    enemy.health = Math.ceil(enemy.health * diff.enemyHP);
                    enemy.maxHealth = Math.ceil(enemy.maxHealth * diff.enemyHP);
                }
                
                // ÈÄüÂ∫¶Ë™øÊï¥
                if (enemy.speed !== undefined) {
                    enemy.speed *= diff.enemySpeed;
                }
                
                // „Çπ„Ç≥„Ç¢Ë™øÊï¥
                if (enemy.score !== undefined) {
                    enemy.score = Math.ceil(enemy.score * diff.scoreMultiplier);
                }
                
                return enemy;
            }

            getSpawnPosition() {
                // Êïµ„ÅØÂâçÊñπÔºà-ZÊñπÂêëÔºâ„Åã„Çâ„É©„É≥„ÉÄ„É†„Å™‰ΩçÁΩÆ„Å´Âá∫Áèæ
                const x = (Math.random() - 0.5) * 70; // Â∑¶Âè≥„Å´Â∫É„Åå„Çã
                const y = (Math.random() - 0.5) * 35; // ‰∏ä‰∏ã„Å´Â∫É„Åå„Çã
                const z = -100 - Math.random() * 50;  // ÂâçÊñπÈÅ†„Åè„Å´„Çπ„Éù„Éº„É≥Ôºà„Çà„ÇäÈÅ†„ÅèÔºâ
                return new THREE.Vector3(x, y, z);
            }
            
            // „Éú„Çπ„Çí„Çπ„Éù„Éº„É≥
            spawnBoss(waveNumber) {
                // Êó¢Â≠ò„ÅÆ„Éú„Çπ„ÇíÁ†¥Ê£Ñ
                if (this.boss) {
                    this.boss.destroy();
                }
                
                // WaveÁï™Âè∑„Å´Âøú„Åò„Åü„Éú„Çπ„ÇíÁîüÊàêÔºàWave 1-5„Åß„É´„Éº„ÉóÔºâ
                const bossType = ((waveNumber - 1) % 5) + 1;
                
                switch (bossType) {
                    case 1:
                        this.boss = new BossAlien1(this.scene, this.player);
                        break;
                    case 2:
                        this.boss = new BossAlien2(this.scene, this.player);
                        break;
                    case 3:
                        this.boss = new BossAlien3(this.scene, this.player);
                        break;
                    case 4:
                        this.boss = new BossAlien4(this.scene, this.player);
                        break;
                    case 5:
                        this.boss = new BossAlien5(this.scene, this.player);
                        break;
                }
                
                // Èõ£ÊòìÂ∫¶„Çí„Éú„Çπ„Å´ÈÅ©Áî®
                if (this.boss) {
                    this.applyDifficultyToEnemy(this.boss);
                }
                
                // Wave 6‰ª•Èôç„ÅØ„Éú„Çπ„ÅÆHP„ÇíÂ¢óÂä†
                if (waveNumber > 5 && this.boss) {
                    const multiplier = 1 + (Math.floor((waveNumber - 1) / 5) * 0.5);
                    this.boss.maxHealth *= multiplier;
                    this.boss.health = this.boss.maxHealth;
                }
                
                this.bossPhase = true;
                
                // „Éú„ÇπÂá∫Áèæ„Ç¢„Éä„Ç¶„É≥„Çπ
                this.showBossAnnouncement(bossType);
            }
            
            showBossAnnouncement(bossType) {
                const announcement = document.getElementById('wave-announcement');
                const text = document.getElementById('announcement-text');
                const sub = document.getElementById('announcement-sub');
                
                const bossNames = [
                    'CYCLOPS TERROR',
                    'TWIN HORROR',
                    'JELLYFISH OVERLORD',
                    'INSECTOID NIGHTMARE',
                    'COSMIC EMPEROR'
                ];
                
                text.textContent = 'WARNING!';
                sub.textContent = bossNames[bossType - 1] + ' APPROACHES!';
                
                announcement.classList.add('visible');
                
                if (this.audioManager) {
                    this.audioManager.playWaveStart();
                }
                
                setTimeout(() => {
                    announcement.classList.remove('visible');
                }, 3000);
            }
            
            showGameClearAnnouncement() {
                const announcement = document.getElementById('wave-announcement');
                const text = document.getElementById('announcement-text');
                const sub = document.getElementById('announcement-sub');
                
                text.textContent = 'CONGRATULATIONS!';
                sub.textContent = 'YOU SAVED THE GALAXY!';
                
                text.style.color = '#ffff00';
                text.style.textShadow = '0 0 30px #ffff00, 0 0 60px #ff8800';
                
                announcement.classList.add('visible');
                
                if (this.audioManager) {
                    this.audioManager.playWaveStart();
                }
                
                // „Ç≤„Éº„É†„ÇØ„É™„Ç¢ÁîªÈù¢„Çí5ÁßíÂæå„Å´Ë°®Á§∫
                setTimeout(() => {
                    announcement.classList.remove('visible');
                    text.style.color = '';
                    text.style.textShadow = '';
                }, 5000);
            }

            showWaveAnnouncement(waveNumber) {
                const announcement = document.getElementById('wave-announcement');
                const text = document.getElementById('announcement-text');
                const sub = document.getElementById('announcement-sub');
                
                text.textContent = `WAVE ${waveNumber}`;
                sub.textContent = waveNumber % 5 === 0 ? 'BOSS INCOMING!' : 'PREPARE FOR BATTLE';
                
                announcement.classList.add('visible');
                
                // Play wave start sound
                if (this.audioManager) {
                    this.audioManager.playWaveStart();
                }
                
                setTimeout(() => {
                    announcement.classList.remove('visible');
                }, 2500);
            }

            update(deltaTime) {
                // Update combo timer
                if (this.combo > 1) {
                    this.comboTimer += deltaTime;
                    if (this.comboTimer >= this.comboTimeout) {
                        this.combo = 1;
                        this.comboTimer = 0;
                        this.updateComboDisplay();
                    }
                }
                
                // Wave delay between waves
                if (!this.waveActive) {
                    this.waveTimer += deltaTime;
                    if (this.waveTimer >= this.waveDelay) {
                        this.startWave(this.currentWave + 1);
                        this.waveTimer = 0;
                    }
                    return;
                }
                
                // Update wave duration
                this.waveDuration += deltaTime;
                
                // ÊÆµÈöéÁöÑ„Å™„Çπ„Éù„Éº„É≥È†ªÂ∫¶„ÅÆÂ¢óÂä†
                // Â∫èÁõ§(0-25%): Êô©„Çâ„ÅóÈÅãËª¢„ÄÅ‰∏≠Áõ§(25-60%): ÊôÆÈÄö„ÄÅÁµÇÁõ§(60-100%): ÊøÄ„Åó„ÅÑ
                const waveProgress = this.waveDuration / this.waveMaxDuration;
                let currentSpawnInterval;
                let spawnChanceMultiplier;
                
                if (waveProgress < 0.25) {
                    // Â∫èÁõ§: Â∞ë„Åó„ÇÜ„Å£„Åè„Çä
                    currentSpawnInterval = this.spawnInterval * 1.2;
                    spawnChanceMultiplier = 0.8;
                    this.wavePhase = 0;
                } else if (waveProgress < 0.6) {
                    // ‰∏≠Áõ§: ÈÄöÂ∏∏
                    currentSpawnInterval = this.spawnInterval;
                    spawnChanceMultiplier = 1.2;
                    this.wavePhase = 1;
                } else {
                    // ÁµÇÁõ§: ÈùûÂ∏∏„Å´ÊøÄ„Åó„ÅÑ
                    currentSpawnInterval = this.spawnInterval * 0.4;
                    spawnChanceMultiplier = 2.0;
                    this.wavePhase = 2;
                }
                
                // Spawn enemies over time (continuous spawning)
                this.spawnTimer += deltaTime;
                if (this.spawnTimer >= currentSpawnInterval && this.totalSpawned < this.maxSpawnsPerWave) {
                    // ÁµÇÁõ§„ÅØË§áÊï∞ÂêåÊôÇ„Çπ„Éù„Éº„É≥„ÅÆÁ¢∫Áéá„ÅåÂ§ßÂπÖ„Å´‰∏ä„Åå„Çã
                    const multiSpawnChance = 0.3 * spawnChanceMultiplier;
                    let spawnCount = 1;
                    if (Math.random() < multiSpawnChance) {
                        spawnCount = this.wavePhase === 2 ? 3 : 2; // ÁµÇÁõ§„ÅØ3‰ΩìÂêåÊôÇ
                    }
                    
                    for (let i = 0; i < spawnCount && this.totalSpawned < this.maxSpawnsPerWave; i++) {
                        this.spawnRandomEnemy(this.currentWave);
                    }
                    // Add randomness to next spawn time
                    this.spawnTimer = -Math.random() * currentSpawnInterval * 0.2;
                }
                
                // Update asteroids
                this.asteroids.forEach(asteroid => asteroid.update(deltaTime));
                this.asteroids = this.asteroids.filter(a => a.alive);
                
                // Update enemies (ÂÖ®„Çø„Ç§„ÉóÂØæÂøú)
                this.enemies.forEach(enemy => {
                    switch (enemy.type) {
                        case 'fighter':
                        case 'interceptor':
                        case 'tank':
                        case 'sniper':
                        case 'swarm':
                            enemy.update(deltaTime, this.projectiles);
                            break;
                        case 'bomber':
                            enemy.update(deltaTime, this.mines);
                            break;
                        case 'carrier':
                            // Carrier„ÅØ‰ªñ„ÅÆÊïµ„ÇíÁîüÊàê„Åß„Åç„Çã
                            enemy.update(deltaTime, this.projectiles, this.enemies);
                            break;
                        default:
                            enemy.update(deltaTime, this.projectiles);
                    }
                });
                this.enemies = this.enemies.filter(e => e.alive);
                
                // Update projectiles
                this.projectiles.forEach(p => p.update(deltaTime));
                this.projectiles = this.projectiles.filter(p => p.alive);
                
                // Update mines
                this.mines.forEach(mine => {
                    const shouldExplode = mine.update(deltaTime, this.player.position);
                    if (shouldExplode && mine.alive) {
                        // Damage player if in range
                        const dist = mine.position.distanceTo(this.player.position);
                        if (dist < mine.triggerRadius) {
                            this.player.takeDamage(mine.damage, mine.position);
                        }
                        mine.destroy();
                    }
                });
                this.mines = this.mines.filter(m => m.alive);
                
                // Update bombsÔºà„Éú„É†„ÅÆÊõ¥Êñ∞„Å®Ë°ùÁ™ÅÂá¶ÁêÜÔºâ
                this.bombs.forEach(bomb => {
                    if (!bomb.alive || bomb.exploded) return;
                    const status = bomb.update(deltaTime);
                    
                    // ÂØøÂëΩÂàá„Çå„Å™„ÇâËá™ÂãïÁàÜÁô∫
                    if (status === 'timeout') {
                        const hitTargets = bomb.explode(this.enemies, this.asteroids, this.vfxManager, this.audioManager);
                        hitTargets.forEach(({ target, destroyed }) => {
                            if (destroyed && target.score) {
                                const isAsteroid = target.type === 'asteroid';
                                this.addScore(target.score, isAsteroid);
                            }
                        });
                        
                        // „Éú„Çπ„Å∏„ÅÆ„ÉÄ„É°„Éº„Ç∏Âá¶ÁêÜÔºà„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÁàÜÁô∫ÊôÇÔºâ
                        if (this.boss && this.boss.alive) {
                            const dist = bomb.position.distanceTo(this.boss.position);
                            if (dist < 120 + this.boss.getCollisionRadius()) {
                                const killed = this.boss.takeDamage(700, true);
                                console.log('Boss hit by timeout bomb! Damage: 700, Killed:', killed);
                                if (this.vfxManager) {
                                    this.vfxManager.createExplosion(this.boss.position.clone(), 'large', 0xff00ff);
                                }
                            }
                        }
                        return; // ÁàÜÁô∫Ê∏à„Åø„Å™„ÅÆ„ÅßË°ùÁ™ÅÂà§ÂÆö„Çπ„Ç≠„ÉÉ„Éó
                    }
                    
                    // Ê∂àÊªÖÊ∏à„Åø„Å™„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
                    if (status === 'destroyed') return;
                    
                    // „Éú„É†„Å®Êïµ/Â∞èÊÉëÊòü„ÅÆË°ùÁ™ÅÂà§ÂÆöÔºàË°ùÁ™Å„Åó„Å¶„ÇÇÁàÜÁô∫„Åó„Å™„ÅÑ„ÄÅÊâãÂãïÁàÜÁô∫„ÅÆ„ÅøÔºâ
                    // Ë°ùÁ™ÅÊôÇ„ÅÆËá™ÂãïÁàÜÁô∫„ÅØÁÑ°ÂäπÂåñ„Åó„Å¶„ÄÅ„Éó„É¨„Ç§„É§„Éº„ÅåÂ•Ω„Åç„Å™„Çø„Ç§„Éü„É≥„Ç∞„ÅßÁàÜÁô∫„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã
                });
                this.bombs = this.bombs.filter(b => b.alive);
                
                // Update power-up items
                this.powerUpItems.forEach(item => item.update(deltaTime));
                this.powerUpItems = this.powerUpItems.filter(item => item.alive);
                
                // Update health items
                this.healthItems.forEach(item => item.update(deltaTime));
                this.healthItems = this.healthItems.filter(item => item.alive);
                
                // Check power-up collisions
                this.checkPowerUpCollisions();
                
                // Check health item collisions
                this.checkHealthItemCollisions();
                
                // Check collision
                this.checkCollisions();
                
                // Update enemy count
                this.enemiesRemaining = this.asteroids.length + this.enemies.length;
                
                // „Éú„ÇπÊà¶„Éï„Çß„Éº„Ç∫„ÅÆÂá¶ÁêÜ
                if (this.bossPhase && this.boss) {
                    // „Éú„Çπ„ÅÆÊõ¥Êñ∞
                    this.boss.update(deltaTime, this.projectiles);
                    
                    // „Éú„Çπ„ÅåÂÄí„Åï„Çå„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    if (!this.boss.alive) {
                        this.bossDefeated = true;
                        this.bossPhase = false;
                        
                        // „Éú„ÇπÊíÉÁ†¥„Çπ„Ç≥„Ç¢
                        this.addScore(this.boss.score, false); // false = enemy (boss)
                        
                        // „Éú„ÇπÊíÉÁ†¥Â†±ÈÖ¨ÔºöHP50%ÂõûÂæ©ÔºàHULLÂÑ™ÂÖà„ÄÅÊ¨°„Å´SHIELDÔºâ
                        if (this.player) {
                            const totalHealAmount = Math.floor(this.player.maxHealth * 0.50);
                            let remainingHeal = totalHealAmount;
                            
                            // „Åæ„ÅöHULL„ÇíÂõûÂæ©ÔºàÂÑ™ÂÖàÔºâ
                            const healthDeficit = this.player.maxHealth - this.player.health;
                            const healthHeal = Math.min(remainingHeal, healthDeficit);
                            this.player.health += healthHeal;
                            remainingHeal -= healthHeal;
                            
                            // ÊÆã„Çä„Åå„ÅÇ„Çå„Å∞SHIELD„ÇíÂõûÂæ©
                            if (remainingHeal > 0) {
                                const shieldDeficit = this.player.maxShields - this.player.shields;
                                const shieldHeal = Math.min(remainingHeal, shieldDeficit);
                                this.player.shields += shieldHeal;
                            }
                            
                            this.showBossRewardNotification('HP +50%');
                            this.updateUI();  // HPÂõûÂæ©„ÇíUI„Å´ÂèçÊò†
                        }
                        
                        // „Éë„ÉØ„Éº„É¨„Éô„É´„Çí1ÊÆµÈöé‰∏ã„Åí„ÇãÔºàÊúÄ‰Ωé0Ôºâ
                        if (this.player && this.player.powerLevel > 0) {
                            this.player.powerLevel--;
                            this.updatePowerLevelUI();
                            this.showBossRewardNotification('POWER DOWN');
                            this.updateUI();  // UI„ÇíÂÜçÂ∫¶Êõ¥Êñ∞
                        }
                        
                        // „Éú„ÇπÁàÜÁô∫„Ç®„Éï„Çß„ÇØ„Éà
                        if (this.vfxManager) {
                            this.vfxManager.createExplosion(this.boss.position.clone(), 'large', 0xff00ff);
                            // ËøΩÂä†„ÅÆÊ¥æÊâã„Å™ÁàÜÁô∫
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    if (this.vfxManager && this.boss) {
                                        const offset = new THREE.Vector3(
                                            (Math.random() - 0.5) * 20,
                                            (Math.random() - 0.5) * 20,
                                            (Math.random() - 0.5) * 20
                                        );
                                        this.vfxManager.createExplosion(
                                            this.boss.position.clone().add(offset),
                                            'large',
                                            0xff6600
                                        );
                                    }
                                }, i * 200);
                            }
                        }
                        
                        // Wave 5„ÅÆ„Éú„Çπ„ÇíÂÄí„Åó„Åü„Çâ„Ç≤„Éº„É†„ÇØ„É™„Ç¢
                        if (this.boss.isFinalBoss || this.currentWave === 5) {
                            this.gameCleared = true;
                            this.showGameClearAnnouncement();
                        }
                        
                        this.boss.destroy();
                        this.boss = null;
                        
                        // WaveÂÆå‰∫Ü
                        this.waveActive = false;
                    }
                    
                    this.updateUI();
                    return;
                }
                
                // Check wave complete: either time ran out OR all spawned and defeated
                const allSpawned = this.totalSpawned >= this.maxSpawnsPerWave;
                const timeUp = this.waveDuration >= this.waveMaxDuration;
                const allDefeated = this.enemiesRemaining === 0 && allSpawned;
                
                // ÈÄöÂ∏∏„Éï„Çß„Éº„Ç∫ÁµÇ‰∫Ü ‚Üí „Éú„Çπ„Éï„Çß„Éº„Ç∫„Å∏
                if ((allDefeated || timeUp) && !this.bossPhase && !this.bossDefeated) {
                    // ÊÆã„Çä„ÅÆÊïµ„ÇíÊéÉÈô§
                    this.enemies.forEach(e => e.destroy());
                    this.asteroids.forEach(a => a.destroy());
                    this.enemies = [];
                    this.asteroids = [];
                    
                    // „Éú„Çπ„Çí„Çπ„Éù„Éº„É≥
                    this.spawnBoss(this.currentWave);
                }
                
                this.updateUI();
            }

            checkCollisions() {
                // Player bullets vs enemies/asteroids
                const playerBullets = this.projectiles.filter(p => p.isPlayerBullet);
                
                playerBullets.forEach(bullet => {
                    if (!bullet.alive) return;
                    
                    // Check asteroids
                    this.asteroids.forEach(asteroid => {
                        if (!asteroid.alive) return;
                        
                        const dist = bullet.position.distanceTo(asteroid.position);
                        if (dist < asteroid.getCollisionRadius() + bullet.getCollisionRadius()) {
                            bullet.destroy();
                            const destroyed = asteroid.takeDamage(bullet.damage);
                            
                            // Hit spark effect
                            if (this.vfxManager) {
                                this.vfxManager.createExplosion(bullet.position.clone(), 'small', 0xffaa00);
                            }
                            
                            // Play bullet impact sound
                            if (this.audioManager) {
                                this.audioManager.playBulletImpact();
                            }
                            
                            if (destroyed) {
                                this.addScore(asteroid.score, true); // true = asteroid
                                
                                // Play asteroid destroyed sound
                                if (this.audioManager) {
                                    this.audioManager.playAsteroidDestroyed();
                                }
                                
                                // Explosion based on asteroid size
                                if (this.vfxManager) {
                                    const expSize = asteroid.size === 'large' ? 'large' : 
                                                   asteroid.size === 'medium' ? 'medium' : 'small';
                                    this.vfxManager.createExplosion(asteroid.position.clone(), expSize, 0xff6600);
                                }
                                
                                // Spawn fragments
                                const fragments = asteroid.getFragments();
                                fragments.forEach(size => {
                                    const offset = new THREE.Vector3(
                                        (Math.random() - 0.5) * 5,
                                        (Math.random() - 0.5) * 5,
                                        (Math.random() - 0.5) * 5
                                    );
                                    const newAsteroid = new Asteroid(
                                        this.scene,
                                        asteroid.position.clone().add(offset),
                                        size
                                    );
                                    this.asteroids.push(newAsteroid);
                                });
                                
                                // ÂÆåÂÖ®Á†¥Â£äÊôÇÔºàsmall„Çµ„Ç§„Ç∫Ôºâ„Å´3%„ÅÆÁ¢∫Áéá„Åß„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Éâ„É≠„ÉÉ„Éó
                                if (fragments.length === 0 && Math.random() < 0.03) {
                                    this.spawnPowerUp(asteroid.position.clone());
                                }
                            }
                        }
                    });
                    
                    // Check enemies
                    this.enemies.forEach(enemy => {
                        if (!enemy.alive) return;
                        
                        const dist = bullet.position.distanceTo(enemy.position);
                        if (dist < enemy.getCollisionRadius() + bullet.getCollisionRadius()) {
                            bullet.destroy();
                            const destroyed = enemy.takeDamage(bullet.damage);
                            
                            // Hit spark
                            if (this.vfxManager) {
                                this.vfxManager.createExplosion(bullet.position.clone(), 'small', 0xff4444);
                            }
                            
                            // Play bullet impact sound
                            if (this.audioManager) {
                                this.audioManager.playBulletImpact();
                            }
                            
                            if (destroyed) {
                                this.addScore(enemy.score, false); // false = enemy
                                
                                // Play enemy destroyed sound
                                if (this.audioManager) {
                                    this.audioManager.playEnemyDestroyed();
                                }
                                
                                // Enemy explosion + kill marker
                                if (this.vfxManager) {
                                    const expSize = enemy.constructor.name === 'EnemyBomber' ? 'large' : 'medium';
                                    this.vfxManager.createExplosion(enemy.position.clone(), expSize, 0xff3300);
                                    this.vfxManager.createKillMarker(enemy.position.clone());
                                }
                                
                                // 7%„ÅÆÁ¢∫Áéá„ÅßHPÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†„Éâ„É≠„ÉÉ„Éó
                                if (Math.random() < 0.07) {
                                    this.spawnHealthItem(enemy.position.clone());
                                }
                            }
                        }
                    });
                    
                    // Check boss
                    if (this.boss && this.boss.alive) {
                        const dist = bullet.position.distanceTo(this.boss.position);
                        if (dist < this.boss.getCollisionRadius() + bullet.getCollisionRadius()) {
                            bullet.destroy();
                            this.boss.takeDamage(bullet.damage, false);
                            
                            // Hit spark
                            if (this.vfxManager) {
                                this.vfxManager.createExplosion(bullet.position.clone(), 'small', 0xff00ff);
                            }
                            
                            if (this.audioManager) {
                                this.audioManager.playBulletImpact();
                            }
                        }
                    }
                });
                
                // Check mines
                this.mines.forEach(mine => {
                    if (!mine.alive) return;
                    
                    playerBullets.forEach(bullet => {
                        if (!bullet.alive) return;
                        
                        const dist = bullet.position.distanceTo(mine.position);
                        if (dist < mine.getCollisionRadius() + bullet.getCollisionRadius()) {
                            bullet.destroy();
                            mine.explode();
                            
                            // Mine explosion
                            if (this.vfxManager) {
                                this.vfxManager.createExplosion(mine.position.clone(), 'medium', 0xff0000);
                            }
                        }
                    });
                });
                
                // Enemy bullets vs player
                const enemyBullets = this.projectiles.filter(p => !p.isPlayerBullet);
                enemyBullets.forEach(bullet => {
                    if (!bullet.alive) return;
                    
                    const dist = bullet.position.distanceTo(this.player.position);
                    if (dist < 3 + bullet.getCollisionRadius()) {
                        bullet.destroy();
                        this.player.takeDamage(bullet.damage, bullet.position);
                        
                        // Player hit effect + damage direction + sound
                        if (this.vfxManager) {
                            this.vfxManager.createExplosion(bullet.position.clone(), 'small', 0x00ffff);
                            this.vfxManager.showDamageDirection(bullet.position, this.player.position);
                        }
                        if (this.audioManager) {
                            this.audioManager.playDamage();
                        }
                    }
                });
                
                // Player vs asteroids/enemies (collision damage)
                [...this.asteroids, ...this.enemies].forEach(obj => {
                    if (!obj.alive) return;
                    
                    const dist = obj.position.distanceTo(this.player.position);
                    if (dist < obj.getCollisionRadius() + 2) {
                        this.player.takeDamage(20, obj.position);
                        obj.takeDamage(50);
                        
                        // Collision effect + damage direction + sound
                        if (this.vfxManager) {
                            this.vfxManager.createExplosion(this.player.position.clone(), 'small', 0xffff00);
                            this.vfxManager.showDamageDirection(obj.position, this.player.position);
                        }
                        if (this.audioManager) {
                            this.audioManager.playDamage();
                        }
                    }
                });
                
                // Player vs Boss (collision damage)
                if (this.boss && this.boss.alive) {
                    const dist = this.boss.position.distanceTo(this.player.position);
                    if (dist < this.boss.getCollisionRadius() + 2) {
                        this.player.takeDamage(30, this.boss.position);
                        
                        if (this.vfxManager) {
                            this.vfxManager.createExplosion(this.player.position.clone(), 'medium', 0xff00ff);
                            this.vfxManager.showDamageDirection(this.boss.position, this.player.position);
                        }
                        if (this.audioManager) {
                            this.audioManager.playDamage();
                        }
                    }
                }
            }

            addScore(points, isAsteroid = false) {
                this.score += points;
                if (isAsteroid) {
                    this.asteroidsDestroyed++;
                } else {
                    this.enemiesDestroyed++;
                }
                this.updateKillsDisplay();
            }

            updateKillsDisplay() {
                document.getElementById('asteroid-kills').textContent = this.asteroidsDestroyed;
                document.getElementById('enemy-kills').textContent = this.enemiesDestroyed;
            }
            
            // Wave 5‰ª•Èôç„ÅÆÁï∞Ê¨°ÂÖÉÁ©∫ÈñìËÉåÊôØ„ÇíË®≠ÂÆö
            setDimensionalRiftBackground() {
                // „Éï„Ç©„Ç∞„ÇíÊ∑±Á¥Ö/Á¥´„Å´Â§âÊõ¥
                if (this.scene.fog) {
                    this.scene.fog.color.setHex(0x1a0011);
                }
                
                // Êó¢Â≠ò„ÅÆÊòü„ÇíËµ§/Á¥´Á≥ª„Å´Â§âÊõ¥
                if (this.scene.children) {
                    this.scene.children.forEach(child => {
                        // Êòü„ÅÆ„Éë„Éº„ÉÜ„Ç£„ÇØ„É´„ÇíÂ§âÊõ¥
                        if (child.isPoints && child.material && child.material.uniforms) {
                            // Êòü„ÅÆËâ≤„ÇíËµ§/Á¥´Á≥ª„Å´
                            if (child.geometry && child.geometry.attributes.color) {
                                const colors = child.geometry.attributes.color.array;
                                for (let i = 0; i < colors.length; i += 3) {
                                    // Ëµ§„Å®Á¥´„Çí„É°„Ç§„É≥„Å´
                                    colors[i] = colors[i] * 0.3 + 0.7;     // R: Â¢óÂä†
                                    colors[i + 1] = colors[i + 1] * 0.2;    // G: Ê∏õÂ∞ë
                                    colors[i + 2] = colors[i + 2] * 0.5 + 0.3; // B: Â∞ë„ÅóÊÆã„Åô
                                }
                                child.geometry.attributes.color.needsUpdate = true;
                            }
                        }
                        
                        // ÊòüÈõ≤„ÅÆËâ≤„ÇÇÂ§âÊõ¥
                        if (child.isGroup) {
                            child.traverse(obj => {
                                if (obj.isMesh && obj.material) {
                                    if (obj.material.color) {
                                        // Ê∑±Á¥Ö„ÇÑÁ¥´„Å´Â§âÊõ¥
                                        const hue = Math.random() * 0.1 + 0.9; // Ëµ§„ÄúÁ¥´
                                        obj.material.color.setHSL(hue % 1, 0.8, 0.3);
                                    }
                                }
                            });
                        }
                    });
                }
                
                // Áï∞Ê¨°ÂÖÉ„ÅÆË£Ç„ÅëÁõÆ„Ç®„Éï„Çß„ÇØ„Éà„ÇíËøΩÂä†
                this.createDimensionalRift();
                
                console.log('[Wave 5+] Dimensional rift background activated!');
            }
            
            // Áï∞Ê¨°ÂÖÉ„ÅÆË£Ç„ÅëÁõÆ„Çí‰ΩúÊàê
            createDimensionalRift() {
                // Â∑®Â§ß„Å™Ê∏¶Â∑ª„ÅèË£Ç„ÅëÁõÆ
                const riftGroup = new THREE.Group();
                
                // ‰∏≠ÂøÉ„ÅÆË£Ç„ÅëÁõÆÔºàÈªí„ÅÑÁ©¥Ôºâ
                const riftCoreGeo = new THREE.RingGeometry(50, 200, 64, 8);
                const riftCoreMat = new THREE.MeshBasicMaterial({
                    color: 0x220011,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const riftCore = new THREE.Mesh(riftCoreGeo, riftCoreMat);
                riftCore.position.set(0, 0, -800);
                riftCore.rotation.x = Math.PI * 0.1;
                riftGroup.add(riftCore);
                
                // Ê∏¶Â∑ª„Åè„Ç®„Éç„É´„ÇÆ„Éº„É™„É≥„Ç∞
                for (let i = 0; i < 5; i++) {
                    const ringGeo = new THREE.TorusGeometry(100 + i * 40, 3 + i * 2, 16, 100);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: i % 2 === 0 ? 0xff0044 : 0x8800ff,
                        transparent: true,
                        opacity: 0.4 - i * 0.05
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.set(0, 0, -800 + i * 10);
                    ring.rotation.x = Math.PI * 0.1;
                    ring.userData.rotSpeed = 0.002 * (i % 2 === 0 ? 1 : -1);
                    ring.userData.isDimensionalRing = true;
                    riftGroup.add(ring);
                }
                
                // ÊµÆÈÅä„Åô„ÇãËµ§„ÅÑÁ≤íÂ≠ê
                const particleCount = 500;
                const particleGeo = new THREE.BufferGeometry();
                const particlePositions = new Float32Array(particleCount * 3);
                const particleColors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 100 + Math.random() * 300;
                    particlePositions[i3] = Math.cos(angle) * radius + (Math.random() - 0.5) * 100;
                    particlePositions[i3 + 1] = (Math.random() - 0.5) * 200;
                    particlePositions[i3 + 2] = -600 - Math.random() * 400;
                    
                    // Ëµ§„ÄúÁ¥´„ÅÆ„É©„É≥„ÉÄ„É†„Ç´„É©„Éº
                    particleColors[i3] = 0.8 + Math.random() * 0.2;
                    particleColors[i3 + 1] = Math.random() * 0.2;
                    particleColors[i3 + 2] = Math.random() * 0.5 + 0.3;
                }
                
                particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
                
                const particleMat = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7,
                    blending: THREE.AdditiveBlending
                });
                
                const particles = new THREE.Points(particleGeo, particleMat);
                particles.userData.isDimensionalParticles = true;
                riftGroup.add(particles);
                
                // ÈÅ†„Åè„Å´‰∏çÊ∞óÂë≥„Å™ÂÖâÊ∫ê„ÇíËøΩÂä†
                const ominousLight = new THREE.PointLight(0xff0033, 2, 1000);
                ominousLight.position.set(0, 0, -600);
                riftGroup.add(ominousLight);
                
                const ominousLight2 = new THREE.PointLight(0x8800ff, 1.5, 800);
                ominousLight2.position.set(100, 50, -700);
                riftGroup.add(ominousLight2);
                
                this.scene.add(riftGroup);
                this.dimensionalRift = riftGroup;
            }

            updateUI() {
                if (!this.player) return;
                
                document.getElementById('wave-number').textContent = this.currentWave;
                document.getElementById('score-value').textContent = this.score.toLocaleString();
                document.getElementById('enemy-count-value').textContent = this.enemiesRemaining;
                
                // Health bars
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                const shieldPercent = (this.player.shields / this.player.maxShields) * 100;
                
                const healthBar = document.getElementById('health-bar-fill');
                const shieldBar = document.getElementById('shield-bar');
                
                if (healthBar) healthBar.style.width = healthPercent + '%';
                if (shieldBar) shieldBar.style.width = shieldPercent + '%';
                
                // Bomb indicator update
                if (this.player) {
                    const bombCount = this.player.bombCount;
                    for (let i = 1; i <= 3; i++) {
                        const bombEl = document.getElementById(`bomb-${i}`);
                        if (bombEl) {
                            if (i <= bombCount) {
                                bombEl.classList.add('ready');
                                bombEl.classList.remove('used');
                            } else {
                                bombEl.classList.remove('ready');
                                bombEl.classList.add('used');
                            }
                        }
                    }
                }
                
                // Boss HP bar update
                const bossContainer = document.getElementById('boss-hp-container');
                if (this.boss && this.boss.alive && this.bossPhase) {
                    bossContainer.style.display = 'block';
                    const bossHpPercent = (this.boss.health / this.boss.maxHealth) * 100;
                    document.getElementById('boss-hp-bar-fill').style.width = bossHpPercent + '%';
                    
                    // „Éú„ÇπÂêç„ÇíË°®Á§∫
                    const bossNames = [
                        'CYCLOPS TERROR',
                        'TWIN HORROR',
                        'JELLYFISH OVERLORD',
                        'INSECTOID NIGHTMARE',
                        'COSMIC EMPEROR'
                    ];
                    const bossType = ((this.currentWave - 1) % 5);
                    document.getElementById('boss-name').textContent = bossNames[bossType];
                } else {
                    bossContainer.style.display = 'none';
                }
            }

            playerFire() {
                const positions = this.player.getWeaponPositions();
                const direction = this.player.getForwardDirection();
                const powerLevel = this.player.powerLevel;
                
                // „Éë„ÉØ„Éº„É¨„Éô„É´„Å´Âøú„Åò„ÅüÂ∞ÑÊíÉ„Éë„Çø„Éº„É≥
                // Level 0: Â∑¶Âè≥2Áô∫Ôºà„Éá„Éï„Ç©„É´„ÉàÔºâ
                // Level 1: Â∑¶Âè≥2Áô∫ + ‰∏≠Â§Æ1Áô∫ = 3Áô∫
                // Level 2: Â∑¶Âè≥2Áô∫ + ‰∏≠Â§Æ1Áô∫ + Êñú„ÇÅ2Áô∫ = 5Áô∫
                // Level 3: Â∑¶Âè≥2Áô∫ + ‰∏≠Â§Æ2Áô∫ + Êñú„ÇÅ4Áô∫ = 8Áô∫ÔºàÂ∫ÉËßíÊâáÁä∂Ôºâ
                
                // Âü∫Êú¨„ÅÆÂ∑¶Âè≥2Áô∫
                positions.forEach((pos, index) => {
                    const projectile = new Projectile(this.scene, pos, direction, true);
                    this.projectiles.push(projectile);
                    
                    // Muzzle flash
                    if (this.vfxManager) {
                        this.vfxManager.createMuzzleFlash(pos.clone(), direction.clone(), 0x00ffff);
                    }
                });
                
                // Level 1+: ‰∏≠Â§Æ„ÅÆÂºæ
                if (powerLevel >= 1) {
                    const centerPos = this.player.position.clone();
                    centerPos.z -= 2;
                    const projectile = new Projectile(this.scene, centerPos, direction, true);
                    this.projectiles.push(projectile);
                    
                    if (this.vfxManager) {
                        this.vfxManager.createMuzzleFlash(centerPos.clone(), direction.clone(), 0x00ffff);
                    }
                }
                
                // Level 2+: Êñú„ÇÅÊñπÂêë„ÅÆÂºæÔºàÂ∑¶Âè≥„Å´15Â∫¶Ôºâ
                if (powerLevel >= 2) {
                    const spreadAngle = 0.26; // Á¥Ñ15Â∫¶
                    const leftDir = direction.clone();
                    leftDir.x = Math.sin(-spreadAngle);
                    leftDir.z = Math.cos(-spreadAngle) * -1;
                    leftDir.normalize();
                    
                    const rightDir = direction.clone();
                    rightDir.x = Math.sin(spreadAngle);
                    rightDir.z = Math.cos(spreadAngle) * -1;
                    rightDir.normalize();
                    
                    const leftPos = this.player.position.clone();
                    leftPos.x -= 1;
                    leftPos.z -= 2;
                    const leftProj = new Projectile(this.scene, leftPos, leftDir, true);
                    this.projectiles.push(leftProj);
                    
                    const rightPos = this.player.position.clone();
                    rightPos.x += 1;
                    rightPos.z -= 2;
                    const rightProj = new Projectile(this.scene, rightPos, rightDir, true);
                    this.projectiles.push(rightProj);
                    
                    if (this.vfxManager) {
                        this.vfxManager.createMuzzleFlash(leftPos.clone(), leftDir.clone(), 0x00ff88);
                        this.vfxManager.createMuzzleFlash(rightPos.clone(), rightDir.clone(), 0x00ff88);
                    }
                }
                
                // Level 3: „Åï„Çâ„Å´Â∫ÉËßí„ÅÆÂºæÔºàÂ∑¶Âè≥„Å´30Â∫¶Ôºâ+ ËøΩÂä†„ÅÆ‰∏≠Â§ÆÂºæ
                if (powerLevel >= 3) {
                    const wideAngle = 0.52; // Á¥Ñ30Â∫¶
                    const leftWideDir = direction.clone();
                    leftWideDir.x = Math.sin(-wideAngle);
                    leftWideDir.z = Math.cos(-wideAngle) * -1;
                    leftWideDir.normalize();
                    
                    const rightWideDir = direction.clone();
                    rightWideDir.x = Math.sin(wideAngle);
                    rightWideDir.z = Math.cos(wideAngle) * -1;
                    rightWideDir.normalize();
                    
                    const leftWidePos = this.player.position.clone();
                    leftWidePos.x -= 2;
                    leftWidePos.z -= 2;
                    const leftWideProj = new Projectile(this.scene, leftWidePos, leftWideDir, true);
                    this.projectiles.push(leftWideProj);
                    
                    const rightWidePos = this.player.position.clone();
                    rightWidePos.x += 2;
                    rightWidePos.z -= 2;
                    const rightWideProj = new Projectile(this.scene, rightWidePos, rightWideDir, true);
                    this.projectiles.push(rightWideProj);
                    
                    // ËøΩÂä†„ÅÆ‰∏≠Â§ÆÂºæÔºàÂ∞ë„Åó‰∏äÔºâ
                    const topCenterPos = this.player.position.clone();
                    topCenterPos.y += 0.5;
                    topCenterPos.z -= 2;
                    const topCenterProj = new Projectile(this.scene, topCenterPos, direction, true);
                    this.projectiles.push(topCenterProj);
                    
                    if (this.vfxManager) {
                        this.vfxManager.createMuzzleFlash(leftWidePos.clone(), leftWideDir.clone(), 0xffff00);
                        this.vfxManager.createMuzzleFlash(rightWidePos.clone(), rightWideDir.clone(), 0xffff00);
                        this.vfxManager.createMuzzleFlash(topCenterPos.clone(), direction.clone(), 0x00ffff);
                    }
                }
                
                // Play laser sound once per fire
                if (this.audioManager) {
                    this.audioManager.playLaser();
                }
            }
            
            // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†„Çí„Çπ„Éù„Éº„É≥
            spawnPowerUp(position) {
                const powerUp = new PowerUpItem(this.scene, position);
                this.powerUpItems.push(powerUp);
                
                // „Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÂá∫Áèæ„Ç®„Éï„Çß„ÇØ„Éà
                if (this.vfxManager) {
                    this.vfxManager.createExplosion(position.clone(), 'small', 0xffff00);
                }
            }
            
            // HPÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†„Çí„Çπ„Éù„Éº„É≥
            spawnHealthItem(position) {
                const healthItem = new HealthItem(this.scene, position);
                this.healthItems.push(healthItem);
                console.log(`[HealthItem] Spawned at position (${position.x.toFixed(1)}, ${position.y.toFixed(1)}, ${position.z.toFixed(1)}). Total items: ${this.healthItems.length}`);
                
                // HPÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†Âá∫Áèæ„Ç®„Éï„Çß„ÇØ„Éà
                if (this.vfxManager) {
                    this.vfxManager.createExplosion(position.clone(), 'small', 0x00ff44);
                }
            }
            
            // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†„Å®„Éó„É¨„Ç§„É§„Éº„ÅÆË°ùÁ™Å„ÉÅ„Çß„ÉÉ„ÇØ
            checkPowerUpCollisions() {
                this.powerUpItems.forEach(item => {
                    if (!item.alive) return;
                    
                    const dist = item.position.distanceTo(this.player.position);
                    if (dist < item.getCollisionRadius() + 3) {
                        // „Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÂèñÂæóÔºÅ
                        item.destroy();
                        
                        // „Éë„ÉØ„Éº„É¨„Éô„É´„Çí‰∏ä„Åí„ÇãÔºàÊúÄÂ§ß3Ôºâ
                        if (this.player.powerLevel < this.player.maxPowerLevel) {
                            this.player.powerLevel++;
                            
                            // „Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÈÄöÁü•„ÇíË°®Á§∫
                            this.showPowerUpNotification(this.player.powerLevel);
                            
                            // ÂèñÂæó„Ç®„Éï„Çß„ÇØ„Éà
                            if (this.vfxManager) {
                                this.vfxManager.createExplosion(this.player.position.clone(), 'medium', 0xffff00);
                            }
                            
                            // ÂèñÂæóÈü≥
                            if (this.audioManager) {
                                this.audioManager.playPowerUp();
                            }
                        } else {
                            // Êó¢„Å´ÊúÄÂ§ß„É¨„Éô„É´„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≥„Ç¢„Éú„Éº„Éä„Çπ
                            this.score += 500;
                            this.showPowerUpNotification('MAX');
                            
                            if (this.audioManager) {
                                this.audioManager.playPowerUp();
                            }
                        }
                        
                        // UIÊõ¥Êñ∞
                        this.updatePowerLevelUI();
                    }
                });
            }
            
            // HPÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†„Å®„Éó„É¨„Ç§„É§„Éº„ÅÆË°ùÁ™Å„ÉÅ„Çß„ÉÉ„ÇØ
            checkHealthItemCollisions() {
                if (!this.healthItems || !this.player) return;
                
                this.healthItems.forEach(item => {
                    if (!item.alive) return;
                    
                    const dist = item.position.distanceTo(this.player.position);
                    if (dist < item.getCollisionRadius() + 3) {
                        // HPÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†ÂèñÂæóÔºÅ
                        item.destroy();
                        
                        // Á∑èÂõûÂæ©Èáè„ÇíË®àÁÆóÔºàHP25%ÂàÜÔºâ
                        const totalHealAmount = Math.floor(this.player.maxHealth * item.healPercent);
                        let remainingHeal = totalHealAmount;
                        
                        const oldHealth = this.player.health;
                        const oldShields = this.player.shields;
                        
                        // „Åæ„ÅöHULL„ÇíÂõûÂæ©ÔºàÂÑ™ÂÖàÔºâ
                        const healthDeficit = this.player.maxHealth - this.player.health;
                        const healthHeal = Math.min(remainingHeal, healthDeficit);
                        this.player.health += healthHeal;
                        remainingHeal -= healthHeal;
                        
                        // ÊÆã„Çä„Åå„ÅÇ„Çå„Å∞SHIELD„ÇíÂõûÂæ©
                        if (remainingHeal > 0) {
                            const shieldDeficit = this.player.maxShields - this.player.shields;
                            const shieldHeal = Math.min(remainingHeal, shieldDeficit);
                            this.player.shields += shieldHeal;
                        }
                        
                        const actualHeal = this.player.health - oldHealth;
                        const actualShieldHeal = this.player.shields - oldShields;
                        
                        console.log(`[HealthItem] Picked up! HULL: ${oldHealth} -> ${this.player.health} (+${actualHeal}), SHIELD: ${oldShields} -> ${this.player.shields} (+${actualShieldHeal})`);
                        
                        // HPÂõûÂæ©ÈÄöÁü•„ÇíË°®Á§∫ÔºàÂêàË®àÂõûÂæ©ÈáèÔºâ
                        this.showHealthNotification(actualHeal + actualShieldHeal);
                        
                        // ÂèñÂæó„Ç®„Éï„Çß„ÇØ„ÉàÔºàÁ∑ëËâ≤Ôºâ
                        if (this.vfxManager) {
                            this.vfxManager.createExplosion(this.player.position.clone(), 'medium', 0x00ff44);
                        }
                        
                        // ÂèñÂæóÈü≥
                        if (this.audioManager) {
                            this.audioManager.playHealthPickup();
                        }
                        
                        // UIÊõ¥Êñ∞
                        this.updateUI();
                        console.log(`[HealthItem] UI updated. HULL: ${(this.player.health / this.player.maxHealth) * 100}%, SHIELD: ${(this.player.shields / this.player.maxShields) * 100}%`);
                    }
                });
            }
            
            // HPÂõûÂæ©ÈÄöÁü•„ÇíË°®Á§∫
            showHealthNotification(amount) {
                const notification = document.createElement('div');
                notification.className = 'health-notification';
                notification.textContent = `HP +${amount}`;
                notification.style.cssText = `
                    position: fixed;
                    top: 30%;
                    left: 50%;
                    transform: translateX(-50%);
                    font-family: 'Orbitron', sans-serif;
                    font-size: 32px;
                    font-weight: bold;
                    color: #00ff44;
                    text-shadow: 0 0 20px #00ff44, 0 0 40px #00ff44;
                    z-index: 1000;
                    animation: powerUpNotify 1.5s ease-out forwards;
                    pointer-events: none;
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 1500);
            }
            
            // „Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÈÄöÁü•„ÇíË°®Á§∫
            showPowerUpNotification(level) {
                const notification = document.createElement('div');
                notification.className = 'power-up-notification';
                
                if (level === 'MAX') {
                    notification.textContent = 'POWER MAX! +500 BONUS';
                    notification.style.color = '#ff4444';
                } else {
                    notification.textContent = `POWER UP! LEVEL ${level}`;
                    notification.style.color = '#ffff00';
                }
                
                notification.style.cssText += `
                    position: fixed;
                    top: 30%;
                    left: 50%;
                    transform: translateX(-50%);
                    font-family: 'Orbitron', sans-serif;
                    font-size: 32px;
                    font-weight: bold;
                    text-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
                    z-index: 1000;
                    animation: powerUpNotify 1.5s ease-out forwards;
                    pointer-events: none;
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 1500);
            }
            
            // „Éú„ÇπÊíÉÁ†¥Â†±ÈÖ¨ÈÄöÁü•„ÇíË°®Á§∫
            showBossRewardNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'boss-reward-notification';
                notification.textContent = message;
                
                const isHeal = message.includes('HP');
                notification.style.cssText = `
                    position: fixed;
                    top: ${isHeal ? '35%' : '40%'};
                    left: 50%;
                    transform: translateX(-50%);
                    font-family: 'Orbitron', sans-serif;
                    font-size: 28px;
                    font-weight: bold;
                    color: ${isHeal ? '#00ff88' : '#ff8800'};
                    text-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
                    z-index: 1000;
                    animation: bossRewardNotify 2s ease-out forwards;
                    pointer-events: none;
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 2000);
            }
            
            // „Éë„ÉØ„Éº„É¨„Éô„É´UIÊõ¥Êñ∞
            updatePowerLevelUI() {
                const powerLevelEl = document.getElementById('power-level-value');
                const powerBarFill = document.getElementById('power-level-fill');
                
                if (powerLevelEl) {
                    powerLevelEl.textContent = this.player.powerLevel;
                    
                    // „É¨„Éô„É´„Å´Âøú„Åò„ÅüËâ≤
                    const colors = ['#ffffff', '#00ff00', '#00ffff', '#ffff00'];
                    powerLevelEl.style.color = colors[this.player.powerLevel];
                }
                
                if (powerBarFill) {
                    // „Éë„ÉØ„Éº„Éê„Éº„ÅÆÂπÖ„ÇíÊõ¥Êñ∞Ôºà0-3„É¨„Éô„É´„Çí0-100%„Å´Ôºâ
                    const percent = (this.player.powerLevel / this.player.maxPowerLevel) * 100;
                    powerBarFill.style.width = percent + '%';
                    
                    // „É¨„Éô„É´„Å´Âøú„Åò„ÅüËâ≤
                    const barColors = [
                        'linear-gradient(90deg, #666666, #888888)',
                        'linear-gradient(90deg, #00ff00, #00aa00)',
                        'linear-gradient(90deg, #00ffff, #00aaff)',
                        'linear-gradient(90deg, #ffff00, #ff8800)'
                    ];
                    powerBarFill.style.background = barColors[this.player.powerLevel];
                }
            }
            
            // „Éú„É†Áô∫Â∞Ñ„Åæ„Åü„ÅØÊâãÂãïÁàÜÁô∫ÔºàB„Ç≠„ÉºÔºâ
            playerBomb() {
                if (!this.player) return false;
                
                // È£õË°å‰∏≠„ÅÆ„Éú„É†„Åå„ÅÇ„Çå„Å∞ÊâãÂãïÁàÜÁô∫
                const flyingBombs = this.bombs.filter(b => b.alive && !b.exploded);
                if (flyingBombs.length > 0) {
                    // ÊúÄÂàù„ÅÆÈ£õË°å‰∏≠„Éú„É†„ÇíÁàÜÁô∫„Åï„Åõ„Çã
                    const bomb = flyingBombs[0];
                    const hitTargets = bomb.explode(this.enemies, this.asteroids, this.vfxManager, this.audioManager);
                    // ÊíÉÁ†¥„Åó„ÅüÊïµ„ÅÆ„Çπ„Ç≥„Ç¢„ÇíÂä†ÁÆó
                    hitTargets.forEach(({ target, destroyed }) => {
                        if (destroyed && target.score) {
                            const isAsteroid = target.type === 'asteroid';
                            this.addScore(target.score, isAsteroid);
                        }
                    });
                    
                    // „Éú„Çπ„Å∏„ÅÆ„ÉÄ„É°„Éº„Ç∏Âá¶ÁêÜÔºà500„ÉÄ„É°„Éº„Ç∏Ôºâ
                    if (this.boss && this.boss.alive) {
                        const dist = bomb.position.distanceTo(this.boss.position);
                        const hitRange = bomb.explosionRadius + this.boss.getCollisionRadius();
                        console.log('Boss distance:', dist, 'Hit range:', hitRange, 'Boss HP:', this.boss.health);
                        if (dist < hitRange) {
                            const killed = this.boss.takeDamage(700, true); // fromBomb = true
                            console.log('Boss hit by bomb! Damage: 700, Boss HP after:', this.boss.health, 'Killed:', killed);
                            
                            if (this.vfxManager) {
                                this.vfxManager.createExplosion(this.boss.position.clone(), 'large', 0xff00ff);
                            }
                            
                            if (this.audioManager) {
                                this.audioManager.playExplosion('large');
                            }
                        }
                    }
                    
                    return true;
                }
                
                // „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥‰∏≠„Åæ„Åü„ÅØ„Éú„É†ÊÆãÊï∞0„Å™„ÇâÁô∫Â∞Ñ‰∏çÂèØ
                if (this.player.bombCooldown > 0 || this.player.bombCount <= 0) {
                    return false;
                }
                
                // „Éú„É†„ÇíÊ∂àË≤ª
                this.player.bombCount--;
                this.player.bombCooldown = this.player.bombCooldownTime;
                
                // „Éó„É¨„Ç§„É§„Éº‰ΩçÁΩÆ„Åã„ÇâÂâçÊñπ„Å´Áô∫Â∞Ñ
                const pos = this.player.position.clone();
                pos.z -= 3; // Â∞ë„ÅóÂâçÊñπ„Åã„Çâ
                const direction = this.player.getForwardDirection();
                
                const bomb = new Bomb(this.scene, pos, direction);
                this.bombs.push(bomb);
                
                // Áô∫Â∞Ñ„Ç®„Éï„Çß„ÇØ„Éà
                if (this.vfxManager) {
                    this.vfxManager.createMuzzleFlash(pos.clone(), direction.clone(), 0xff00ff);
                }
                
                // „Éú„É†Áô∫Â∞ÑÈü≥
                if (this.audioManager) {
                    this.audioManager.playBombLaunch();
                }
                
                return true;
            }

            cleanup() {
                this.asteroids.forEach(a => a.destroy());
                this.enemies.forEach(e => e.destroy());
                this.projectiles.forEach(p => p.destroy());
                this.mines.forEach(m => m.destroy());
                this.bombs.forEach(b => b.destroy());  // „Éú„É†„ÇÇ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                this.powerUpItems.forEach(p => p.destroy());  // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†„ÇÇ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                this.healthItems.forEach(h => h.destroy());   // HPÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†„ÇÇ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                
                // „Éú„Çπ„ÇÇ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                if (this.boss) {
                    this.boss.destroy();
                    this.boss = null;
                }
                
                this.asteroids = [];
                this.enemies = [];
                this.projectiles = [];
                this.mines = [];
                this.bombs = [];
                this.powerUpItems = [];
                this.healthItems = [];
                this.bossPhase = false;
                this.bossDefeated = false;
                this.gameCleared = false;
            }
        }

        // Main Game Class
        class StellarAssault {
            constructor() {
                this.state = GameState.LOADING;
                this.loadProgress = 0;
                
                // Core Three.js components
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.composer = null;
                
                // Environment
                this.starfield = null;
                this.starLayers = [];
                this.nebulas = [];
                this.spaceDust = null;
                this.planets = [];
                
                // Game Objects
                this.player = null;
                this.input = null;
                this.waveManager = null;
                
                // Shooting
                this.fireTimer = 0;
                this.fireRate = 0.1; // seconds between shots
                this.bombKeyPressed = false; // „Éú„É†„Ç≠„ÉºÈÄ£Â∞ÑÈò≤Ê≠¢
                
                // Camera
                this.cameraOffset = new THREE.Vector3(0, 8, 25);
                this.cameraLookAhead = new THREE.Vector3(0, 0, -20);
                
                // FPS tracking
                this.fpsFrames = 0;
                this.fpsLastTime = 0;
                this.fpsDisplay = 60;
                
                // Timing
                this.clock = new THREE.Clock();
                this.deltaTime = 0;
                this.elapsedTime = 0;
                
                // Performance
                this.frameCount = 0;
                this.fps = 60;
                this.lastFpsUpdate = 0;
                
                // Initialize
                this.init();
            }

            async init() {
                // Load saved settings first
                GameSettings.load();
                
                this.updateLoadingProgress(10, 'Creating renderer...');
                this.initRenderer();
                
                this.updateLoadingProgress(20, 'Setting up scene...');
                this.initScene();
                
                this.updateLoadingProgress(30, 'Configuring camera...');
                this.initCamera();
                
                this.updateLoadingProgress(40, 'Adding lights...');
                this.initLights();
                
                this.updateLoadingProgress(50, 'Generating starfield...');
                this.createStarfield();
                
                this.updateLoadingProgress(60, 'Creating nebulas...');
                this.createNebulas();
                
                this.updateLoadingProgress(70, 'Adding space dust...');
                this.createSpaceDust();
                
                this.updateLoadingProgress(80, 'Initializing input system...');
                this.input = new InputManager();
                
                this.updateLoadingProgress(85, 'Creating player ship...');
                this.player = new PlayerShip(this.scene);
                
                this.updateLoadingProgress(86, 'Initializing audio system...');
                this.audioManager = new AudioManager();
                this.audioManager.setMasterVolume(GameSettings.masterVolume);
                
                this.updateLoadingProgress(87, 'Initializing VFX system...');
                this.vfxManager = new VFXManager(this.scene, this.camera);
                
                this.updateLoadingProgress(88, 'Initializing wave manager...');
                this.waveManager = new WaveManager(this.scene, this.player);
                this.waveManager.vfxManager = this.vfxManager;
                this.waveManager.audioManager = this.audioManager;
                this.vfxManager.audioManager = this.audioManager;
                
                this.updateLoadingProgress(90, 'Initializing post-processing...');
                this.initPostProcessing();
                
                this.updateLoadingProgress(95, 'Setting up controls...');
                this.initEventListeners();
                
                // Apply loaded settings
                document.getElementById('fps-counter').classList.toggle('visible', GameSettings.showFPS);
                
                this.updateLoadingProgress(100, 'Ready!');
                
                // Start game loop
                setTimeout(() => {
                    this.hideLoadingScreen();
                    this.showMainMenu();
                    this.animate();
                }, 500);
            }

            updateLoadingProgress(progress, text) {
                this.loadProgress = progress;
                document.getElementById('loading-bar').style.width = progress + '%';
                document.getElementById('loading-text').textContent = text.toUpperCase();
            }

            hideLoadingScreen() {
                document.getElementById('loading-screen').classList.add('hidden');
            }

            showMainMenu() {
                this.state = GameState.MENU;
                document.getElementById('main-menu').classList.add('active');
            }

            hideMainMenu() {
                document.getElementById('main-menu').classList.remove('active');
            }

            initRenderer() {
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: false,
                    powerPreference: 'high-performance'
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                this.renderer.setClearColor(0x000011, 1);
                
                document.getElementById('game-container').appendChild(this.renderer.domElement);
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000011, 0.00015);
            }

            initCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    60, // FOV„ÇíÂ∞ë„ÅóÁã≠„ÇÅ„Å¶Ë¶ã„ÇÑ„Åô„Åè
                    window.innerWidth / window.innerHeight,
                    0.1,
                    10000
                );
                // ÂæåÊñπ‰∏ä„Åã„Çâ„ÅÆË¶ñÁÇπÔºàÁ∏¶„Çπ„ÇØ„É≠„Éº„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞È¢®Ôºâ
                this.camera.position.set(0, 20, 35);
                this.camera.lookAt(0, 0, -30);
            }

            initLights() {
                // Ambient light for base illumination
                const ambientLight = new THREE.AmbientLight(0x222244, 0.5);
                this.scene.add(ambientLight);

                // Main directional light (sun-like)
                const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
                mainLight.position.set(50, 30, 50);
                mainLight.castShadow = false;
                this.scene.add(mainLight);

                // Accent lights for atmosphere
                const blueLight = new THREE.PointLight(0x0066ff, 0.5, 500);
                blueLight.position.set(-100, 50, -100);
                this.scene.add(blueLight);

                const purpleLight = new THREE.PointLight(0x9900ff, 0.3, 500);
                purpleLight.position.set(100, -50, 100);
                this.scene.add(purpleLight);

                // Rim light for dramatic effect
                const rimLight = new THREE.DirectionalLight(0x00ffff, 0.3);
                rimLight.position.set(-50, 0, -50);
                this.scene.add(rimLight);
            }

            createStarfield() {
                // Multi-layer starfield for parallax effect
                const layers = [
                    { count: 3000, size: 0.5, distance: 2000, speed: 0.1 },
                    { count: 2000, size: 1.0, distance: 1500, speed: 0.2 },
                    { count: 1000, size: 1.5, distance: 1000, speed: 0.3 },
                    { count: 500, size: 2.5, distance: 500, speed: 0.5 }
                ];

                this.starLayers = [];

                layers.forEach((layer, index) => {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(layer.count * 3);
                    const colors = new Float32Array(layer.count * 3);
                    const sizes = new Float32Array(layer.count);

                    for (let i = 0; i < layer.count; i++) {
                        const i3 = i * 3;
                        
                        // Spherical distribution
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        const r = layer.distance * (0.8 + Math.random() * 0.4);
                        
                        positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                        positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                        positions[i3 + 2] = r * Math.cos(phi);

                        // Star colors (white, blue-white, yellow, orange)
                        const colorChoice = Math.random();
                        if (colorChoice < 0.6) {
                            // White
                            colors[i3] = 1;
                            colors[i3 + 1] = 1;
                            colors[i3 + 2] = 1;
                        } else if (colorChoice < 0.8) {
                            // Blue-white
                            colors[i3] = 0.8;
                            colors[i3 + 1] = 0.9;
                            colors[i3 + 2] = 1;
                        } else if (colorChoice < 0.95) {
                            // Yellow
                            colors[i3] = 1;
                            colors[i3 + 1] = 0.95;
                            colors[i3 + 2] = 0.8;
                        } else {
                            // Orange/red (rare)
                            colors[i3] = 1;
                            colors[i3 + 1] = 0.7;
                            colors[i3 + 2] = 0.5;
                        }

                        // Varying sizes for depth
                        sizes[i] = layer.size * (0.5 + Math.random() * 1.0);
                    }

                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                    // Custom shader for twinkling stars
                    const starMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            pixelRatio: { value: this.renderer.getPixelRatio() }
                        },
                        vertexShader: `
                            attribute float size;
                            attribute vec3 color;
                            varying vec3 vColor;
                            varying float vBrightness;
                            uniform float time;
                            uniform float pixelRatio;
                            
                            void main() {
                                vColor = color;
                                
                                // Twinkling effect
                                float twinkle = sin(time * 2.0 + position.x * 0.1 + position.y * 0.1) * 0.5 + 0.5;
                                vBrightness = 0.6 + twinkle * 0.4;
                                
                                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                                gl_PointSize = size * pixelRatio * (300.0 / -mvPosition.z);
                                gl_Position = projectionMatrix * mvPosition;
                            }
                        `,
                        fragmentShader: `
                            varying vec3 vColor;
                            varying float vBrightness;
                            
                            void main() {
                                // Circular star shape with soft edges
                                vec2 center = gl_PointCoord - vec2(0.5);
                                float dist = length(center);
                                
                                if (dist > 0.5) discard;
                                
                                // Soft glow effect
                                float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                                float glow = exp(-dist * 4.0);
                                
                                vec3 finalColor = vColor * vBrightness * (alpha + glow * 0.5);
                                gl_FragColor = vec4(finalColor, alpha);
                            }
                        `,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });

                    const stars = new THREE.Points(geometry, starMaterial);
                    stars.userData.speed = layer.speed;
                    this.scene.add(stars);
                    this.starLayers.push(stars);
                });
            }

            createNebulas() {
                // Create multiple nebula clouds
                const nebulaConfigs = [
                    { position: new THREE.Vector3(-300, 100, -500), color1: 0xff00ff, color2: 0x0066ff, scale: 200 },
                    { position: new THREE.Vector3(400, -50, -600), color1: 0xff6600, color2: 0xff0066, scale: 150 },
                    { position: new THREE.Vector3(0, 200, -800), color1: 0x00ffff, color2: 0x0033ff, scale: 250 }
                ];

                nebulaConfigs.forEach(config => {
                    const nebula = this.createNebulaCloud(config);
                    this.nebulas.push(nebula);
                    this.scene.add(nebula);
                });
            }

            createNebulaCloud(config) {
                const group = new THREE.Group();
                group.position.copy(config.position);

                // Create volumetric nebula using multiple transparent planes
                const nebulaCount = 20;
                
                for (let i = 0; i < nebulaCount; i++) {
                    const size = config.scale * (0.5 + Math.random() * 1.0);
                    const geometry = new THREE.PlaneGeometry(size, size);
                    
                    // Procedural nebula texture using canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Create gradient nebula pattern
                    const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
                    
                    const color1 = new THREE.Color(config.color1);
                    const color2 = new THREE.Color(config.color2);
                    const mixedColor = color1.clone().lerp(color2, Math.random());
                    
                    gradient.addColorStop(0, `rgba(${Math.floor(mixedColor.r * 255)}, ${Math.floor(mixedColor.g * 255)}, ${Math.floor(mixedColor.b * 255)}, 0.3)`);
                    gradient.addColorStop(0.4, `rgba(${Math.floor(mixedColor.r * 255)}, ${Math.floor(mixedColor.g * 255)}, ${Math.floor(mixedColor.b * 255)}, 0.15)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 256, 256);
                    
                    // Add noise
                    const imageData = ctx.getImageData(0, 0, 256, 256);
                    for (let j = 0; j < imageData.data.length; j += 4) {
                        const noise = (Math.random() - 0.5) * 30;
                        imageData.data[j] = Math.max(0, Math.min(255, imageData.data[j] + noise));
                        imageData.data[j + 1] = Math.max(0, Math.min(255, imageData.data[j + 1] + noise));
                        imageData.data[j + 2] = Math.max(0, Math.min(255, imageData.data[j + 2] + noise));
                    }
                    ctx.putImageData(imageData, 0, 0);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        side: THREE.DoubleSide,
                        opacity: 0.4 + Math.random() * 0.3
                    });
                    
                    const plane = new THREE.Mesh(geometry, material);
                    
                    // Random position and rotation within the nebula
                    plane.position.set(
                        (Math.random() - 0.5) * config.scale,
                        (Math.random() - 0.5) * config.scale,
                        (Math.random() - 0.5) * config.scale * 0.5
                    );
                    plane.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    
                    plane.userData.rotationSpeed = {
                        x: (Math.random() - 0.5) * 0.001,
                        y: (Math.random() - 0.5) * 0.001,
                        z: (Math.random() - 0.5) * 0.001
                    };
                    
                    group.add(plane);
                }

                return group;
            }

            createSpaceDust() {
                const dustCount = 5000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(dustCount * 3);
                const velocities = new Float32Array(dustCount * 3);
                const colors = new Float32Array(dustCount * 3);
                
                for (let i = 0; i < dustCount; i++) {
                    const i3 = i * 3;
                    
                    // Distribute dust in a cylinder around the player
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 50 + Math.random() * 200;
                    
                    positions[i3] = Math.cos(angle) * radius;
                    positions[i3 + 1] = (Math.random() - 0.5) * 200;
                    positions[i3 + 2] = Math.sin(angle) * radius - 100;
                    
                    // Velocities for particle movement
                    velocities[i3] = (Math.random() - 0.5) * 0.1;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i3 + 2] = -0.5 - Math.random() * 1.5; // Moving toward player
                    
                    // Subtle blue/white colors
                    colors[i3] = 0.6 + Math.random() * 0.4;
                    colors[i3 + 1] = 0.7 + Math.random() * 0.3;
                    colors[i3 + 2] = 0.9 + Math.random() * 0.1;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const dustMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        pixelRatio: { value: this.renderer.getPixelRatio() }
                    },
                    vertexShader: `
                        attribute vec3 color;
                        attribute vec3 velocity;
                        varying vec3 vColor;
                        varying float vAlpha;
                        uniform float time;
                        uniform float pixelRatio;
                        
                        void main() {
                            vColor = color;
                            
                            // Animate position
                            vec3 pos = position + velocity * time;
                            
                            // Wrap around
                            pos.z = mod(pos.z + 200.0, 400.0) - 200.0;
                            
                            // Fade based on distance
                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            float dist = length(mvPosition.xyz);
                            vAlpha = smoothstep(300.0, 50.0, dist) * 0.6;
                            
                            gl_PointSize = pixelRatio * 2.0 * (100.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        varying float vAlpha;
                        
                        void main() {
                            vec2 center = gl_PointCoord - vec2(0.5);
                            float dist = length(center);
                            if (dist > 0.5) discard;
                            
                            float alpha = (1.0 - dist * 2.0) * vAlpha;
                            gl_FragColor = vec4(vColor, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.spaceDust = new THREE.Points(geometry, dustMaterial);
                this.scene.add(this.spaceDust);
            }

            initPostProcessing() {
                // Effect Composer for post-processing
                this.composer = new THREE.EffectComposer(this.renderer);
                
                // Render pass
                const renderPass = new THREE.RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);
                
                // Bloom pass for HDR glow effect
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5,  // strength
                    0.4,  // radius
                    0.85  // threshold
                );
                this.composer.addPass(bloomPass);
                this.bloomPass = bloomPass;
            }

            initEventListeners() {
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Menu buttons
                document.getElementById('btn-start').addEventListener('click', () => {
                    this.startGame();
                });
                
                document.getElementById('btn-controls').addEventListener('click', () => {
                    this.showControlsModal();
                });
                
                document.getElementById('btn-settings').addEventListener('click', () => {
                    this.showSettingsModal();
                });

                // Controls modal close
                document.getElementById('controls-close').addEventListener('click', () => {
                    this.hideControlsModal();
                });

                document.getElementById('controls-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'controls-modal') {
                        this.hideControlsModal();
                    }
                });

                // Settings modal close and controls
                document.getElementById('settings-close').addEventListener('click', () => {
                    this.hideSettingsModal();
                });

                document.getElementById('settings-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'settings-modal') {
                        this.hideSettingsModal();
                    }
                });

                document.getElementById('settings-apply').addEventListener('click', () => {
                    this.applySettings();
                    this.hideSettingsModal();
                });

                // Difficulty buttons
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                });

                // Sensitivity slider
                document.getElementById('sensitivity-slider').addEventListener('input', (e) => {
                    document.getElementById('sensitivity-value').textContent = parseFloat(e.target.value).toFixed(1);
                });

                // Volume slider
                document.getElementById('volume-slider').addEventListener('input', (e) => {
                    document.getElementById('volume-value').textContent = e.target.value + '%';
                });

                // Toggle switches
                document.querySelectorAll('.toggle-switch').forEach(toggle => {
                    toggle.addEventListener('click', () => {
                        toggle.classList.toggle('active');
                    });
                });
                
                // Sound toggle button
                document.getElementById('sound-toggle').addEventListener('click', () => {
                    if (this.audioManager) {
                        const enabled = this.audioManager.toggleSound();
                        document.getElementById('sound-toggle').classList.toggle('muted', !enabled);
                    }
                });
                
                // Keyboard for debug and game controls
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'F3') {
                        e.preventDefault();
                        document.getElementById('fps-counter').classList.toggle('visible');
                    }
                    if (e.key === 'Escape') {
                        if (this.state === GameState.PLAYING) {
                            this.pauseGame();
                        } else if (this.state === GameState.PAUSED) {
                            this.resumeGame();
                        }
                    }
                    // M key to toggle mute
                    if (e.key === 'm' || e.key === 'M') {
                        if (this.audioManager) {
                            const enabled = this.audioManager.toggleSound();
                            document.getElementById('sound-toggle').classList.toggle('muted', !enabled);
                        }
                    }
                });
                
                // Game over buttons
                document.getElementById('btn-restart').addEventListener('click', () => {
                    this.restartGame();
                });
                
                document.getElementById('btn-to-menu').addEventListener('click', () => {
                    this.returnToMenu();
                });
                
                // Pause screen buttons
                document.getElementById('btn-resume').addEventListener('click', () => {
                    this.resumeGame();
                });
                
                document.getElementById('btn-quit').addEventListener('click', () => {
                    this.quitToMenu();
                });
            }

            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                
                this.renderer.setSize(width, height);
                this.composer.setSize(width, height);
            }

            startGame() {
                this.hideMainMenu();
                this.state = GameState.PLAYING;
                
                // Resume audio context (requires user interaction)
                if (this.audioManager) {
                    this.audioManager.resume();
                }
                
                // Show game UI
                document.getElementById('crosshair').classList.add('visible');
                document.getElementById('barrel-roll-indicator').classList.add('visible');
                document.getElementById('bomb-indicator').classList.add('visible');
                document.getElementById('wave-indicator').classList.add('visible');
                document.getElementById('score-display').classList.add('visible');
                document.getElementById('health-bar').classList.add('visible');
                document.getElementById('enemy-count').classList.add('visible');
                document.getElementById('power-level-display').classList.add('visible');
                document.getElementById('sound-toggle').classList.add('visible');
                
                // Reset player position
                if (this.player) {
                    this.player.position.set(0, 0, 0);
                    this.player.velocity.set(0, 0, 0);
                    this.player.health = this.player.maxHealth;
                    this.player.shields = this.player.maxShields;
                    this.player.invincible = false;
                    this.player.isBarrelRolling = false;
                    this.player.powerLevel = 0; // „Éë„ÉØ„Éº„É¨„Éô„É´„Çí„É™„Çª„ÉÉ„Éà
                    if (this.player.mesh) {
                        this.player.mesh.position.set(0, 0, 0);
                        this.player.mesh.rotation.set(0, 0, 0);
                        this.player.mesh.visible = true;
                    }
                }
                
                // Reset wave manager
                if (this.waveManager) {
                    this.waveManager.cleanup();
                    this.waveManager.currentWave = 0;
                    this.waveManager.score = 0;
                    this.waveManager.combo = 1;
                    this.waveManager.maxCombo = 1;
                    this.waveManager.waveActive = false;
                    this.waveManager.waveTimer = 0;
                    this.waveManager.updatePowerLevelUI(); // „Éë„ÉØ„Éº„É¨„Éô„É´UI„ÇíÊõ¥Êñ∞
                }
                
                console.log('Game started!');
            }

            pauseGame() {
                if (this.state === GameState.PLAYING) {
                    this.state = GameState.PAUSED;
                    
                    // Update pause screen stats
                    document.getElementById('pause-score').textContent = this.waveManager.score.toLocaleString();
                    document.getElementById('pause-wave').textContent = this.waveManager.currentWave;
                    
                    // Show pause screen
                    document.getElementById('pause-screen').classList.add('visible');
                }
            }

            resumeGame() {
                if (this.state === GameState.PAUSED) {
                    this.state = GameState.PLAYING;
                    document.getElementById('pause-screen').classList.remove('visible');
                }
            }

            quitToMenu() {
                document.getElementById('pause-screen').classList.remove('visible');
                this.returnToMenu();
            }

            updatePlayer(deltaTime, elapsedTime) {
                if (this.player && this.state === GameState.PLAYING) {
                    // Apply time scale from VFX
                    const timeScale = this.vfxManager ? this.vfxManager.getTimeScale() : 1;
                    const scaledDelta = deltaTime * timeScale;
                    
                    this.player.update(scaledDelta, this.input, elapsedTime);
                    this.updateCamera(scaledDelta);
                    
                    // Handle shooting
                    this.fireTimer += scaledDelta;
                    if ((this.input.mouse.leftButton || this.input.isKeyPressed('Space')) && this.fireTimer >= this.fireRate) {
                        this.waveManager.playerFire();
                        this.fireTimer = 0;
                    }
                    
                    // Handle bomb (B key) - „Ç≠„Éº„ÇíÊäº„ÅóÁõ¥„Åï„Å™„ÅÑ„Å®ÈÄ£Â∞Ñ„Åï„Çå„Å™„ÅÑ
                    if (this.player.bombCooldown > 0) {
                        this.player.bombCooldown -= scaledDelta;
                    }
                    const bombKeyDown = this.input.isKeyPressed('KeyB');
                    if (bombKeyDown && !this.bombKeyPressed && this.waveManager) {
                        this.waveManager.playerBomb();
                    }
                    this.bombKeyPressed = bombKeyDown;
                    
                    // Update wave manager
                    if (this.waveManager) {
                        this.waveManager.update(scaledDelta);
                    }
                    
                    // Update VFX
                    if (this.vfxManager) {
                        this.vfxManager.update(scaledDelta);
                        this.vfxManager.updateShake(scaledDelta);
                        
                        // Apply screen shake to camera
                        const shake = this.vfxManager.getShakeOffset();
                        this.camera.position.x += shake.x;
                        this.camera.position.y += shake.y;
                    }
                    
                    // Check game over
                    if (this.player.health <= 0) {
                        this.gameOver();
                    }
                }
            }

            gameOver() {
                this.state = GameState.GAME_OVER;
                
                // Hide game UI
                document.getElementById('crosshair').classList.remove('visible');
                document.getElementById('barrel-roll-indicator').classList.remove('visible');
                document.getElementById('bomb-indicator').classList.remove('visible');
                
                // Update final stats
                document.getElementById('final-score').textContent = this.waveManager.score.toLocaleString();
                document.getElementById('final-waves').textContent = this.waveManager.currentWave;
                document.getElementById('final-asteroids').textContent = this.waveManager.asteroidsDestroyed;
                document.getElementById('final-enemies').textContent = this.waveManager.enemiesDestroyed;
                
                // Show game over screen
                document.getElementById('game-over-screen').classList.add('visible');
            }

            restartGame() {
                // Hide game over screen
                document.getElementById('game-over-screen').classList.remove('visible');
                
                // Reset and start new game
                this.startGame();
            }

            returnToMenu() {
                // Hide game over screen
                document.getElementById('game-over-screen').classList.remove('visible');
                
                // Hide game UI
                document.getElementById('wave-indicator').classList.remove('visible');
                document.getElementById('score-display').classList.remove('visible');
                document.getElementById('health-bar').classList.remove('visible');
                document.getElementById('enemy-count').classList.remove('visible');
                document.getElementById('power-level-display').classList.remove('visible');
                document.getElementById('sound-toggle').classList.remove('visible');
                document.getElementById('bomb-indicator').classList.remove('visible');
                
                // Clean up
                if (this.waveManager) {
                    this.waveManager.cleanup();
                }
                
                // Show main menu
                this.showMainMenu();
            }

            // Controls Modal
            showControlsModal() {
                document.getElementById('controls-modal').classList.add('visible');
            }

            hideControlsModal() {
                document.getElementById('controls-modal').classList.remove('visible');
            }

            // Settings Modal
            showSettingsModal() {
                // Load current settings into UI
                this.loadSettingsToUI();
                document.getElementById('settings-modal').classList.add('visible');
            }

            hideSettingsModal() {
                document.getElementById('settings-modal').classList.remove('visible');
            }

            loadSettingsToUI() {
                // Difficulty
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.difficulty === GameSettings.difficulty) {
                        btn.classList.add('active');
                    }
                });

                // Sensitivity
                document.getElementById('sensitivity-slider').value = GameSettings.mouseSensitivity;
                document.getElementById('sensitivity-value').textContent = GameSettings.mouseSensitivity.toFixed(1);

                // Volume
                document.getElementById('volume-slider').value = GameSettings.masterVolume * 100;
                document.getElementById('volume-value').textContent = Math.round(GameSettings.masterVolume * 100) + '%';

                // Toggle switches
                document.getElementById('screenshake-toggle').classList.toggle('active', GameSettings.screenShake);
                document.getElementById('fps-toggle').classList.toggle('active', GameSettings.showFPS);
                document.getElementById('autofire-toggle').classList.toggle('active', GameSettings.autoFire);
                document.getElementById('inverty-toggle').classList.toggle('active', GameSettings.invertY);
            }

            applySettings() {
                // Difficulty
                const activeDiffBtn = document.querySelector('.difficulty-btn.active');
                if (activeDiffBtn) {
                    GameSettings.difficulty = activeDiffBtn.dataset.difficulty;
                }

                // Sensitivity
                GameSettings.mouseSensitivity = parseFloat(document.getElementById('sensitivity-slider').value);

                // Volume
                GameSettings.masterVolume = parseInt(document.getElementById('volume-slider').value) / 100;
                if (this.audioManager) {
                    this.audioManager.setMasterVolume(GameSettings.masterVolume);
                }

                // Toggle settings
                GameSettings.screenShake = document.getElementById('screenshake-toggle').classList.contains('active');
                GameSettings.showFPS = document.getElementById('fps-toggle').classList.contains('active');
                GameSettings.autoFire = document.getElementById('autofire-toggle').classList.contains('active');
                GameSettings.invertY = document.getElementById('inverty-toggle').classList.contains('active');

                // Apply FPS toggle immediately
                document.getElementById('fps-counter').classList.toggle('visible', GameSettings.showFPS);

                // Save settings
                GameSettings.save();

                console.log('Settings applied:', GameSettings);
            }

            updateFPS(elapsedTime) {
                this.fpsFrames++;
                
                if (elapsedTime - this.fpsLastTime >= 1) {
                    this.fpsDisplay = this.fpsFrames;
                    this.fpsFrames = 0;
                    this.fpsLastTime = elapsedTime;
                    
                    const fpsEl = document.getElementById('fps-counter');
                    fpsEl.textContent = `FPS: ${this.fpsDisplay}`;
                    
                    // Color based on performance
                    if (this.fpsDisplay >= 55) {
                        fpsEl.style.color = 'rgba(0, 255, 100, 0.7)';
                    } else if (this.fpsDisplay >= 30) {
                        fpsEl.style.color = 'rgba(255, 200, 0, 0.7)';
                    } else {
                        fpsEl.style.color = 'rgba(255, 50, 50, 0.7)';
                    }
                }
            }

            updateCamera(deltaTime) {
                if (!this.player) return;
                
                // Á∏¶„Çπ„ÇØ„É≠„Éº„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞È¢®„ÅÆ„Ç´„É°„É© - „Çà„ÇäÂ∫É„ÅÑËøΩÂæì
                // „Éó„É¨„Ç§„É§„Éº„ÅÆ‰ΩçÁΩÆ„Å´Âøú„Åò„Å¶„Ç´„É°„É©„ÇÇÂãï„ÅèÔºà„ÉÄ„Ç§„Éä„Éü„ÉÉ„ÇØ„Å™ËøΩÂæìÔºâ
                const targetX = this.player.position.x * 0.4; // Â∑¶Âè≥„Å´„Çà„ÇäËøΩÂæì
                const targetY = 28 + this.player.position.y * 0.3; // È´ò„ÅïË™øÊï¥
                const targetZ = 50 + this.player.position.z; // ZÊñπÂêë„ÇíËøΩÂæì
                
                // „Çπ„É†„Éº„Ç∫„Å´„Ç´„É°„É©„ÇíÁßªÂãïÔºà„Çà„ÇäÊªë„Çâ„Åã„Å´Ôºâ
                this.camera.position.x += (targetX - this.camera.position.x) * deltaTime * 4;
                this.camera.position.y += (targetY - this.camera.position.y) * deltaTime * 3;
                this.camera.position.z += (targetZ - this.camera.position.z) * deltaTime * 3;
                
                // „Éó„É¨„Ç§„É§„Éº„ÅÆÂâçÊñπ„ÇíË¶ã„ÇãÔºà„Çà„ÇäËá™ÁÑ∂„Å™Ë¶ñÁÇπÔºâ
                const lookTarget = new THREE.Vector3(
                    this.player.position.x * 0.6,
                    this.player.position.y * 0.4,
                    this.player.position.z - 60 // ÂâçÊñπ„ÇíË¶ã„Çã
                );
                this.camera.lookAt(lookTarget);
            }

            updateEnvironment(deltaTime, elapsedTime) {
                // Update star layers (parallax rotation)
                this.starLayers.forEach((layer, index) => {
                    layer.rotation.y += deltaTime * 0.01 * layer.userData.speed;
                    layer.material.uniforms.time.value = elapsedTime;
                });
                
                // Update nebulas
                this.nebulas.forEach(nebula => {
                    nebula.rotation.z += deltaTime * 0.02;
                    nebula.children.forEach(child => {
                        if (child.userData.rotationSpeed) {
                            child.rotation.x += child.userData.rotationSpeed.x;
                            child.rotation.y += child.userData.rotationSpeed.y;
                        }
                    });
                });
                
                // Update space dust
                if (this.spaceDust) {
                    this.spaceDust.material.uniforms.time.value = elapsedTime * 10;
                }
                
                // Update dimensional rift (Wave 5+)
                if (this.waveManager && this.waveManager.dimensionalRift) {
                    this.waveManager.dimensionalRift.traverse(child => {
                        if (child.userData.isDimensionalRing) {
                            child.rotation.z += child.userData.rotSpeed;
                        }
                        if (child.userData.isDimensionalParticles && child.geometry) {
                            // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´„ÇíÂõûËª¢„Åï„Åõ„Çã
                            child.rotation.y += deltaTime * 0.1;
                        }
                    });
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.deltaTime = this.clock.getDelta();
                this.elapsedTime = this.clock.getElapsedTime();
                
                // Cap delta time to prevent physics issues
                this.deltaTime = Math.min(this.deltaTime, 0.1);
                
                // Update environment
                this.updateEnvironment(this.deltaTime, this.elapsedTime);
                
                // Update based on game state
                if (this.state === GameState.MENU) {
                    // Gentle camera movement for menu
                    this.camera.position.x = Math.sin(this.elapsedTime * 0.1) * 5;
                    this.camera.position.y = 15 + Math.cos(this.elapsedTime * 0.15) * 2;
                    this.camera.position.z = 30;
                    this.camera.lookAt(0, 0, -50);
                    
                    // Hide player in menu
                    if (this.player && this.player.mesh) {
                        this.player.mesh.visible = false;
                    }
                } else if (this.state === GameState.PLAYING) {
                    // Show player
                    if (this.player && this.player.mesh) {
                        this.player.mesh.visible = true;
                    }
                    
                    // Update player
                    this.updatePlayer(this.deltaTime, this.elapsedTime);
                    
                    // Update camera to follow player
                    this.updateCamera(this.deltaTime);
                }
                
                // Update FPS counter
                this.updateFPS(this.elapsedTime);
                
                // Render - temporarily disable post-processing for debug
                this.renderer.render(this.scene, this.camera);
                // if (this.composer) {
                //     this.composer.render(this.deltaTime);
                // }
            }
        }

        // Initialize game when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new StellarAssault();
        });
    </script>
</body>
</html>
